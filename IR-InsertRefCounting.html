<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>IR.InsertRefCounting</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sslang-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="src/IR.InsertRefCounting.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">IR.InsertRefCounting</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">The external interface</a></li><li><a href="#g:2">Module internals, not intended for use outside this module</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This inserts <code>dup</code> and <code>drop</code> primitives according to a caller <code>dup</code>,
callee <code>drop</code> policy.  The value returned by a function should be
passed back referenced (ownership transfers from the callee back to
the caller).</p><p>The <code>dup : a -&gt; a</code> primitive behaves like the identity function,
evaluating and returning its first argument and increasing the
reference count on the result.  It is meant to be wrapped around
function arguments.</p><p>The <code>drop : a -&gt; b -&gt; a</code> primitive evaluates and returns its first
argument.  It decrements the reference count to its second argument
after it has evaluated its first argument.  It is meant to be wrapped
around function bodies that need to use and then de-reference their
arguments.</p><p>Thus, something like</p><pre>add a b = a + b</pre><p>becomes</p><pre>add a b =
  drop
    (drop
       ((dup a) + (dup b))
       b)
    a
</pre><p>Arguments <code>a</code> and <code>b</code> to the <code>+</code> primitive are duplicated and the
result of <code>+</code> is duplicated internally, so <code>add</code> does not need to
duplicate its result.  Both arguments <code>a</code> and <code>b</code> are dropped.</p><p>Try running <code>sslc --dump-ir-final</code> on an example to see the inserted
<code>dup</code> and <code>drop</code> constructs.</p><p>Our approach was inspired by Perceus
<a href="https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/">https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/</a></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:insertRefCounting">insertRefCounting</a> :: <a href="IR-IR.html#t:Program" title="IR.IR">Program</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="Common-Compiler.html#t:Pass" title="Common.Compiler">Pass</a> (<a href="IR-IR.html#t:Program" title="IR.IR">Program</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Fresh">Fresh</a> = <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> <a href="../base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="Common-Compiler.html#t:Pass" title="Common.Compiler">Pass</a></li><li class="src short"><a href="#v:getFresh">getFresh</a> :: <a href="../base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> <a href="Common-Identifiers.html#t:VarId" title="Common.Identifiers">VarId</a></li><li class="src short"><a href="#v:makeDup">makeDup</a> :: <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></li><li class="src short"><a href="#v:makeDrop">makeDrop</a> :: <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></li><li class="src short"><a href="#v:insertTop">insertTop</a> :: (<a href="Common-Identifiers.html#t:VarId" title="Common.Identifiers">VarId</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> (<a href="Common-Identifiers.html#t:VarId" title="Common.Identifiers">VarId</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>)</li><li class="src short"><a href="#v:insertExpr">insertExpr</a> :: <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> (<a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>)</li><li class="src short"><a href="#v:insertAlt">insertAlt</a> :: (<a href="IR-IR.html#t:Alt" title="IR.IR">Alt</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> (<a href="IR-IR.html#t:Alt" title="IR.IR">Alt</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>The external interface</h1></a><div class="doc empty">&nbsp;</div><div class="top"><p class="src"><a id="v:insertRefCounting" class="def">insertRefCounting</a> :: <a href="IR-IR.html#t:Program" title="IR.IR">Program</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="Common-Compiler.html#t:Pass" title="Common.Compiler">Pass</a> (<a href="IR-IR.html#t:Program" title="IR.IR">Program</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) <a href="src/IR.InsertRefCounting.html#insertRefCounting" class="link">Source</a> <a href="#v:insertRefCounting" class="selflink">#</a></p><div class="doc"><p>Insert dup and drop primitives throughout a program</p><p>Applies <code><a href="IR-InsertRefCounting.html#v:insertTop" title="IR.InsertRefCounting">insertTop</a></code> to the program's definitions</p></div></div><a href="#g:2" id="g:2"><h1>Module internals, not intended for use outside this module</h1></a><div class="doc empty">&nbsp;</div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Fresh" class="def">Fresh</a> = <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> <a href="../base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="Common-Compiler.html#t:Pass" title="Common.Compiler">Pass</a> <a href="src/IR.InsertRefCounting.html#Fresh" class="link">Source</a> <a href="#t:Fresh" class="selflink">#</a></p><div class="doc"><p>Monad for creating fresh variables: add an Int to the pass</p></div></div><div class="top"><p class="src"><a id="v:getFresh" class="def">getFresh</a> :: <a href="../base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> <a href="Common-Identifiers.html#t:VarId" title="Common.Identifiers">VarId</a> <a href="src/IR.InsertRefCounting.html#getFresh" class="link">Source</a> <a href="#v:getFresh" class="selflink">#</a></p><div class="doc"><p>Create a fresh variable name with the given suffix</p><p>Creates a new variable ID of the form &quot;anon1,&quot; &quot;anon2,&quot;
 etc. followed by the supplied suffix</p></div></div><div class="top"><p class="src"><a id="v:makeDup" class="def">makeDup</a> <a href="src/IR.InsertRefCounting.html#makeDup" class="link">Source</a> <a href="#v:makeDup" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></td><td class="doc"><p>The variable to duplicate and return</p></td></tr><tr><td class="src">-&gt; <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></td><td class="doc"><p>The <code>dup</code> call</p></td></tr></table></div><div class="doc"><p>Make a dup primitive that returns the type of its argument</p></div></div><div class="top"><p class="src"><a id="v:makeDrop" class="def">makeDrop</a> <a href="src/IR.InsertRefCounting.html#makeDrop" class="link">Source</a> <a href="#v:makeDrop" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></td><td class="doc"><p>The expression to evaluate and return</p></td></tr><tr><td class="src">-&gt; <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></td><td class="doc"><p>The variable to drop afterwards</p></td></tr><tr><td class="src">-&gt; <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a></td><td class="doc"><p>The <code>drop</code> call</p></td></tr></table></div><div class="doc"><p>Make a drop primitive with unit type</p></div></div><div class="doc empty">&nbsp;</div><div class="top"><p class="src"><a id="v:insertTop" class="def">insertTop</a> :: (<a href="Common-Identifiers.html#t:VarId" title="Common.Identifiers">VarId</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> (<a href="Common-Identifiers.html#t:VarId" title="Common.Identifiers">VarId</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) <a href="src/IR.InsertRefCounting.html#insertTop" class="link">Source</a> <a href="#v:insertTop" class="selflink">#</a></p><div class="doc"><p>Insert referencing counting for top-level expressions</p><p>Applies <code><a href="IR-InsertRefCounting.html#v:insertExpr" title="IR.InsertRefCounting">insertExpr</a></code> to a top-level delcaration</p></div></div><div class="top"><p class="src"><a id="v:insertExpr" class="def">insertExpr</a> :: <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a> -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> (<a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) <a href="src/IR.InsertRefCounting.html#insertExpr" class="link">Source</a> <a href="#v:insertExpr" class="selflink">#</a></p><div class="doc"><p>Insert reference counting into an expression</p><p>This is the main workhorse of this module.</p><ul><li><strong>Literals</strong> are unchanged, e.g.,</li></ul><pre>42</pre><p>remains</p><pre>42</pre><ul><li><strong>Data constructors</strong> are unchanged, e.g.,</li></ul><pre>True</pre><p>remains</p><pre>True</pre><p>because they are functions whose results are returned with an existing reference</p><ul><li>A <strong>variable reference</strong> becomes a call to dup because it introduces
  another reference to the named object, e.g.,</li></ul><pre>v</pre><p>becomes</p><pre>dup v</pre><ul><li><strong>Application</strong> recurses (inserts dups and drops) on both the
  function being applied and its argument e.g.,</li></ul><pre>add x y</pre><p>becomes</p><pre>(dup add) (dup x) (dup y)</pre><ul><li><strong>Primitive</strong> function application inserts dups and drops on its
  arguments, e.g.,</li></ul><pre>(+) x y</pre><p>becomes</p><pre>(+) (dup x) (dup y)</pre><ul><li><strong>Let</strong> introduces new names whose values are dropped after the body
  is evaluated; <code>let _ =</code> are given names so they can be dropped.</li></ul><pre>let a = Foo 42
    _ = a
17</pre><p>becomes</p><pre>let a = Foo 42
drop
  (let anon1_underscore = dup a
   drop
     17
     anon1_underscore)
  a</pre><ul><li>Nested <strong>Lambda</strong> expressions are handled by collecting them into a
  single expression with multiple arguments, adding dups and drops to
  the body, and adding drops around the body for each argument (which
  the caller should have duped)</li></ul><pre>add a b = a + b</pre><p>desugars to</p><pre>add = fun a (fun b (a + b))</pre><p>and becomes</p><pre>add = fun a (
        fun b (
           drop (
              drop (
                (dup a) + (dup b)
              ) b
           ) a
</pre><ul><li><strong>Matches</strong> that operate on a variable are modified by inserting
 dups and drops into the arms (but not the scrutinee)</li></ul><pre>match v
  Foo x = x + 1
  Bar = 42
</pre><p>desugars to</p><pre>match v
  Foo pat_anon0 = let x = pat_anon0
                    x + 1
  Bar = 42
</pre><p>then becomes</p><pre>match v
  Foo pat_anon0 = drop
                    dup pat_anon0
                    let x = dup pat_anon0
                    drop (
                       dup x + 1
                    ) x
                  ) pat_anon0
  Bar = 42
</pre><ul><li><strong>Matches</strong> that scrutinize an expression lift the scrutinee
  into a <code>let</code> then insert dups and drops on the whole thing</li></ul><pre>  match add x y
    10 = 5
    _ = 3
</pre><p>becomes</p><pre>  let anon0_scrutinee = (dup add) (dup x) (dup y)
  drop (
    match anon0_scrutinee
      10 = 5
      _ = 3
  ) anon0_scruitinee
</pre></div></div><div class="top"><p class="src"><a id="v:insertAlt" class="def">insertAlt</a> :: (<a href="IR-IR.html#t:Alt" title="IR.IR">Alt</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) -&gt; <a href="IR-InsertRefCounting.html#t:Fresh" title="IR.InsertRefCounting">Fresh</a> (<a href="IR-IR.html#t:Alt" title="IR.IR">Alt</a>, <a href="IR-IR.html#t:Expr" title="IR.IR">Expr</a> <a href="IR-Types-Type.html#t:Type" title="IR.Types.Type">Type</a>) <a href="src/IR.InsertRefCounting.html#insertAlt" class="link">Source</a> <a href="#v:insertAlt" class="selflink">#</a></p><div class="doc"><p>Insert dups and drops into pattern match arms</p><p>The body of default and literal patterns is simply recursed upon.</p><p>Every named variable in a pattern is duped and dropped, e.g.,</p><pre>match v
  Foo x = expr
</pre><p>becomes</p><pre>match v
  Foo _anon1 = drop
                 (let x = dup _anon1
                  expr
               ) x
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>