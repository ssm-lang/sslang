<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DerivingVia #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-3"></span><span>
</span><span id="line-4"></span><span class="hs-comment">{-| Description : Insert reference counting primitives

This inserts @dup@ and @drop@ primitives according to a caller @dup@,
callee @drop@ policy.  The value returned by a function should be
passed back referenced (ownership transfers from the callee back to
the caller).

The @dup : a -&gt; a@ primitive behaves like the identity function,
evaluating and returning its first argument and increasing the
reference count on the result.  It is meant to be wrapped around
function arguments.

The @drop : a -&gt; b -&gt; a@ primitive evaluates and returns its first
argument.  It decrements the reference count to its second argument
after it has evaluated its first argument.  It is meant to be wrapped
around function bodies that need to use and then de-reference their
arguments.

Thus, something like

&gt; add a b = a + b

becomes

@
add a b =
  drop
    (drop
       ((dup a) + (dup b))
       b)
    a
@

Arguments @a@ and @b@ to the @+@ primitive are duplicated and the
result of @+@ is duplicated internally, so @add@ does not need to
duplicate its result.  Both arguments @a@ and @b@ are dropped.

Try running @sslc --dump-ir-final@ on an example to see the inserted
@dup@ and @drop@ constructs.

Our approach was inspired by Perceus
&lt;https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/&gt;

-}</span><span>
</span><span id="line-48"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">IR.InsertRefCounting</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Common.Compiler.html"><span class="hs-identifier">Common.Compiler</span></a></span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Compiler</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Common.Identifiers.html"><span class="hs-identifier">Common.Identifiers</span></a></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.State.Lazy</span></span><span>       </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">MonadState</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">StateT</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">evalStateT</span></span><span>
</span><span id="line-55"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">forM</span></span><span>
</span><span id="line-56"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">modify</span></span><span>
</span><span id="line-57"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>                     </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">fromJust</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="IR.IR.html"><span class="hs-identifier">IR.IR</span></a></span><span>                         </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">I</span></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="IR.Types.html"><span class="hs-identifier">IR.Types</span></a></span><span>                      </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">I</span></span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="hs-comment">-- * The external interface</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- $external</span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span class="hs-comment">-- | Insert dup and drop primitives throughout a program</span><span>
</span><span id="line-68"></span><span class="hs-comment">--</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- Applies `insertTop` to the program's definitions</span><span>
</span><span id="line-70"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertRefCounting"><span class="hs-identifier hs-type">insertRefCounting</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Program"><span class="hs-identifier hs-type">I.Program</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.Compiler.html#Pass"><span class="hs-identifier hs-type">Compiler.Pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Program"><span class="hs-identifier hs-type">I.Program</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span id="insertRefCounting"><span class="annot"><span class="annottext">insertRefCounting :: Program Type -&gt; Pass (Program Type)
</span><a href="IR.InsertRefCounting.html#insertRefCounting"><span class="hs-identifier hs-var hs-var">insertRefCounting</span></a></span></span><span> </span><span id="local-6989586621679567429"><span class="annot"><span class="annottext">Program Type
</span><a href="#local-6989586621679567429"><span class="hs-identifier hs-var">program</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">StateT Int Pass (Program Type) -&gt; Int -&gt; Pass (Program Type)
forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m a
</span><span class="hs-operator hs-var">`evalStateT`</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(StateT Int Pass (Program Type) -&gt; Pass (Program Type))
-&gt; StateT Int Pass (Program Type) -&gt; Pass (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679567428"><span class="annot"><span class="annottext">programDefs :: [(VarId, Expr Type)]
</span><a href="#local-6989586621679567428"><span class="hs-identifier hs-var hs-var">programDefs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Program Type -&gt; [(VarId, Expr Type)]
forall t. Program t -&gt; [(VarId, Expr t)]
</span><a href="IR.IR.html#programDefs"><span class="hs-identifier hs-var hs-var">I.programDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program Type
</span><a href="#local-6989586621679567429"><span class="hs-identifier hs-var">program</span></a></span><span>
</span><span id="line-73"></span><span>  </span><span id="local-6989586621679567426"><span class="annot"><span class="annottext">[(VarId, Expr Type)]
</span><a href="#local-6989586621679567426"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">((VarId, Expr Type) -&gt; StateT Int Pass (VarId, Expr Type))
-&gt; [(VarId, Expr Type)] -&gt; StateT Int Pass [(VarId, Expr Type)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(VarId, Expr Type) -&gt; StateT Int Pass (VarId, Expr Type)
</span><a href="IR.InsertRefCounting.html#insertTop"><span class="hs-identifier hs-var">insertTop</span></a></span><span> </span><span class="annot"><span class="annottext">[(VarId, Expr Type)]
</span><a href="#local-6989586621679567428"><span class="hs-identifier hs-var">programDefs</span></a></span><span>
</span><span id="line-74"></span><span>  </span><span class="annot"><span class="annottext">Program Type -&gt; StateT Int Pass (Program Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Program Type -&gt; StateT Int Pass (Program Type))
-&gt; Program Type -&gt; StateT Int Pass (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program Type
</span><a href="#local-6989586621679567429"><span class="hs-identifier hs-var">program</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">programDefs :: [(VarId, Expr Type)]
</span><a href="IR.IR.html#programDefs"><span class="hs-identifier hs-var">I.programDefs</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(VarId, Expr Type)]
</span><a href="#local-6989586621679567426"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-75"></span><span>                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">programEntry :: VarId
</span><a href="IR.IR.html#programEntry"><span class="hs-identifier hs-var">I.programEntry</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Program Type -&gt; VarId
forall t. Program t -&gt; VarId
</span><a href="IR.IR.html#programEntry"><span class="hs-identifier hs-var hs-var">I.programEntry</span></a></span><span> </span><span class="annot"><span class="annottext">Program Type
</span><a href="#local-6989586621679567429"><span class="hs-identifier hs-var">program</span></a></span><span>
</span><span id="line-76"></span><span>                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">typeDefs :: [(TConId, TypeDef)]
</span><a href="IR.IR.html#typeDefs"><span class="hs-identifier hs-var">I.typeDefs</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Program Type -&gt; [(TConId, TypeDef)]
forall t. Program t -&gt; [(TConId, TypeDef)]
</span><a href="IR.IR.html#typeDefs"><span class="hs-identifier hs-var hs-var">I.typeDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program Type
</span><a href="#local-6989586621679567429"><span class="hs-identifier hs-var">program</span></a></span><span>
</span><span id="line-77"></span><span>                   </span><span class="hs-special">}</span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span class="hs-comment">-- * Module internals, not intended for use outside this module</span><span>
</span><span id="line-81"></span><span class="hs-comment">--</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- $internal</span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span class="hs-comment">-- | Monad for creating fresh variables: add an Int to the pass</span><span>
</span><span id="line-86"></span><span class="hs-keyword">type</span><span> </span><span id="Fresh"><span class="annot"><a href="IR.InsertRefCounting.html#Fresh"><span class="hs-identifier hs-var">Fresh</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><a href="Common.Compiler.html#Pass"><span class="hs-identifier hs-type">Compiler.Pass</span></a></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span class="hs-comment">-- | Create a fresh variable name with the given suffix</span><span>
</span><span id="line-89"></span><span class="hs-comment">--</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- Creates a new variable ID of the form &quot;anon1,&quot; &quot;anon2,&quot;</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- etc. followed by the supplied suffix</span><span>
</span><span id="line-92"></span><span class="annot"><a href="IR.InsertRefCounting.html#getFresh"><span class="hs-identifier hs-type">getFresh</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.InsertRefCounting.html#Fresh"><span class="hs-identifier hs-type">Fresh</span></a></span><span> </span><span class="annot"><a href="Common.Identifiers.html#VarId"><span class="hs-identifier hs-type">I.VarId</span></a></span><span>
</span><span id="line-93"></span><span id="getFresh"><span class="annot"><span class="annottext">getFresh :: String -&gt; Fresh VarId
</span><a href="IR.InsertRefCounting.html#getFresh"><span class="hs-identifier hs-var hs-var">getFresh</span></a></span></span><span> </span><span id="local-6989586621679567420"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679567420"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-94"></span><span>  </span><span id="local-6989586621679567419"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679567419"><span class="hs-identifier hs-var">curCount</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT Int Pass Int
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-95"></span><span>  </span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; StateT Int Pass ()
forall s (m :: * -&gt; *). MonadState s m =&gt; (s -&gt; s) -&gt; m ()
</span><span class="hs-identifier hs-var">modify</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span>  </span><span class="annot"><span class="annottext">VarId -&gt; Fresh VarId
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(VarId -&gt; Fresh VarId) -&gt; VarId -&gt; Fresh VarId
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; VarId
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; VarId) -&gt; String -&gt; VarId
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;anon&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679567419"><span class="hs-identifier hs-var">curCount</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679567420"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | Make a dup primitive that returns the type of its argument</span><span>
</span><span id="line-99"></span><span class="annot"><a href="IR.InsertRefCounting.html#makeDup"><span class="hs-identifier hs-type">makeDup</span></a></span><span>
</span><span id="line-100"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-comment">-- ^ The variable to duplicate and return</span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-comment">-- ^ The @dup@ call</span><span>
</span><span id="line-102"></span><span id="makeDup"><span class="annot"><span class="annottext">makeDup :: Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDup"><span class="hs-identifier hs-var hs-var">makeDup</span></a></span></span><span> </span><span id="local-6989586621679567414"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567414"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Primitive -&gt; [Expr Type] -&gt; Type -&gt; Expr Type
forall t. Primitive -&gt; [Expr t] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Prim"><span class="hs-identifier hs-var">I.Prim</span></a></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Dup"><span class="hs-identifier hs-var">I.Dup</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567414"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type) -&gt; Type -&gt; Expr Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">I.extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567414"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="hs-comment">-- | Make a drop primitive with unit type</span><span>
</span><span id="line-105"></span><span class="annot"><a href="IR.InsertRefCounting.html#makeDrop"><span class="hs-identifier hs-type">makeDrop</span></a></span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-comment">-- ^ The expression to evaluate and return</span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-comment">-- ^ The variable to drop afterwards</span><span>
</span><span id="line-108"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-comment">-- ^ The @drop@ call</span><span>
</span><span id="line-109"></span><span id="makeDrop"><span class="annot"><span class="annottext">makeDrop :: Expr Type -&gt; Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDrop"><span class="hs-identifier hs-var hs-var">makeDrop</span></a></span></span><span> </span><span id="local-6989586621679567409"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567409"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679567408"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567408"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Primitive -&gt; [Expr Type] -&gt; Type -&gt; Expr Type
forall t. Primitive -&gt; [Expr t] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Prim"><span class="hs-identifier hs-var">I.Prim</span></a></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Drop"><span class="hs-identifier hs-var">I.Drop</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567408"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567409"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Type.html#Unit"><span class="hs-identifier hs-var">I.Unit</span></a></span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span>
</span><span id="line-113"></span><span class="hs-comment">-- $internal</span><span>
</span><span id="line-114"></span><span>
</span><span id="line-115"></span><span class="hs-comment">-- | Insert referencing counting for top-level expressions</span><span>
</span><span id="line-116"></span><span class="hs-comment">--</span><span>
</span><span id="line-117"></span><span class="hs-comment">-- Applies `insertExpr` to a top-level delcaration</span><span>
</span><span id="line-118"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertTop"><span class="hs-identifier hs-type">insertTop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#VarId"><span class="hs-identifier hs-type">I.VarId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.InsertRefCounting.html#Fresh"><span class="hs-identifier hs-type">Fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#VarId"><span class="hs-identifier hs-type">I.VarId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-119"></span><span id="insertTop"><span class="annot"><span class="annottext">insertTop :: (VarId, Expr Type) -&gt; StateT Int Pass (VarId, Expr Type)
</span><a href="IR.InsertRefCounting.html#insertTop"><span class="hs-identifier hs-var hs-var">insertTop</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679567405"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567405"><span class="hs-identifier hs-var">var</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567404"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567404"><span class="hs-identifier hs-var">expr</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567405"><span class="hs-identifier hs-var">var</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; (VarId, Expr Type))
-&gt; StateT Int Pass (Expr Type)
-&gt; StateT Int Pass (VarId, Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567404"><span class="hs-identifier hs-var">expr</span></a></span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-comment">{- | Insert reference counting into an expression

This is the main workhorse of this module.

* __Literals__ are unchanged, e.g.,

&gt; 42

remains

&gt; 42

* __Data constructors__ are unchanged, e.g.,

&gt; True

remains

&gt; True

because they are functions whose results are returned with an existing reference
  
* A __variable reference__ becomes a call to dup because it introduces
  another reference to the named object, e.g.,

&gt; v

becomes

&gt; dup v

* __Application__ recurses (inserts dups and drops) on both the
  function being applied and its argument e.g.,

&gt; add x y

becomes

&gt; (dup add) (dup x) (dup y)

* __Primitive__ function application inserts dups and drops on its
  arguments, e.g.,

&gt; (+) x y

becomes

&gt; (+) (dup x) (dup y)

* __Let__ introduces new names whose values are dropped after the body
  is evaluated; @let _ =@ are given names so they can be dropped.

&gt; let a = Foo 42
&gt;     _ = a
&gt; 17

becomes

&gt; let a = Foo 42
&gt; drop
&gt;   (let anon1_underscore = dup a
&gt;    drop
&gt;      17
&gt;      anon1_underscore)
&gt;   a

* Nested __Lambda__ expressions are handled by collecting them into a
  single expression with multiple arguments, adding dups and drops to
  the body, and adding drops around the body for each argument (which
  the caller should have duped)

&gt; add a b = a + b

desugars to

&gt; add = fun a (fun b (a + b))

and becomes

@
add = fun a (
        fun b (
           drop (
              drop (
                (dup a) + (dup b)
              ) b
           ) a
@

* __Matches__ that operate on a variable are modified by inserting
 dups and drops into the arms (but not the scrutinee)

@
match v
  Foo x = x + 1
  Bar = 42
@

desugars to

@
match v
  Foo pat_anon0 = let x = pat_anon0
                    x + 1
  Bar = 42
@

then becomes

@
match v
  Foo pat_anon0 = drop
                    dup pat_anon0
                    let x = dup pat_anon0
                    drop (
                       dup x + 1
                    ) x
                  ) pat_anon0
  Bar = 42
@

* __Matches__ that scrutinize an expression lift the scrutinee
  into a @let@ then insert dups and drops on the whole thing

@
  match add x y
    10 = 5
    _ = 3
@

becomes

@
  let anon0_scrutinee = (dup add) (dup x) (dup y)
  drop (
    match anon0_scrutinee
      10 = 5
      _ = 3
  ) anon0_scruitinee
@

-}</span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span class="hs-comment">--</span><span>
</span><span id="line-265"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-type">insertExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.InsertRefCounting.html#Fresh"><span class="hs-identifier hs-type">Fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span id="insertExpr"><span class="annot"><span class="annottext">insertExpr :: Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var hs-var">insertExpr</span></a></span></span><span> </span><span id="local-6989586621679567401"><span class="annot"><span class="annottext">dcon :: Expr Type
</span><a href="#local-6989586621679567401"><span class="hs-identifier hs-var">dcon</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="IR.IR.html#Data"><span class="hs-identifier hs-type">I.Data</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567401"><span class="hs-identifier hs-var">dcon</span></a></span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span id="local-6989586621679567399"><span class="annot"><span class="annottext">lit :: Expr Type
</span><a href="#local-6989586621679567399"><span class="hs-identifier hs-var">lit</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="IR.IR.html#Lit"><span class="hs-identifier hs-type">I.Lit</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567399"><span class="hs-identifier hs-var">lit</span></a></span><span>
</span><span id="line-270"></span><span>
</span><span id="line-271"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span id="local-6989586621679567397"><span class="annot"><span class="annottext">var :: Expr Type
</span><a href="#local-6989586621679567397"><span class="hs-identifier hs-var">var</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="IR.IR.html#Var"><span class="hs-identifier hs-type">I.Var</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; StateT Int Pass (Expr Type))
-&gt; Expr Type -&gt; StateT Int Pass (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDup"><span class="hs-identifier hs-var">makeDup</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567397"><span class="hs-identifier hs-var">var</span></a></span><span>
</span><span id="line-272"></span><span>
</span><span id="line-273"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#App"><span class="hs-identifier hs-type">I.App</span></a></span><span> </span><span id="local-6989586621679567394"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567394"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679567393"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567393"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679567392"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567392"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#App"><span class="hs-identifier hs-var">I.App</span></a></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; Expr Type -&gt; Type -&gt; Expr Type)
-&gt; StateT Int Pass (Expr Type)
-&gt; StateT Int Pass (Expr Type -&gt; Type -&gt; Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567394"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">StateT Int Pass (Expr Type -&gt; Type -&gt; Expr Type)
-&gt; StateT Int Pass (Expr Type)
-&gt; StateT Int Pass (Type -&gt; Expr Type)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567393"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">StateT Int Pass (Type -&gt; Expr Type)
-&gt; StateT Int Pass Type -&gt; StateT Int Pass (Expr Type)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; StateT Int Pass Type
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567392"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Prim"><span class="hs-identifier hs-type">I.Prim</span></a></span><span> </span><span id="local-6989586621679567391"><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679567391"><span class="hs-identifier hs-var">p</span></a></span></span><span>    </span><span id="local-6989586621679567390"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679567390"><span class="hs-identifier hs-var">es</span></a></span></span><span>   </span><span id="local-6989586621679567389"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567389"><span class="hs-identifier hs-var">typ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Primitive -&gt; [Expr Type] -&gt; Type -&gt; Expr Type
forall t. Primitive -&gt; [Expr t] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Prim"><span class="hs-identifier hs-var">I.Prim</span></a></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679567391"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">([Expr Type] -&gt; Type -&gt; Expr Type)
-&gt; StateT Int Pass [Expr Type]
-&gt; StateT Int Pass (Type -&gt; Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; StateT Int Pass (Expr Type))
-&gt; [Expr Type] -&gt; StateT Int Pass [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679567390"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="annot"><span class="annottext">StateT Int Pass (Type -&gt; Expr Type)
-&gt; StateT Int Pass Type -&gt; StateT Int Pass (Expr Type)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; StateT Int Pass Type
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567389"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-276"></span><span>
</span><span id="line-277"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Let"><span class="hs-identifier hs-type">I.Let</span></a></span><span>  </span><span id="local-6989586621679567387"><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679567387"><span class="hs-identifier hs-var">bins</span></a></span></span><span> </span><span id="local-6989586621679567386"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567386"><span class="hs-identifier hs-var">expr</span></a></span></span><span> </span><span id="local-6989586621679567385"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567385"><span class="hs-identifier hs-var">typ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-278"></span><span>  </span><span id="local-6989586621679567384"><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679567384"><span class="hs-identifier hs-var">bins'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
-&gt; ((Binder, Expr Type) -&gt; StateT Int Pass (Binder, Expr Type))
-&gt; StateT Int Pass [(Binder, Expr Type)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679567387"><span class="hs-identifier hs-var">bins</span></a></span><span> </span><span class="annot"><span class="annottext">(Binder, Expr Type) -&gt; StateT Int Pass (Binder, Expr Type)
</span><a href="#local-6989586621679567383"><span class="hs-identifier hs-var">droppedBinder</span></a></span><span>
</span><span id="line-279"></span><span>  </span><span id="local-6989586621679567382"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567382"><span class="hs-identifier hs-var">expr'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567386"><span class="hs-identifier hs-var">expr</span></a></span><span>
</span><span id="line-280"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; StateT Int Pass (Expr Type))
-&gt; Expr Type -&gt; StateT Int Pass (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)] -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. [(Binder, Expr t)] -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Let"><span class="hs-identifier hs-var">I.Let</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679567384"><span class="hs-identifier hs-var">bins'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((Binder, Expr Type) -&gt; Expr Type -&gt; Expr Type)
-&gt; Expr Type -&gt; [(Binder, Expr Type)] -&gt; Expr Type
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDrop"><span class="hs-identifier hs-var">makeDrop</span></a></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; Expr Type -&gt; Expr Type)
-&gt; ((Binder, Expr Type) -&gt; Expr Type)
-&gt; (Binder, Expr Type)
-&gt; Expr Type
-&gt; Expr Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Binder, Expr Type) -&gt; Expr Type
forall t. (Binder, Expr t) -&gt; Expr t
</span><a href="#local-6989586621679567379"><span class="hs-identifier hs-var">varFromBind</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567382"><span class="hs-identifier hs-var">expr'</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679567384"><span class="hs-identifier hs-var">bins'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567385"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-281"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-282"></span><span>  </span><span id="local-6989586621679567379"><span class="annot"><span class="annottext">varFromBind :: (Binder, Expr t) -&gt; Expr t
</span><a href="#local-6989586621679567379"><span class="hs-identifier hs-var hs-var">varFromBind</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679567378"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679567378"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567377"><span class="annot"><span class="annottext">Expr t
</span><a href="#local-6989586621679567377"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarId -&gt; t -&gt; Expr t
forall t. VarId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Var"><span class="hs-identifier hs-var">I.Var</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder -&gt; VarId
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679567378"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr t -&gt; t
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">I.extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr t
</span><a href="#local-6989586621679567377"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span>  </span><span id="local-6989586621679567383"><span class="annot"><span class="annottext">droppedBinder :: (Binder, Expr Type) -&gt; StateT Int Pass (Binder, Expr Type)
</span><a href="#local-6989586621679567383"><span class="hs-identifier hs-var hs-var">droppedBinder</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567376"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567376"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-284"></span><span>    </span><span id="local-6989586621679567375"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567375"><span class="hs-identifier hs-var">temp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Fresh VarId
</span><a href="IR.InsertRefCounting.html#getFresh"><span class="hs-identifier hs-var">getFresh</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;_underscore&quot;</span></span><span>
</span><span id="line-285"></span><span>    </span><span id="local-6989586621679567374"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567374"><span class="hs-identifier hs-var">d'</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567376"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-286"></span><span>    </span><span class="annot"><span class="annottext">(Binder, Expr Type) -&gt; StateT Int Pass (Binder, Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567375"><span class="hs-identifier hs-var">temp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567374"><span class="hs-identifier hs-var">d'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>  </span><span class="annot"><a href="#local-6989586621679567383"><span class="hs-identifier hs-var">droppedBinder</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679567373"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679567373"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567372"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567372"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-288"></span><span>    </span><span id="local-6989586621679567371"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567371"><span class="hs-identifier hs-var">d'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567372"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-289"></span><span>    </span><span class="annot"><span class="annottext">(Binder, Expr Type) -&gt; StateT Int Pass (Binder, Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679567373"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567371"><span class="hs-identifier hs-var">d'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span id="local-6989586621679567370"><span class="annot"><span class="annottext">lam :: Expr Type
</span><a href="#local-6989586621679567370"><span class="hs-identifier hs-var">lam</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Lambda"><span class="hs-identifier hs-type">I.Lambda</span></a></span><span> </span><span class="annot"><span class="annottext">Binder
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679567368"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567368"><span class="hs-identifier hs-var">typ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-292"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679567367"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679567367"><span class="hs-identifier hs-var">args</span></a></span></span><span>    </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567366"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567366"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; ([Binder], Expr Type)
forall t. Expr t -&gt; ([Binder], Expr t)
</span><a href="IR.IR.html#unfoldLambda"><span class="hs-identifier hs-var">I.unfoldLambda</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567370"><span class="hs-identifier hs-var">lam</span></a></span><span>
</span><span id="line-293"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679567364"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679567364"><span class="hs-identifier hs-var">argTypes</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([Type], Type)
</span><a href="IR.Types.Type.html#unfoldArrow"><span class="hs-identifier hs-var">I.unfoldArrow</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567368"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-294"></span><span>  </span><span id="local-6989586621679567362"><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679567362"><span class="hs-identifier hs-var">args'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Binder] -&gt; (Binder -&gt; Fresh VarId) -&gt; StateT Int Pass [VarId]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679567367"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">((Binder -&gt; Fresh VarId) -&gt; StateT Int Pass [VarId])
-&gt; (Binder -&gt; Fresh VarId) -&gt; StateT Int Pass [VarId]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Fresh VarId -&gt; (VarId -&gt; Fresh VarId) -&gt; Binder -&gt; Fresh VarId
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Fresh VarId
</span><a href="IR.InsertRefCounting.html#getFresh"><span class="hs-identifier hs-var">getFresh</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;_arg&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Fresh VarId
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-comment">-- handle _ arguments</span><span>
</span><span id="line-295"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679567360"><span class="annot"><span class="annottext">typedArgs :: [(Binder, Type)]
</span><a href="#local-6989586621679567360"><span class="hs-identifier hs-var hs-var">typedArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VarId -&gt; Type -&gt; (Binder, Type))
-&gt; [VarId] -&gt; [Type] -&gt; [(Binder, Type)]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679567358"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567358"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679567357"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567357"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567358"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567357"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679567362"><span class="hs-identifier hs-var">args'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679567364"><span class="hs-identifier hs-var">argTypes</span></a></span><span>
</span><span id="line-296"></span><span>      </span><span id="local-6989586621679567356"><span class="annot"><span class="annottext">argVars :: [Expr Type]
</span><a href="#local-6989586621679567356"><span class="hs-identifier hs-var hs-var">argVars</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(VarId -&gt; Type -&gt; Expr Type) -&gt; [VarId] -&gt; [Type] -&gt; [Expr Type]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Type -&gt; Expr Type
forall t. VarId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Var"><span class="hs-identifier hs-var">I.Var</span></a></span><span> </span><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679567362"><span class="hs-identifier hs-var">args'</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679567364"><span class="hs-identifier hs-var">argTypes</span></a></span><span>
</span><span id="line-297"></span><span>  </span><span id="local-6989586621679567355"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567355"><span class="hs-identifier hs-var">body'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567366"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-298"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; StateT Int Pass (Expr Type))
-&gt; Expr Type -&gt; StateT Int Pass (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Type)] -&gt; Expr Type -&gt; Expr Type
</span><a href="IR.IR.html#foldLambda"><span class="hs-identifier hs-var">I.foldLambda</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Type)]
</span><a href="#local-6989586621679567360"><span class="hs-identifier hs-var">typedArgs</span></a></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; Expr Type) -&gt; Expr Type -&gt; Expr Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; Expr Type -&gt; Expr Type)
-&gt; Expr Type -&gt; [Expr Type] -&gt; Expr Type
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDrop"><span class="hs-identifier hs-var">makeDrop</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567355"><span class="hs-identifier hs-var">body'</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679567356"><span class="hs-identifier hs-var">argVars</span></a></span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Match"><span class="hs-identifier hs-type">I.Match</span></a></span><span> </span><span id="local-6989586621679567352"><span class="annot"><span class="annottext">v :: Expr Type
</span><a href="#local-6989586621679567352"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="IR.IR.html#Var"><span class="hs-identifier hs-type">I.Var</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621679567351"><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679567351"><span class="hs-identifier hs-var">alts</span></a></span></span><span> </span><span id="local-6989586621679567350"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567350"><span class="hs-identifier hs-var">typ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-301"></span><span>  </span><span id="local-6989586621679567349"><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679567349"><span class="hs-identifier hs-var">alts'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Type)]
-&gt; ((Alt, Expr Type) -&gt; StateT Int Pass (Alt, Expr Type))
-&gt; StateT Int Pass [(Alt, Expr Type)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679567351"><span class="hs-identifier hs-var">alts</span></a></span><span> </span><span class="annot"><span class="annottext">(Alt, Expr Type) -&gt; StateT Int Pass (Alt, Expr Type)
</span><a href="IR.InsertRefCounting.html#insertAlt"><span class="hs-identifier hs-var">insertAlt</span></a></span><span>
</span><span id="line-302"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; StateT Int Pass (Expr Type))
-&gt; Expr Type -&gt; StateT Int Pass (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; [(Alt, Expr Type)] -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; [(Alt, Expr t)] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Match"><span class="hs-identifier hs-var">I.Match</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567352"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679567349"><span class="hs-identifier hs-var">alts'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567350"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Match"><span class="hs-identifier hs-type">I.Match</span></a></span><span> </span><span id="local-6989586621679567347"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567347"><span class="hs-identifier hs-var">scrutExpr</span></a></span></span><span> </span><span id="local-6989586621679567346"><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679567346"><span class="hs-identifier hs-var">alts</span></a></span></span><span> </span><span id="local-6989586621679567345"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567345"><span class="hs-identifier hs-var">typ</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-305"></span><span>  </span><span id="local-6989586621679567344"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567344"><span class="hs-identifier hs-var">scrutVar</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Fresh VarId
</span><a href="IR.InsertRefCounting.html#getFresh"><span class="hs-identifier hs-var">getFresh</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;_scrutinee&quot;</span></span><span>
</span><span id="line-306"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; StateT Int Pass (Expr Type))
-&gt; Expr Type -&gt; StateT Int Pass (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)] -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. [(Binder, Expr t)] -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Let"><span class="hs-identifier hs-var">I.Let</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567344"><span class="hs-identifier hs-var">scrutVar</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567347"><span class="hs-identifier hs-var">scrutExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-307"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; [(Alt, Expr Type)] -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; [(Alt, Expr t)] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Match"><span class="hs-identifier hs-var">I.Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Type -&gt; Expr Type
forall t. VarId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Var"><span class="hs-identifier hs-var">I.Var</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567344"><span class="hs-identifier hs-var">scrutVar</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type) -&gt; Type -&gt; Expr Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">I.extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567347"><span class="hs-identifier hs-var">scrutExpr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679567346"><span class="hs-identifier hs-var">alts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567345"><span class="hs-identifier hs-var">typ</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>                     </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679567345"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-309"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span id="local-6989586621679567343"><span class="annot"><span class="annottext">e :: Expr Type
</span><a href="#local-6989586621679567343"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Exception"><span class="hs-identifier hs-type">I.Exception</span></a></span><span> </span><span class="annot"><span class="annottext">ExceptType
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567343"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span class="hs-comment">{- | Insert dups and drops into pattern match arms

The body of default and literal patterns is simply recursed upon.

Every named variable in a pattern is duped and dropped, e.g.,

@
match v
  Foo x = expr
@

becomes

@
match v
  Foo _anon1 = drop
                 (let x = dup _anon1
                  expr
               ) x
@
-}</span><span>
</span><span id="line-332"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertAlt"><span class="hs-identifier hs-type">insertAlt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Alt"><span class="hs-identifier hs-type">I.Alt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.InsertRefCounting.html#Fresh"><span class="hs-identifier hs-type">Fresh</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Alt"><span class="hs-identifier hs-type">I.Alt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">I.Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">I.Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-333"></span><span id="insertAlt"><span class="annot"><span class="annottext">insertAlt :: (Alt, Expr Type) -&gt; StateT Int Pass (Alt, Expr Type)
</span><a href="IR.InsertRefCounting.html#insertAlt"><span class="hs-identifier hs-var hs-var">insertAlt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltBinder"><span class="hs-identifier hs-type">I.AltBinder</span></a></span><span> </span><span id="local-6989586621679567340"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679567340"><span class="hs-identifier hs-var">v</span></a></span></span><span>      </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567339"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567339"><span class="hs-identifier hs-var">e</span></a></span></span><span>   </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder -&gt; Alt
</span><a href="IR.IR.html#AltBinder"><span class="hs-identifier hs-var">I.AltBinder</span></a></span><span> </span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679567340"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; (Alt, Expr Type))
-&gt; StateT Int Pass (Expr Type) -&gt; StateT Int Pass (Alt, Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567339"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-334"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertAlt"><span class="hs-identifier hs-var">insertAlt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltLit"><span class="hs-identifier hs-type">I.AltLit</span></a></span><span>     </span><span id="local-6989586621679567337"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679567337"><span class="hs-identifier hs-var">l</span></a></span></span><span>      </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567336"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567336"><span class="hs-identifier hs-var">e</span></a></span></span><span>   </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Literal -&gt; Alt
</span><a href="IR.IR.html#AltLit"><span class="hs-identifier hs-var">I.AltLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679567337"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Expr Type -&gt; (Alt, Expr Type))
-&gt; StateT Int Pass (Expr Type) -&gt; StateT Int Pass (Alt, Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567336"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-335"></span><span class="annot"><a href="IR.InsertRefCounting.html#insertAlt"><span class="hs-identifier hs-var">insertAlt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltData"><span class="hs-identifier hs-type">I.AltData</span></a></span><span> </span><span id="local-6989586621679567334"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679567334"><span class="hs-identifier hs-var">dcon</span></a></span></span><span> </span><span id="local-6989586621679567333"><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679567333"><span class="hs-identifier hs-var">binds</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679567332"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567332"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-336"></span><span>  </span><span id="local-6989586621679567331"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567331"><span class="hs-identifier hs-var">body'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; StateT Int Pass (Expr Type)
</span><a href="IR.InsertRefCounting.html#insertExpr"><span class="hs-identifier hs-var">insertExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567332"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-337"></span><span>  </span><span class="annot"><span class="annottext">(Alt, Expr Type) -&gt; StateT Int Pass (Alt, Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DConId -&gt; [Alt] -&gt; Alt
</span><a href="IR.IR.html#AltData"><span class="hs-identifier hs-var">I.AltData</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679567334"><span class="hs-identifier hs-var">dcon</span></a></span><span> </span><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679567333"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">(Alt -&gt; Expr Type -&gt; Expr Type) -&gt; Expr Type -&gt; [Alt] -&gt; Expr Type
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder -&gt; Expr Type -&gt; Expr Type
</span><a href="#local-6989586621679567330"><span class="hs-identifier hs-var">dropDupLet</span></a></span><span> </span><span class="annot"><span class="annottext">(Binder -&gt; Expr Type -&gt; Expr Type)
-&gt; (Alt -&gt; Binder) -&gt; Alt -&gt; Expr Type -&gt; Expr Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Alt -&gt; Binder
</span><a href="IR.IR.html#getAltDefault"><span class="hs-identifier hs-var">I.getAltDefault</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567331"><span class="hs-identifier hs-var">body'</span></a></span><span> </span><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679567333"><span class="hs-identifier hs-var">binds</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-339"></span><span>  </span><span id="local-6989586621679567330"><span class="annot"><span class="annottext">dropDupLet :: Binder -&gt; Expr Type -&gt; Expr Type
</span><a href="#local-6989586621679567330"><span class="hs-identifier hs-var hs-var">dropDupLet</span></a></span></span><span> </span><span class="annot"><span class="annottext">Binder
</span><span class="hs-identifier hs-var">Nothing</span></span><span>  </span><span id="local-6989586621679567328"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567328"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567328"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-340"></span><span>  </span><span class="annot"><a href="#local-6989586621679567330"><span class="hs-identifier hs-var">dropDupLet</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679567327"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567327"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679567326"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567326"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDrop"><span class="hs-identifier hs-var">makeDrop</span></a></span><span>
</span><span id="line-341"></span><span>    </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567325"><span class="hs-identifier hs-var">varExpr</span></a></span><span>
</span><span id="line-342"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Binder, Expr Type)] -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. [(Binder, Expr t)] -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Let"><span class="hs-identifier hs-var">I.Let</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type
</span><a href="IR.InsertRefCounting.html#makeDup"><span class="hs-identifier hs-var">makeDup</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567325"><span class="hs-identifier hs-var">varExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567326"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">I.extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679567326"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-343"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679567325"><span class="annot"><span class="annottext">varExpr :: Expr Type
</span><a href="#local-6989586621679567325"><span class="hs-identifier hs-var hs-var">varExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Type -&gt; Expr Type
forall t. VarId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Var"><span class="hs-identifier hs-var">I.Var</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679567327"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Type.html#Unit"><span class="hs-identifier hs-var">I.Unit</span></a></span><span> </span><span class="hs-comment">-- FIXME: This should not be I.Unit; it should be the type of the argument of the data constructor</span><span>
</span><span id="line-344"></span></pre></body></html>