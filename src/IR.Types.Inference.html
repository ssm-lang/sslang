<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE OverloadedStrings #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE PartialTypeSignatures #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-partial-type-signatures #-}</span><span>
</span><span id="line-6"></span><span>
</span><span id="line-7"></span><span class="hs-comment">-- | Hindley-Milner-Damas type inference with union-find.</span><span>
</span><span id="line-8"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">IR.Types.Inference</span><span>
</span><span id="line-9"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#inferProgram"><span class="hs-identifier">inferProgram</span></a></span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="IR.IR.html"><span class="hs-identifier">IR.IR</span></a></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="IR.SegmentLets.html"><span class="hs-identifier">IR.SegmentLets</span></a></span><span>                 </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="IR.SegmentLets.html#segmentDefs"><span class="hs-identifier">segmentDefs</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="IR.Types.Type.html"><span class="hs-identifier">IR.Types.Type</span></a></span><span>                 </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="IR.Types.Unification.html"><span class="hs-identifier">IR.Types.Unification</span></a></span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">U</span></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="IR.Types.Unification.html"><span class="hs-identifier">IR.Types.Unification</span></a></span><span>           </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#%3C%3A%3D"><span class="hs-operator">(&lt;:=)</span></a></span><span>
</span><span id="line-17"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator">(=:=)</span></a></span><span>
</span><span id="line-18"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Common.Compiler.html"><span class="hs-identifier">Common.Compiler</span></a></span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Compiler</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Common.Identifiers.html"><span class="hs-identifier">Common.Identifiers</span></a></span><span>             </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Common.Identifiers.html#HasFreeVars"><span class="hs-identifier">HasFreeVars</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifiable"><span class="hs-identifier">Identifiable</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifier"><span class="hs-identifier">Identifier</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-24"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">IsString</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-25"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#fromId"><span class="hs-identifier">fromId</span></a></span><span>
</span><span id="line-26"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#showId"><span class="hs-identifier">showId</span></a></span><span>
</span><span id="line-27"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>                  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-operator">(&lt;=&lt;)</span></span><span>
</span><span id="line-30"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">forM</span></span><span>
</span><span id="line-31"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">forM_</span></span><span>
</span><span id="line-32"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unless</span></span><span>
</span><span id="line-33"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">when</span></span><span>
</span><span id="line-34"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">zipWithM</span></span><span>
</span><span id="line-35"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">zipWithM_</span></span><span>
</span><span id="line-36"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span>                 </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Bifunctor</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>                      </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>                     </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">fromJust</span></span><span>
</span><span id="line-40"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span>
</span><span id="line-41"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span>                      </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">S</span></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-comment">-- | Helper notation for constructing arrow types.</span><span>
</span><span id="line-45"></span><span class="annot"><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-type">(-:&gt;)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-46"></span><span id="-%3A%3E"><span class="annot"><span class="annottext">-:&gt; :: Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var hs-var">(-:&gt;)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Unification.html#Arrow"><span class="hs-identifier hs-var">U.Arrow</span></a></span><span>
</span><span id="line-47"></span><span class="hs-keyword">infixr</span><span> </span><span class="hs-number">5</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-type">-:&gt;</span></a></span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span class="hs-comment">-- | State maintained during type inference.</span><span>
</span><span id="line-50"></span><span class="hs-keyword">data</span><span> </span><span id="InferCtx"><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-var">InferCtx</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InferCtx"><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-var">InferCtx</span></a></span></span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="varEnv"><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varEnv"><span class="hs-identifier hs-var hs-var">varEnv</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span>  </span><span class="hs-comment">-- ^ mapping from vars to schemes</span><span>
</span><span id="line-52"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="kindEnv"><span class="annot"><span class="annottext">InferCtx -&gt; Map TConId Kind
</span><a href="IR.Types.Inference.html#kindEnv"><span class="hs-identifier hs-var hs-var">kindEnv</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="Common.Identifiers.html#TConId"><span class="hs-identifier hs-type">TConId</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Kind"><span class="hs-identifier hs-type">T.Kind</span></a></span><span>        </span><span class="hs-comment">-- ^ mapping from tcons to kinds</span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#HasFreeUVars"><span class="hs-identifier hs-type">U.HasFreeUVars</span></a></span><span> </span><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-type">InferCtx</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-56"></span><span>  </span><span id="local-6989586621679538735"><span class="annot"><span class="annottext">freeUVars :: InferCtx -&gt; InferM ctx (Set IntVar)
</span><a href="IR.Types.Unification.html#freeUVars"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeUVars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Set IntVar] -&gt; Set IntVar)
-&gt; ReaderT
     ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
-&gt; InferM ctx (Set IntVar)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">[Set IntVar] -&gt; Set IntVar
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; f (Set a) -&gt; Set a
</span><span class="hs-identifier hs-var">S.unions</span></span><span> </span><span class="annot"><span class="annottext">(ReaderT ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
 -&gt; InferM ctx (Set IntVar))
-&gt; (InferCtx
    -&gt; ReaderT
         ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar])
-&gt; InferCtx
-&gt; InferM ctx (Set IntVar)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; InferM ctx (Set IntVar))
-&gt; [Scheme]
-&gt; ReaderT
     ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; InferM ctx (Set IntVar)
forall a ctx. HasFreeUVars a =&gt; a -&gt; InferM ctx (Set IntVar)
</span><a href="IR.Types.Unification.html#freeUVars"><span class="hs-identifier hs-var">U.freeUVars</span></a></span><span> </span><span class="annot"><span class="annottext">([Scheme]
 -&gt; ReaderT
      ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar])
-&gt; (InferCtx -&gt; [Scheme])
-&gt; InferCtx
-&gt; ReaderT
     ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Map Identifier Scheme -&gt; [Scheme]
forall k a. Map k a -&gt; [a]
</span><span class="hs-identifier hs-var">M.elems</span></span><span> </span><span class="annot"><span class="annottext">(Map Identifier Scheme -&gt; [Scheme])
-&gt; (InferCtx -&gt; Map Identifier Scheme) -&gt; InferCtx -&gt; [Scheme]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varEnv"><span class="hs-identifier hs-var hs-var">varEnv</span></a></span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-comment">-- | Inference monad, specialized to use 'InferCtx' as the state.</span><span>
</span><span id="line-59"></span><span class="hs-keyword">type</span><span> </span><span id="Infer"><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-var">Infer</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#InferM"><span class="hs-identifier hs-type">U.InferM</span></a></span><span> </span><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-type">InferCtx</span></a></span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="hs-comment">-- | Perform an 'Infer' monad, with the environmnt extended by some bindings.</span><span>
</span><span id="line-62"></span><span id="local-6989586621679538862"><span class="annot"><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-type">withBindings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679538862"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679538862"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-63"></span><span id="withBindings"><span class="annot"><span class="annottext">withBindings :: [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var hs-var">withBindings</span></a></span></span><span> </span><span id="local-6989586621679538728"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538728"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(InferCtx -&gt; InferCtx) -&gt; Infer a -&gt; Infer a
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">U.local</span></span><span>
</span><span id="line-64"></span><span>  </span><span class="annot"><span class="annottext">((InferCtx -&gt; InferCtx) -&gt; Infer a -&gt; Infer a)
-&gt; (InferCtx -&gt; InferCtx) -&gt; Infer a -&gt; Infer a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679538726"><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679538726"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679538726"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">varEnv :: Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varEnv"><span class="hs-identifier hs-var">varEnv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Identifier, Scheme)
 -&gt; Map Identifier Scheme -&gt; Map Identifier Scheme)
-&gt; Map Identifier Scheme
-&gt; [(Identifier, Scheme)]
-&gt; Map Identifier Scheme
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Identifier
 -&gt; Scheme -&gt; Map Identifier Scheme -&gt; Map Identifier Scheme)
-&gt; (Identifier, Scheme)
-&gt; Map Identifier Scheme
-&gt; Map Identifier Scheme
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">Identifier
-&gt; Scheme -&gt; Map Identifier Scheme -&gt; Map Identifier Scheme
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insert</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varEnv"><span class="hs-identifier hs-var hs-var">varEnv</span></a></span><span> </span><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679538726"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(Identifier, Scheme)]
</span><a href="#local-6989586621679538722"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-65"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-66"></span><span>  </span><span id="local-6989586621679538722"><span class="annot"><span class="annottext">vs :: [(Identifier, Scheme)]
</span><a href="#local-6989586621679538722"><span class="hs-identifier hs-var hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Binder, Scheme) -&gt; Maybe (Identifier, Scheme))
-&gt; [(Binder, Scheme)] -&gt; [(Identifier, Scheme)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">(Binder, Scheme) -&gt; Maybe (Identifier, Scheme)
forall a a b.
(Identifiable a, Identifiable a) =&gt;
(Maybe a, b) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679538721"><span class="hs-identifier hs-var">unBind</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538728"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-67"></span><span>  </span><span id="local-6989586621679538721"><span class="annot"><span class="annottext">unBind :: (Maybe a, b) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679538721"><span class="hs-identifier hs-var hs-var">unBind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679538720"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679538720"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538719"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679538719"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, b) -&gt; Maybe (a, b)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a
forall a b. (Identifiable a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#fromId"><span class="hs-identifier hs-var">fromId</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679538720"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679538719"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-68"></span><span>  </span><span class="annot"><a href="#local-6989586621679538721"><span class="hs-identifier hs-var">unBind</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe a, b)
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (a, b)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="hs-comment">-- | Look up the 'U.Scheme' a data identifier in the variable environment.</span><span>
</span><span id="line-71"></span><span id="local-6989586621679538792"><span class="annot"><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-type">lookupBinding</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifiable"><span class="hs-identifier hs-type">Identifiable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679538792"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679538792"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span></span><span>
</span><span id="line-72"></span><span id="lookupBinding"><span class="annot"><span class="annottext">lookupBinding :: i -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var hs-var">lookupBinding</span></a></span></span><span> </span><span id="local-6989586621679538717"><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679538717"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-73"></span><span>    </span><span class="hs-keyword">do</span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><span class="annottext">(InferCtx -&gt; Maybe Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Maybe Scheme)
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">U.asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Identifier -&gt; Map Identifier Scheme -&gt; Maybe Scheme
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">M.lookup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">i -&gt; Identifier
forall a b. (Identifiable a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#fromId"><span class="hs-identifier hs-var">fromId</span></a></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679538717"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Identifier Scheme -&gt; Maybe Scheme)
-&gt; (InferCtx -&gt; Map Identifier Scheme) -&gt; InferCtx -&gt; Maybe Scheme
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varEnv"><span class="hs-identifier hs-var hs-var">varEnv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ReaderT
  InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Maybe Scheme)
-&gt; (Maybe Scheme -&gt; Infer Scheme) -&gt; Infer Scheme
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Infer Scheme
-&gt; (Scheme -&gt; Infer Scheme) -&gt; Maybe Scheme -&gt; Infer Scheme
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Error -&gt; Infer Scheme
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">U.throwError</span></span><span> </span><span class="annot"><span class="annottext">Error
</span><a href="#local-6989586621679538712"><span class="hs-identifier hs-var">unbound</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span>
</span><span id="line-75"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-76"></span><span>  </span><span id="local-6989586621679538712"><span class="annot"><span class="annottext">unbound :: Error
</span><a href="#local-6989586621679538712"><span class="hs-identifier hs-var hs-var">unbound</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ErrorMsg -&gt; Error
</span><a href="Common.Compiler.html#TypeError"><span class="hs-identifier hs-var">Compiler.TypeError</span></a></span><span> </span><span class="annot"><span class="annottext">(ErrorMsg -&gt; Error) -&gt; ErrorMsg -&gt; Error
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ErrorMsg
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ErrorMsg) -&gt; String -&gt; ErrorMsg
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Unbound variable: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">i -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679538717"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-comment">-- | Look up the 'T.Kind' of a type constructor in the kind environment.</span><span>
</span><span id="line-79"></span><span class="annot"><a href="IR.Types.Inference.html#lookupKind"><span class="hs-identifier hs-type">lookupKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.Identifiers.html#TConId"><span class="hs-identifier hs-type">TConId</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Kind"><span class="hs-identifier hs-type">T.Kind</span></a></span><span>
</span><span id="line-80"></span><span id="lookupKind"><span class="annot"><span class="annottext">lookupKind :: TConId -&gt; Infer Kind
</span><a href="IR.Types.Inference.html#lookupKind"><span class="hs-identifier hs-var hs-var">lookupKind</span></a></span></span><span> </span><span id="local-6989586621679538708"><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538708"><span class="hs-identifier hs-var">tcon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-81"></span><span>  </span><span class="annot"><span class="annottext">(InferCtx -&gt; Maybe Kind)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Maybe Kind)
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; a) -&gt; m a
</span><span class="hs-identifier hs-var">U.asks</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TConId -&gt; Map TConId Kind -&gt; Maybe Kind
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">M.lookup</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538708"><span class="hs-identifier hs-var">tcon</span></a></span><span> </span><span class="annot"><span class="annottext">(Map TConId Kind -&gt; Maybe Kind)
-&gt; (InferCtx -&gt; Map TConId Kind) -&gt; InferCtx -&gt; Maybe Kind
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; Map TConId Kind
</span><a href="IR.Types.Inference.html#kindEnv"><span class="hs-identifier hs-var hs-var">kindEnv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ReaderT
  InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Maybe Kind)
-&gt; (Maybe Kind -&gt; Infer Kind) -&gt; Infer Kind
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Infer Kind -&gt; (Kind -&gt; Infer Kind) -&gt; Maybe Kind -&gt; Infer Kind
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Error -&gt; Infer Kind
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">U.throwError</span></span><span> </span><span class="annot"><span class="annottext">Error
</span><a href="#local-6989586621679538707"><span class="hs-identifier hs-var">missing</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Infer Kind
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span>
</span><span id="line-82"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-83"></span><span>  </span><span id="local-6989586621679538707"><span class="annot"><span class="annottext">missing :: Error
</span><a href="#local-6989586621679538707"><span class="hs-identifier hs-var hs-var">missing</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-84"></span><span>    </span><span class="annot"><span class="annottext">ErrorMsg -&gt; Error
</span><a href="Common.Compiler.html#TypeError"><span class="hs-identifier hs-var">Compiler.TypeError</span></a></span><span>
</span><span id="line-85"></span><span>      </span><span class="annot"><span class="annottext">(ErrorMsg -&gt; Error) -&gt; ErrorMsg -&gt; Error
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>  </span><span class="annot"><span class="annottext">String -&gt; ErrorMsg
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span>
</span><span id="line-86"></span><span>      </span><span class="annot"><span class="annottext">(String -&gt; ErrorMsg) -&gt; String -&gt; ErrorMsg
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>  </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Could not find type constructor: &quot;</span></span><span>
</span><span id="line-87"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538708"><span class="hs-identifier hs-var">tcon</span></a></span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-comment">-- | Infer the types of every node in an optionally annotated program.</span><span>
</span><span id="line-90"></span><span class="annot"><a href="IR.Types.Inference.html#inferProgram"><span class="hs-identifier hs-type">inferProgram</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Program"><span class="hs-identifier hs-type">Program</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Annotations"><span class="hs-identifier hs-type">Annotations</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.Compiler.html#Pass"><span class="hs-identifier hs-type">Compiler.Pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Program"><span class="hs-identifier hs-type">Program</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-91"></span><span id="inferProgram"><span class="annot"><span class="annottext">inferProgram :: Program Annotations -&gt; Pass (Program Type)
</span><a href="IR.Types.Inference.html#inferProgram"><span class="hs-identifier hs-var hs-var">inferProgram</span></a></span></span><span> </span><span id="local-6989586621679538706"><span class="annot"><span class="annottext">Program Annotations
</span><a href="#local-6989586621679538706"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; InferM InferCtx (Program Type) -&gt; Pass (Program Type)
forall ctx a. ctx -&gt; InferM ctx a -&gt; Pass a
</span><a href="IR.Types.Unification.html#runInfer"><span class="hs-identifier hs-var">U.runInfer</span></a></span><span> </span><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679538704"><span class="hs-identifier hs-var">initCtx</span></a></span><span> </span><span class="annot"><span class="annottext">(InferM InferCtx (Program Type) -&gt; Pass (Program Type))
-&gt; InferM InferCtx (Program Type) -&gt; Pass (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-92"></span><span>  </span><span id="local-6989586621679538703"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538703"><span class="hs-identifier hs-var">ebs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">((VarId, Type)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
-&gt; [(VarId, Type)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(VarId, Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
</span><a href="IR.Types.Inference.html#externBindings"><span class="hs-identifier hs-var">externBindings</span></a></span><span> </span><span class="annot"><span class="annottext">([(VarId, Type)]
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; [(VarId, Type)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program Annotations -&gt; [(VarId, Type)]
forall t. Program t -&gt; [(VarId, Type)]
</span><a href="IR.IR.html#externDecls"><span class="hs-identifier hs-var hs-var">externDecls</span></a></span><span> </span><span class="annot"><span class="annottext">Program Annotations
</span><a href="#local-6989586621679538706"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-93"></span><span>  </span><span id="local-6989586621679538700"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538700"><span class="hs-identifier hs-var">dbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[[(Binder, Scheme)]] -&gt; [(Binder, Scheme)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[(Binder, Scheme)]] -&gt; [(Binder, Scheme)])
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">((TConId, TypeDef)
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; [(TConId, TypeDef)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(TConId, TypeDef)
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#typedefBindings"><span class="hs-identifier hs-var">typedefBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Program Annotations -&gt; [(TConId, TypeDef)]
forall t. Program t -&gt; [(TConId, TypeDef)]
</span><a href="IR.IR.html#typeDefs"><span class="hs-identifier hs-var hs-var">typeDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program Annotations
</span><a href="#local-6989586621679538706"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-94"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; InferM InferCtx (Program Type) -&gt; InferM InferCtx (Program Type)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538703"><span class="hs-identifier hs-var">ebs</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)] -&gt; [(Binder, Scheme)] -&gt; [(Binder, Scheme)]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538700"><span class="hs-identifier hs-var">dbs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(InferM InferCtx (Program Type) -&gt; InferM InferCtx (Program Type))
-&gt; InferM InferCtx (Program Type) -&gt; InferM InferCtx (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679538695"><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679538695"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538694"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538694"><span class="hs-identifier hs-var">ds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(VarId, Expr Type)] -&gt; ([VarId], [Expr Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([(VarId, Expr Type)] -&gt; ([VarId], [Expr Type]))
-&gt; (([(Binder, Expr Type)], ()) -&gt; [(VarId, Expr Type)])
-&gt; ([(Binder, Expr Type)], ())
-&gt; ([VarId], [Expr Type])
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Binder, Expr Type) -&gt; (VarId, Expr Type))
-&gt; [(Binder, Expr Type)] -&gt; [(VarId, Expr Type)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Binder -&gt; VarId) -&gt; (Binder, Expr Type) -&gt; (VarId, Expr Type)
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">Binder -&gt; VarId
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([(Binder, Expr Type)] -&gt; [(VarId, Expr Type)])
-&gt; (([(Binder, Expr Type)], ()) -&gt; [(Binder, Expr Type)])
-&gt; ([(Binder, Expr Type)], ())
-&gt; [(VarId, Expr Type)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">([(Binder, Expr Type)], ()) -&gt; [(Binder, Expr Type)]
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">(([(Binder, Expr Type)], ()) -&gt; ([VarId], [Expr Type]))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     ([(Binder, Expr Type)], ())
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     ([VarId], [Expr Type])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Annotations)]
-&gt; Infer ()
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     ([(Binder, Expr Type)], ())
forall a.
[(Binder, Expr Annotations)]
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-var">withDefs</span></a></span><span>
</span><span id="line-96"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((VarId, Expr Annotations) -&gt; (Binder, Expr Annotations))
-&gt; [(VarId, Expr Annotations)] -&gt; [(Binder, Expr Annotations)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(VarId -&gt; Binder)
-&gt; (VarId, Expr Annotations) -&gt; (Binder, Expr Annotations)
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([(VarId, Expr Annotations)] -&gt; [(Binder, Expr Annotations)])
-&gt; [(VarId, Expr Annotations)] -&gt; [(Binder, Expr Annotations)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program Annotations -&gt; [(VarId, Expr Annotations)]
forall t. Program t -&gt; [(VarId, Expr t)]
</span><a href="IR.IR.html#programDefs"><span class="hs-identifier hs-var hs-var">programDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program Annotations
</span><a href="#local-6989586621679538706"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; Infer ()
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span>    </span><span id="local-6989586621679538689"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538689"><span class="hs-identifier hs-var">ds'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Expr Type
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; [Expr Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span>
</span><span id="line-99"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Expr Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">((Type
  -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
 -&gt; Expr Type
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; (Type
    -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Expr Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Type -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#freeze"><span class="hs-identifier hs-var">U.freeze</span></a></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; (Type
    -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) b c a.
Monad m =&gt;
(b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&lt;=&lt;</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Type -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#applyBindings"><span class="hs-identifier hs-var">U.applyBindings</span></a></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; (Scheme -&gt; Type)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Type
forall t. SchemeOf t -&gt; t
</span><a href="IR.Types.Type.html#unScheme"><span class="hs-identifier hs-var">T.unScheme</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; (Type -&gt; Infer Scheme)
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) b c a.
Monad m =&gt;
(b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&lt;=&lt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Infer Scheme
forall ctx. HasFreeUVars ctx =&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#generalize"><span class="hs-identifier hs-var">U.generalize</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-100"></span><span>      </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538694"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-101"></span><span>    </span><span class="annot"><span class="annottext">Program Type -&gt; InferM InferCtx (Program Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Program Type -&gt; InferM InferCtx (Program Type))
-&gt; Program Type -&gt; InferM InferCtx (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program Annotations
</span><a href="#local-6989586621679538706"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">programDefs :: [(VarId, Expr Type)]
</span><a href="IR.IR.html#programDefs"><span class="hs-identifier hs-var">programDefs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarId] -&gt; [Expr Type] -&gt; [(VarId, Expr Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679538695"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538689"><span class="hs-identifier hs-var">ds'</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-102"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-103"></span><span>  </span><span class="hs-comment">-- | Obtain the kind of each type constructor.</span><span>
</span><span id="line-104"></span><span>  </span><span id="local-6989586621679538684"><span class="annot"><span class="annottext">kenv :: Map TConId Kind
</span><a href="#local-6989586621679538684"><span class="hs-identifier hs-var hs-var">kenv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(TConId, Kind)] -&gt; Map TConId Kind
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromList</span></span><span> </span><span class="annot"><span class="annottext">([(TConId, Kind)] -&gt; Map TConId Kind)
-&gt; [(TConId, Kind)] -&gt; Map TConId Kind
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((TConId, TypeDef) -&gt; (TConId, Kind))
-&gt; [(TConId, TypeDef)] -&gt; [(TConId, Kind)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TypeDef -&gt; Kind) -&gt; (TConId, TypeDef) -&gt; (TConId, Kind)
forall (p :: * -&gt; * -&gt; *) b c a.
Bifunctor p =&gt;
(b -&gt; c) -&gt; p a b -&gt; p a c
</span><span class="hs-identifier hs-var">second</span></span><span> </span><span class="annot"><span class="annottext">((TypeDef -&gt; Kind) -&gt; (TConId, TypeDef) -&gt; (TConId, Kind))
-&gt; (TypeDef -&gt; Kind) -&gt; (TConId, TypeDef) -&gt; (TConId, Kind)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">([TVarId] -&gt; Kind) -&gt; (TypeDef -&gt; [TVarId]) -&gt; TypeDef -&gt; Kind
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">TypeDef -&gt; [TVarId]
</span><a href="IR.IR.html#targs"><span class="hs-identifier hs-var hs-var">targs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([(TConId, TypeDef)] -&gt; [(TConId, Kind)])
-&gt; [(TConId, TypeDef)] -&gt; [(TConId, Kind)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program Annotations -&gt; [(TConId, TypeDef)]
forall t. Program t -&gt; [(TConId, TypeDef)]
</span><a href="IR.IR.html#typeDefs"><span class="hs-identifier hs-var hs-var">typeDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program Annotations
</span><a href="#local-6989586621679538706"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-comment">-- | Construct the inintial inference context.</span><span>
</span><span id="line-107"></span><span>  </span><span id="local-6989586621679538704"><span class="annot"><span class="annottext">initCtx :: InferCtx
</span><a href="#local-6989586621679538704"><span class="hs-identifier hs-var hs-var">initCtx</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-108"></span><span>    </span><span class="annot"><span class="annottext">InferCtx :: Map Identifier Scheme -&gt; Map TConId Kind -&gt; InferCtx
</span><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-type">InferCtx</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">varEnv :: Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varEnv"><span class="hs-identifier hs-var">varEnv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Identifier Scheme
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">kindEnv :: Map TConId Kind
</span><a href="IR.Types.Inference.html#kindEnv"><span class="hs-identifier hs-var">kindEnv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map TConId Kind
</span><a href="IR.Types.Type.html#builtinKinds"><span class="hs-identifier hs-var">T.builtinKinds</span></a></span><span> </span><span class="annot"><span class="annottext">Map TConId Kind -&gt; Map TConId Kind -&gt; Map TConId Kind
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-operator hs-var">`M.union`</span></span><span> </span><span class="annot"><span class="annottext">Map TConId Kind
</span><a href="#local-6989586621679538684"><span class="hs-identifier hs-var">kenv</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="hs-comment">-- | Create bindings for the extern symbols.</span><span>
</span><span id="line-111"></span><span class="annot"><a href="IR.Types.Inference.html#externBindings"><span class="hs-identifier hs-type">externBindings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#VarId"><span class="hs-identifier hs-type">VarId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-112"></span><span id="externBindings"><span class="annot"><span class="annottext">externBindings :: (VarId, Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
</span><a href="IR.Types.Inference.html#externBindings"><span class="hs-identifier hs-var hs-var">externBindings</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679538676"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538676"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538675"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538675"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-113"></span><span>  </span><span id="local-6989586621679538674"><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679538674"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Infer Scheme
forall ctx. HasFreeUVars ctx =&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#generalize"><span class="hs-identifier hs-var">U.generalize</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Infer Scheme) -&gt; Type -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#unfreeze"><span class="hs-identifier hs-var">U.unfreeze</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538675"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="annot"><span class="annottext">(Binder, Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538676"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679538674"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span class="hs-comment">-- | Create bindings for the data constructors of each type definition.</span><span>
</span><span id="line-117"></span><span class="annot"><a href="IR.Types.Inference.html#typedefBindings"><span class="hs-identifier hs-type">typedefBindings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#TConId"><span class="hs-identifier hs-type">TConId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#TypeDef"><span class="hs-identifier hs-type">TypeDef</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-118"></span><span id="typedefBindings"><span class="annot"><span class="annottext">typedefBindings :: (TConId, TypeDef)
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#typedefBindings"><span class="hs-identifier hs-var hs-var">typedefBindings</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679538672"><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538672"><span class="hs-identifier hs-var">tc</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#TypeDef"><span class="hs-identifier hs-type">TypeDef</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">variants :: TypeDef -&gt; [(DConId, TypeVariant)]
</span><a href="IR.IR.html#variants"><span class="hs-identifier hs-var">variants</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679538669"><span class="annot"><span class="annottext">[(DConId, TypeVariant)]
</span><a href="#local-6989586621679538669"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">targs :: TypeDef -&gt; [TVarId]
</span><a href="IR.IR.html#targs"><span class="hs-identifier hs-var">targs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679538668"><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538668"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-119"></span><span>  </span><span class="annot"><span class="annottext">[(DConId, TypeVariant)]
-&gt; ((DConId, TypeVariant)
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[(DConId, TypeVariant)]
</span><a href="#local-6989586621679538669"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="annot"><span class="annottext">(((DConId, TypeVariant)
  -&gt; ReaderT
       InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; ((DConId, TypeVariant)
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679538667"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538667"><span class="hs-identifier hs-var">dc</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538666"><span class="annot"><span class="annottext">TypeVariant
</span><a href="#local-6989586621679538666"><span class="hs-identifier hs-var">tv</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-120"></span><span>    </span><span id="local-6989586621679538665"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538665"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#unfreeze"><span class="hs-identifier hs-var">U.unfreeze</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; [Type])
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">TypeVariant
</span><a href="#local-6989586621679538666"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-121"></span><span>      </span><span class="annot"><a href="IR.IR.html#VariantUnnamed"><span class="hs-identifier hs-type">VariantUnnamed</span></a></span><span> </span><span id="local-6989586621679538663"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538663"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Type]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538663"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-122"></span><span>      </span><span class="annot"><a href="IR.IR.html#VariantNamed"><span class="hs-identifier hs-type">VariantNamed</span></a></span><span>   </span><span class="annot"><span class="annottext">[(VarId, Type)]
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#todo"><span class="hs-identifier hs-var">Compiler.todo</span></a></span><span>
</span><span id="line-123"></span><span>        </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;typedefBindings cannot yet handle variants with named fields&quot;</span></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679538660"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679538660"><span class="hs-identifier hs-var hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TConId -&gt; [Type] -&gt; Type
</span><a href="IR.Types.Unification.html#TCon"><span class="hs-identifier hs-var">U.TCon</span></a></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538672"><span class="hs-identifier hs-var">tc</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; Type) -&gt; [Type] -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; Type) -&gt; [TVarId] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538668"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-126"></span><span>        </span><span id="local-6989586621679538657"><span class="annot"><span class="annottext">s :: Scheme
</span><a href="#local-6989586621679538657"><span class="hs-identifier hs-var hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538668"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538665"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538660"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span>    </span><span id="local-6989586621679538654"><span class="annot"><span class="annottext">Set IntVar
</span><a href="#local-6989586621679538654"><span class="hs-identifier hs-var">ftvs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; InferM InferCtx (Set IntVar)
forall a ctx. HasFreeUVars a =&gt; a -&gt; InferM ctx (Set IntVar)
</span><a href="IR.Types.Unification.html#freeUVars"><span class="hs-identifier hs-var">U.freeUVars</span></a></span><span> </span><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679538657"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-129"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Infer () -&gt; Infer ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Set IntVar
forall a. Set a
</span><span class="hs-identifier hs-var">S.empty</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar -&gt; Set IntVar -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar
</span><a href="#local-6989586621679538654"><span class="hs-identifier hs-var">ftvs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Infer () -&gt; Infer ()) -&gt; Infer () -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-130"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; Infer ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Infer ()) -&gt; String -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-131"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type definition contains unbound type variables:&quot;</span></span><span>
</span><span id="line-132"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;        &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unwords</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(IntVar -&gt; String) -&gt; [IntVar] -&gt; [String]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">IntVar -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">([IntVar] -&gt; [String]) -&gt; [IntVar] -&gt; [String]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar -&gt; [IntVar]
forall a. Set a -&gt; [a]
</span><span class="hs-identifier hs-var">S.toList</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar
</span><a href="#local-6989586621679538654"><span class="hs-identifier hs-var">ftvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;for type : &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538672"><span class="hs-identifier hs-var">tc</span></a></span><span>
</span><span id="line-134"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;from data constructor: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538667"><span class="hs-identifier hs-var">dc</span></a></span><span>
</span><span id="line-135"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span>    </span><span class="annot"><span class="annottext">(Binder, Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(VarId -&gt; Binder) -&gt; VarId -&gt; Binder
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; VarId
forall a b. (Identifiable a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#fromId"><span class="hs-identifier hs-var">fromId</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538667"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679538657"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-comment">-- | Perform inference, with the environment extended by a list of bindings.</span><span>
</span><span id="line-140"></span><span id="local-6989586621679538846"><span class="annot"><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-type">withDefs</span></a></span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Annotations"><span class="hs-identifier hs-type">Annotations</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679538846"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679538846"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-144"></span><span id="withDefs"><span class="annot"><span class="annottext">withDefs :: [(Binder, Expr Annotations)]
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-var hs-var">withDefs</span></a></span></span><span> </span><span id="local-6989586621679538648"><span class="annot"><span class="annottext">[(Binder, Expr Annotations)]
</span><a href="#local-6989586621679538648"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span id="local-6989586621679538647"><span class="annot"><span class="annottext">Infer a
</span><a href="#local-6989586621679538647"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Binder, Expr Annotations)]] -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="#local-6989586621679538646"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">([[(Binder, Expr Annotations)]]
 -&gt; Infer ([(Binder, Expr Type)], a))
-&gt; [[(Binder, Expr Annotations)]]
-&gt; Infer ([(Binder, Expr Type)], a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Annotations)] -&gt; [[(Binder, Expr Annotations)]]
forall t. Show t =&gt; [Def t] -&gt; [[Def t]]
</span><a href="IR.SegmentLets.html#segmentDefs"><span class="hs-identifier hs-var">segmentDefs</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Annotations)]
</span><a href="#local-6989586621679538648"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-145"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-146"></span><span>  </span><span class="annot"><a href="#local-6989586621679538646"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Annotations"><span class="hs-identifier hs-type">Annotations</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-147"></span><span>  </span><span id="local-6989586621679538646"><span class="annot"><span class="annottext">go :: [[(Binder, Expr Annotations)]] -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="#local-6989586621679538646"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Binder, Expr Annotations)] -&gt; ([Binder], [Expr Annotations])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679538645"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679538645"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538644"><span class="annot"><span class="annottext">[Expr Annotations]
</span><a href="#local-6989586621679538644"><span class="hs-identifier hs-var">es</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679538643"><span class="annot"><span class="annottext">[[(Binder, Expr Annotations)]]
</span><a href="#local-6989586621679538643"><span class="hs-identifier hs-var">dss</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-148"></span><span>    </span><span class="hs-comment">-- Create fresh unification variable for each binder</span><span>
</span><span id="line-149"></span><span>    </span><span id="local-6989586621679538642"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538642"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Binder
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; [Binder]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; Binder
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679538645"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span>    </span><span class="hs-comment">-- Create empty scheme for each binder's unification variable</span><span>
</span><span id="line-152"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679538639"><span class="annot"><span class="annottext">ss :: [Scheme]
</span><a href="#local-6989586621679538639"><span class="hs-identifier hs-var hs-var">ss</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; [Type] -&gt; [Scheme]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538642"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-comment">-- Infer definitions with those schemes in scope</span><span>
</span><span id="line-155"></span><span>    </span><span id="local-6989586621679538638"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538638"><span class="hs-identifier hs-var">es'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)] -&gt; Infer [Expr Type] -&gt; Infer [Expr Type]
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; [Scheme] -&gt; [(Binder, Scheme)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679538645"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Scheme]
</span><a href="#local-6989586621679538639"><span class="hs-identifier hs-var">ss</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Infer [Expr Type] -&gt; Infer [Expr Type])
-&gt; Infer [Expr Type] -&gt; Infer [Expr Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Expr Annotations
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; [Expr Annotations] -&gt; Infer [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Annotations]
</span><a href="#local-6989586621679538644"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-comment">-- Unify unification variables with the inferred type of each definition</span><span>
</span><span id="line-158"></span><span>    </span><span class="annot"><span class="annottext">[(Type, Expr Type)] -&gt; ((Type, Expr Type) -&gt; Infer ()) -&gt; Infer ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m ()
</span><span class="hs-identifier hs-var">forM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Expr Type] -&gt; [(Type, Expr Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538642"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538638"><span class="hs-identifier hs-var">es'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Type, Expr Type) -&gt; Infer ()) -&gt; Infer ())
-&gt; ((Type, Expr Type) -&gt; Infer ()) -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679538636"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538636"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span id="local-6989586621679538634"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538634"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538636"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538634"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span>    </span><span id="local-6989586621679538633"><span class="annot"><span class="annottext">[Scheme]
</span><a href="#local-6989586621679538633"><span class="hs-identifier hs-var">ss'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Expr Type]
-&gt; (Expr Type -&gt; Infer Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Scheme]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538638"><span class="hs-identifier hs-var">es'</span></a></span><span> </span><span class="annot"><span class="annottext">((Expr Type -&gt; Infer Scheme)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Scheme])
-&gt; (Expr Type -&gt; Infer Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Scheme]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679538632"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538632"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Bool
forall t. Expr t -&gt; Bool
</span><a href="IR.IR.html#isValue"><span class="hs-identifier hs-var">isValue</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538632"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-161"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Infer Scheme
forall ctx. HasFreeUVars ctx =&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#generalize"><span class="hs-identifier hs-var">U.generalize</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Infer Scheme) -&gt; Type -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538632"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-162"></span><span>      </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538632"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-163"></span><span>
</span><span id="line-164"></span><span>    </span><span class="annot"><span class="annottext">([(Binder, Expr Type)] -&gt; [(Binder, Expr Type)])
-&gt; ([(Binder, Expr Type)], a) -&gt; ([(Binder, Expr Type)], a)
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; [Expr Type] -&gt; [(Binder, Expr Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679538645"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538638"><span class="hs-identifier hs-var">es'</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
-&gt; [(Binder, Expr Type)] -&gt; [(Binder, Expr Type)]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(([(Binder, Expr Type)], a) -&gt; ([(Binder, Expr Type)], a))
-&gt; Infer ([(Binder, Expr Type)], a)
-&gt; Infer ([(Binder, Expr Type)], a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; Infer ([(Binder, Expr Type)], a)
-&gt; Infer ([(Binder, Expr Type)], a)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; [Scheme] -&gt; [(Binder, Scheme)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679538645"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Scheme]
</span><a href="#local-6989586621679538633"><span class="hs-identifier hs-var">ss'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[[(Binder, Expr Annotations)]] -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="#local-6989586621679538646"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[[(Binder, Expr Annotations)]]
</span><a href="#local-6989586621679538643"><span class="hs-identifier hs-var">dss</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span><span>  </span><span class="annot"><a href="#local-6989586621679538646"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[[(Binder, Expr Annotations)]]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(a -&gt; ([(Binder, Expr Type)], a))
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Infer a
</span><a href="#local-6989586621679538647"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-comment">-- | Type inference rules for type-annotated expressions.</span><span>
</span><span id="line-168"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-type">inferExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Annotations"><span class="hs-identifier hs-type">Annotations</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-169"></span><span id="inferExpr"><span class="annot"><span class="annottext">inferExpr :: Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var hs-var">inferExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Var"><span class="hs-identifier hs-type">Var</span></a></span><span> </span><span id="local-6989586621679538629"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538629"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621679538628"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538628"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-170"></span><span>  </span><span id="local-6989586621679538627"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538627"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Infer Scheme
forall i. Identifiable i =&gt; i -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538629"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-171"></span><span>  </span><span class="annot"><span class="annottext">VarId -&gt; Type -&gt; Expr Type
forall t. VarId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Var"><span class="hs-identifier hs-var">Var</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538629"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538628"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538627"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-172"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Data"><span class="hs-identifier hs-type">Data</span></a></span><span> </span><span id="local-6989586621679538622"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538622"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621679538621"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538621"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-173"></span><span>  </span><span id="local-6989586621679538620"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538620"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; Infer Scheme
forall i. Identifiable i =&gt; i -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538622"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-174"></span><span>  </span><span class="annot"><span class="annottext">DConId -&gt; Type -&gt; Expr Type
forall t. DConId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Data"><span class="hs-identifier hs-var">Data</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538622"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538621"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538620"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-175"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621679538618"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679538618"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679538617"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538617"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-176"></span><span>  </span><span id="local-6989586621679538616"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538616"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#inferLit"><span class="hs-identifier hs-var">inferLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679538618"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-177"></span><span>  </span><span class="annot"><span class="annottext">Literal -&gt; Type -&gt; Expr Type
forall t. Literal -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Lit"><span class="hs-identifier hs-var">Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679538618"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538617"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538616"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-178"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679538613"><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538613"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679538612"><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538612"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679538611"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538611"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-179"></span><span>  </span><span id="local-6989586621679538610"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538610"><span class="hs-identifier hs-var">f'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538613"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-180"></span><span>  </span><span id="local-6989586621679538609"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538609"><span class="hs-identifier hs-var">a'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538612"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-181"></span><span>  </span><span id="local-6989586621679538608"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538608"><span class="hs-identifier hs-var">rt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-182"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538610"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538609"><span class="hs-identifier hs-var">a'</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538608"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-183"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538610"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538609"><span class="hs-identifier hs-var">a'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538611"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538608"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-184"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Let"><span class="hs-identifier hs-type">Let</span></a></span><span> </span><span id="local-6989586621679538606"><span class="annot"><span class="annottext">[(Binder, Expr Annotations)]
</span><a href="#local-6989586621679538606"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span id="local-6989586621679538605"><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538605"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679538604"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538604"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-185"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679538603"><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679538603"><span class="hs-identifier hs-var">ds'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538602"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538602"><span class="hs-identifier hs-var">e'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Annotations)]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; Infer ([(Binder, Expr Type)], Expr Type)
forall a.
[(Binder, Expr Annotations)]
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-var">withDefs</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Annotations)]
</span><a href="#local-6989586621679538606"><span class="hs-identifier hs-var">ds</span></a></span><span> </span><span class="annot"><span class="annottext">(ReaderT
   InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
 -&gt; Infer ([(Binder, Expr Type)], Expr Type))
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; Infer ([(Binder, Expr Type)], Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538605"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-186"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Expr Type)] -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. [(Binder, Expr t)] -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Let"><span class="hs-identifier hs-var">Let</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679538603"><span class="hs-identifier hs-var">ds'</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538602"><span class="hs-identifier hs-var">e'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538604"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538602"><span class="hs-identifier hs-var">e'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-187"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Lambda"><span class="hs-identifier hs-type">Lambda</span></a></span><span> </span><span id="local-6989586621679538600"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679538600"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679538599"><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538599"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679538598"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538598"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-188"></span><span>  </span><span id="local-6989586621679538597"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538597"><span class="hs-identifier hs-var">at</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-189"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679538600"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538597"><span class="hs-identifier hs-var">at</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(ReaderT
   InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-190"></span><span>    </span><span id="local-6989586621679538596"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538596"><span class="hs-identifier hs-var">b'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538599"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-191"></span><span>    </span><span class="annot"><span class="annottext">Binder -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. Binder -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Lambda"><span class="hs-identifier hs-var">Lambda</span></a></span><span> </span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679538600"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538596"><span class="hs-identifier hs-var">b'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538598"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538597"><span class="hs-identifier hs-var">at</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538596"><span class="hs-identifier hs-var">b'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span id="local-6989586621679538594"><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538594"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679538593"><span class="annot"><span class="annottext">[(Alt, Expr Annotations)]
</span><a href="#local-6989586621679538593"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span id="local-6989586621679538592"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538592"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-193"></span><span>  </span><span id="local-6989586621679538591"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538591"><span class="hs-identifier hs-var">s'</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538594"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-194"></span><span>  </span><span id="local-6989586621679538590"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538590"><span class="hs-identifier hs-var">rt</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-195"></span><span>  </span><span id="local-6989586621679538589"><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679538589"><span class="hs-identifier hs-var">as'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Annotations)]
-&gt; ((Alt, Expr Annotations)
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Alt, Expr Type)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Annotations)]
</span><a href="#local-6989586621679538593"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">(((Alt, Expr Annotations)
  -&gt; ReaderT
       InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Alt, Expr Type)])
-&gt; ((Alt, Expr Annotations)
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Alt, Expr Type)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679538588"><span class="annot"><span class="annottext">Alt
</span><a href="#local-6989586621679538588"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538587"><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538587"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-196"></span><span>    </span><span id="local-6989586621679538586"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538586"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Alt
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538591"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Alt
</span><a href="#local-6989586621679538588"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-197"></span><span>    </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679538586"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">(ReaderT
   InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-198"></span><span>      </span><span id="local-6989586621679538584"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538584"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
</span><a href="#local-6989586621679538587"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-199"></span><span>      </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538590"><span class="hs-identifier hs-var">rt</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538584"><span class="hs-identifier hs-var">c'</span></a></span><span>
</span><span id="line-200"></span><span>      </span><span class="annot"><span class="annottext">(Alt, Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Alt
</span><a href="#local-6989586621679538588"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538584"><span class="hs-identifier hs-var">c'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; [(Alt, Expr Type)] -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; [(Alt, Expr t)] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Match"><span class="hs-identifier hs-var">Match</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679538591"><span class="hs-identifier hs-var">s'</span></a></span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679538589"><span class="hs-identifier hs-var">as'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538592"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538590"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-202"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Prim"><span class="hs-identifier hs-type">Prim</span></a></span><span> </span><span id="local-6989586621679538582"><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679538582"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679538581"><span class="annot"><span class="annottext">[Expr Annotations]
</span><a href="#local-6989586621679538581"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span id="local-6989586621679538580"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538580"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-203"></span><span>  </span><span id="local-6989586621679538579"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538579"><span class="hs-identifier hs-var">es'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Expr Annotations
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; [Expr Annotations] -&gt; Infer [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Expr Annotations
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Annotations]
</span><a href="#local-6989586621679538581"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-204"></span><span>  </span><span id="local-6989586621679538578"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538578"><span class="hs-identifier hs-var">rt</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-205"></span><span>  </span><span id="local-6989586621679538577"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538577"><span class="hs-identifier hs-var">t</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Primitive -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Expr Annotations] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Expr Annotations]
</span><a href="#local-6989586621679538581"><span class="hs-identifier hs-var">es</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679538582"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-206"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538577"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Expr Type -&gt; Type) -&gt; [Expr Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538579"><span class="hs-identifier hs-var">es'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538578"><span class="hs-identifier hs-var">rt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-207"></span><span>  </span><span class="annot"><span class="annottext">Primitive -&gt; [Expr Type] -&gt; Type -&gt; Expr Type
forall t. Primitive -&gt; [Expr t] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Prim"><span class="hs-identifier hs-var">Prim</span></a></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679538582"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679538579"><span class="hs-identifier hs-var">es'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538580"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538578"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-208"></span><span>
</span><span id="line-209"></span><span class="hs-comment">-- | Obtain bindings for a pattern match arm, according to the scrutinee's type.</span><span>
</span><span id="line-210"></span><span class="annot"><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-type">inferAlt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-211"></span><span id="inferAlt"><span class="annot"><span class="annottext">inferAlt :: Type
-&gt; Alt
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var hs-var">inferAlt</span></a></span></span><span> </span><span id="local-6989586621679538575"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538575"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltData"><span class="hs-identifier hs-type">AltData</span></a></span><span> </span><span id="local-6989586621679538573"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538573"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679538572"><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679538572"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679538571"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538571"><span class="hs-identifier hs-var">ats</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538570"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538570"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([Type], Type)
</span><a href="IR.Types.Unification.html#unfoldArrow"><span class="hs-identifier hs-var">U.unfoldArrow</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; ([Type], Type))
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ([Type], Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; Infer Scheme
forall i. Identifiable i =&gt; i -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538573"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-213"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538575"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538570"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-214"></span><span>  </span><span class="annot"><span class="annottext">Bool -&gt; Infer () -&gt; Infer ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538571"><span class="hs-identifier hs-var">ats</span></a></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Kind -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">[Alt] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679538572"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Infer () -&gt; Infer ()) -&gt; Infer () -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-215"></span><span>    </span><span class="annot"><span class="annottext">String -&gt; Infer ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Infer ()) -&gt; String -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-216"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Wrong number of arguments for data constructor: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538573"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-217"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Expected: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538571"><span class="hs-identifier hs-var">ats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-218"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Got: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Alt] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679538572"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-219"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-220"></span><span>  </span><span class="annot"><span class="annottext">[[(Binder, Scheme)]] -&gt; [(Binder, Scheme)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[(Binder, Scheme)]] -&gt; [(Binder, Scheme)])
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; Alt
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; [Type]
-&gt; [Alt]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</span><span class="hs-identifier hs-var">zipWithM</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Alt
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538571"><span class="hs-identifier hs-var">ats</span></a></span><span> </span><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679538572"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-221"></span><span class="annot"><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span id="local-6989586621679538567"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538567"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltLit"><span class="hs-identifier hs-type">AltLit</span></a></span><span> </span><span id="local-6989586621679538565"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679538565"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-222"></span><span>  </span><span id="local-6989586621679538564"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538564"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#inferLit"><span class="hs-identifier hs-var">inferLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679538565"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-223"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538567"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538564"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-224"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-225"></span><span class="annot"><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span id="local-6989586621679538563"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538563"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltBinder"><span class="hs-identifier hs-type">AltBinder</span></a></span><span> </span><span id="local-6989586621679538561"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679538561"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679538561"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538563"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span class="hs-comment">-- | Type inference rules for primitives of a given arity.</span><span>
</span><span id="line-228"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-type">inferPrim</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Primitive"><span class="hs-identifier hs-type">Primitive</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span>
</span><span id="line-229"></span><span id="inferPrim"><span class="annot"><span class="annottext">inferPrim :: Kind -&gt; Primitive -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var hs-var">inferPrim</span></a></span></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#New"><span class="hs-identifier hs-var">New</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Dup"><span class="hs-identifier hs-var">Dup</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-231"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Drop"><span class="hs-identifier hs-var">Drop</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-232"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Deref"><span class="hs-identifier hs-var">Deref</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-233"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Assign"><span class="hs-identifier hs-var">Assign</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-234"></span><span>  </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-235"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#After"><span class="hs-identifier hs-var">After</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-comment">-- return $ T.forall [&quot;a&quot;] $ U.Time -:&gt; U.Ref (U.TVar &quot;a&quot;) -:&gt; U.TVar &quot;a&quot; -:&gt; U.Unit</span><span>
</span><span id="line-237"></span><span>  </span><span class="hs-comment">-- TODO: ^ use this one</span><span>
</span><span id="line-238"></span><span>  </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span>
</span><span id="line-239"></span><span>    </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>   </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-240"></span><span>    </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>   </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-241"></span><span>    </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>    </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-243"></span><span>    </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-244"></span><span class="hs-comment">-- inferPrim _   Now         = return $ T.forall [] $ U.Unit -:&gt; U.Time</span><span>
</span><span id="line-245"></span><span>  </span><span class="hs-comment">-- TODO: ^ use this one</span><span>
</span><span id="line-246"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Now"><span class="hs-identifier hs-var">Now</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-247"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#CQuote"><span class="hs-identifier hs-type">CQuote</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-248"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Loop"><span class="hs-identifier hs-var">Loop</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-249"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Break"><span class="hs-identifier hs-var">Break</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span> </span><span class="hs-comment">-- TODO: this is should be void?</span><span>
</span><span id="line-250"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#FfiCall"><span class="hs-identifier hs-type">FfiCall</span></a></span><span> </span><span id="local-6989586621679538546"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538546"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Infer Scheme
forall i. Identifiable i =&gt; i -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679538546"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-251"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#CCall"><span class="hs-identifier hs-type">CCall</span></a></span><span>   </span><span class="annot"><span class="annottext">CSym
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="hs-comment">-- Any type</span><span>
</span><span id="line-252"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#PrimOp"><span class="hs-identifier hs-type">PrimOp</span></a></span><span>  </span><span class="annot"><span class="annottext">PrimOp
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-253"></span><span class="hs-comment">-- TODO: ^ this should actually be returning bool for some ops</span><span>
</span><span id="line-254"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span id="local-6989586621679538543"><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538543"><span class="hs-identifier hs-var">len</span></a></span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Par"><span class="hs-identifier hs-var">Par</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538541"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538540"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538539"><span class="hs-identifier hs-var">ret</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-255"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-256"></span><span>  </span><span id="local-6989586621679538541"><span class="annot"><span class="annottext">tvs :: [TVarId]
</span><a href="#local-6989586621679538541"><span class="hs-identifier hs-var hs-var">tvs</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Kind -&gt; [TVarId] -&gt; [TVarId]
forall a. Kind -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538543"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">([TVarId] -&gt; [TVarId]) -&gt; [TVarId] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Kind -&gt; TVarId) -&gt; [Kind] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; TVarId -&gt; TVarId
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; TVarId) -&gt; (Kind -&gt; TVarId) -&gt; Kind -&gt; TVarId
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; TVarId
forall a b. (Show a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#showId"><span class="hs-identifier hs-var">showId</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Kind
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-257"></span><span>  </span><span id="local-6989586621679538540"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679538540"><span class="hs-identifier hs-var hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; Type) -&gt; [TVarId] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538541"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-258"></span><span>  </span><span id="local-6989586621679538539"><span class="annot"><span class="annottext">ret :: Type
</span><a href="#local-6989586621679538539"><span class="hs-identifier hs-var hs-var">ret</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type
</span><a href="IR.Types.Unification.html#tuple"><span class="hs-identifier hs-var">U.tuple</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538540"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-259"></span><span class="annot"><a href="IR.Types.Inference.html#inferPrim"><span class="hs-identifier hs-var">inferPrim</span></a></span><span> </span><span id="local-6989586621679538536"><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538536"><span class="hs-identifier hs-var">len</span></a></span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Wait"><span class="hs-identifier hs-var">Wait</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538534"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538533"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538532"><span class="hs-identifier hs-var">ret</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-261"></span><span>  </span><span id="local-6989586621679538534"><span class="annot"><span class="annottext">tvs :: [TVarId]
</span><a href="#local-6989586621679538534"><span class="hs-identifier hs-var hs-var">tvs</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Kind -&gt; [TVarId] -&gt; [TVarId]
forall a. Kind -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538536"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">([TVarId] -&gt; [TVarId]) -&gt; [TVarId] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Kind -&gt; TVarId) -&gt; [Kind] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; TVarId -&gt; TVarId
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; TVarId) -&gt; (Kind -&gt; TVarId) -&gt; Kind -&gt; TVarId
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; TVarId
forall a b. (Show a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#showId"><span class="hs-identifier hs-var">showId</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Kind
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-262"></span><span>  </span><span id="local-6989586621679538533"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679538533"><span class="hs-identifier hs-var hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; Type) -&gt; [TVarId] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679538534"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-263"></span><span>  </span><span id="local-6989586621679538532"><span class="annot"><span class="annottext">ret :: Type
</span><a href="#local-6989586621679538532"><span class="hs-identifier hs-var hs-var">ret</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-264"></span><span>
</span><span id="line-265"></span><span class="hs-comment">-- | Type inference rules for literals.</span><span>
</span><span id="line-266"></span><span class="annot"><a href="IR.Types.Inference.html#inferLit"><span class="hs-identifier hs-type">inferLit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span>
</span><span id="line-267"></span><span id="inferLit"><span class="annot"><span class="annottext">inferLit :: Literal -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#inferLit"><span class="hs-identifier hs-var hs-var">inferLit</span></a></span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="IR.IR.html#LitEvent"><span class="hs-identifier hs-var">LitEvent</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-268"></span><span class="annot"><a href="IR.Types.Inference.html#inferLit"><span class="hs-identifier hs-var">inferLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#LitIntegral"><span class="hs-identifier hs-type">LitIntegral</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Scheme) -&gt; Scheme -&gt; Infer Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-269"></span><span class="hs-comment">-- TODO: ^ integral typeclasses</span><span>
</span><span id="line-270"></span><span>
</span><span id="line-271"></span><span class="hs-comment">-- | Check an inferred type (RHS) against some annotations (LHS).</span><span>
</span><span id="line-272"></span><span class="annot"><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-type">checkAgainst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Type.html#Annotations"><span class="hs-identifier hs-type">Annotations</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-273"></span><span id="checkAgainst"><span class="annot"><span class="annottext">checkAgainst :: Annotations
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var hs-var">checkAgainst</span></a></span></span><span> </span><span id="local-6989586621679538529"><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538529"><span class="hs-identifier hs-var">anns</span></a></span></span><span> </span><span id="local-6989586621679538528"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538528"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-274"></span><span>  </span><span class="annot"><span class="annottext">[Annotation]
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="#local-6989586621679538527"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Annotation] -&gt; [Annotation]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">([Annotation] -&gt; [Annotation]) -&gt; [Annotation] -&gt; [Annotation]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Annotations -&gt; [Annotation]
</span><a href="IR.Types.Type.html#unAnnotations"><span class="hs-identifier hs-var">T.unAnnotations</span></a></span><span> </span><span class="annot"><span class="annottext">Annotations
</span><a href="#local-6989586621679538529"><span class="hs-identifier hs-var">anns</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538528"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-275"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-276"></span><span>  </span><span id="local-6989586621679538527"><span class="annot"><span class="annottext">check :: [Annotation]
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="#local-6989586621679538527"><span class="hs-identifier hs-var hs-var">check</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>       </span><span id="local-6989586621679538524"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538524"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538524"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-277"></span><span>  </span><span class="annot"><a href="#local-6989586621679538527"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679538523"><span class="annot"><span class="annottext">Annotation
</span><a href="#local-6989586621679538523"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679538522"><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538522"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679538521"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538521"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-278"></span><span>    </span><span id="local-6989586621679538520"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538520"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Annotation
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var">unravelAnnotation</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538521"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Annotation
</span><a href="#local-6989586621679538523"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-279"></span><span>    </span><span class="annot"><span class="annottext">Type -&gt; Infer ()
</span><a href="IR.Types.Inference.html#checkKind"><span class="hs-identifier hs-var">checkKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538521"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-280"></span><span>    </span><span class="annot"><span class="annottext">Type -&gt; Infer ()
</span><a href="IR.Types.Inference.html#checkKind"><span class="hs-identifier hs-var">checkKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538520"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-281"></span><span>    </span><span id="local-6989586621679538517"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679538517"><span class="hs-identifier hs-var">checksOut</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538521"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; InferM InferCtx Bool
forall ctx. Type -&gt; Type -&gt; InferM ctx Bool
</span><a href="IR.Types.Unification.html#%3C%3A%3D"><span class="hs-operator hs-var">&lt;:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538520"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-282"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; Infer () -&gt; Infer ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679538517"><span class="hs-identifier hs-var">checksOut</span></a></span><span> </span><span class="annot"><span class="annottext">(Infer () -&gt; Infer ()) -&gt; Infer () -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-283"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; Infer ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Infer ()) -&gt; String -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-284"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type annotation is too general:&quot;</span></span><span>
</span><span id="line-285"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Annotation: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Annotation -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Annotation
</span><a href="#local-6989586621679538523"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-286"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Actual type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538521"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-287"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Instantiated ann: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538520"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-288"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-289"></span><span>    </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538521"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538520"><span class="hs-identifier hs-var">t'</span></a></span><span>    </span><span class="hs-comment">-- Now that the annotation is valid, actually unify it</span><span>
</span><span id="line-290"></span><span>    </span><span class="annot"><span class="annottext">[Annotation]
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="#local-6989586621679538527"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538522"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538520"><span class="hs-identifier hs-var">t'</span></a></span><span> </span><span class="hs-comment">-- Pass on the more general annotation type</span><span>
</span><span id="line-291"></span><span>
</span><span id="line-292"></span><span class="hs-comment">-- | Checks the kind of all type constructors in a type.</span><span>
</span><span id="line-293"></span><span class="annot"><a href="IR.Types.Inference.html#checkKind"><span class="hs-identifier hs-type">checkKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-294"></span><span id="checkKind"><span class="annot"><span class="annottext">checkKind :: Type -&gt; Infer ()
</span><a href="IR.Types.Inference.html#checkKind"><span class="hs-identifier hs-var hs-var">checkKind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.Types.Unification.html#TCon"><span class="hs-identifier hs-type">U.TCon</span></a></span><span> </span><span id="local-6989586621679538516"><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538516"><span class="hs-identifier hs-var">tcon</span></a></span></span><span> </span><span id="local-6989586621679538515"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538515"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-295"></span><span>  </span><span id="local-6989586621679538514"><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538514"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TConId -&gt; Infer Kind
</span><a href="IR.Types.Inference.html#lookupKind"><span class="hs-identifier hs-var">lookupKind</span></a></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538516"><span class="hs-identifier hs-var">tcon</span></a></span><span>
</span><span id="line-296"></span><span>  </span><span class="annot"><span class="annottext">Bool -&gt; Infer () -&gt; Infer ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538514"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Kind -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538515"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Infer () -&gt; Infer ()) -&gt; Infer () -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-297"></span><span>    </span><span class="annot"><span class="annottext">Error -&gt; Infer ()
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">U.throwError</span></span><span> </span><span class="annot"><span class="annottext">(Error -&gt; Infer ()) -&gt; Error -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Kind -&gt; Error
</span><a href="#local-6989586621679538513"><span class="hs-identifier hs-var">wrongKind</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538514"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">(Kind -&gt; Error) -&gt; Kind -&gt; Error
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538515"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-298"></span><span>  </span><span class="annot"><span class="annottext">(Type -&gt; Infer ()) -&gt; [Type] -&gt; Infer ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Infer ()
</span><a href="IR.Types.Inference.html#checkKind"><span class="hs-identifier hs-var">checkKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538515"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-299"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-300"></span><span>  </span><span id="local-6989586621679538513"><span class="annot"><span class="annottext">wrongKind :: Kind -&gt; Kind -&gt; Error
</span><a href="#local-6989586621679538513"><span class="hs-identifier hs-var hs-var">wrongKind</span></a></span></span><span> </span><span id="local-6989586621679538511"><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538511"><span class="hs-identifier hs-var">expected</span></a></span></span><span> </span><span id="local-6989586621679538510"><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538510"><span class="hs-identifier hs-var">actual</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ErrorMsg -&gt; Error
</span><a href="Common.Compiler.html#TypeError"><span class="hs-identifier hs-var">Compiler.TypeError</span></a></span><span> </span><span class="annot"><span class="annottext">(ErrorMsg -&gt; Error) -&gt; ErrorMsg -&gt; Error
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ErrorMsg
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ErrorMsg) -&gt; String -&gt; ErrorMsg
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-301"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Wrong kind for type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538516"><span class="hs-identifier hs-var">tcon</span></a></span><span>
</span><span id="line-302"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Expected: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String
</span><a href="#local-6989586621679538509"><span class="hs-identifier hs-var">fmtKind</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538511"><span class="hs-identifier hs-var">expected</span></a></span><span>
</span><span id="line-303"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Actual: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String
</span><a href="#local-6989586621679538509"><span class="hs-identifier hs-var">fmtKind</span></a></span><span> </span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538510"><span class="hs-identifier hs-var">actual</span></a></span><span>
</span><span id="line-304"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-305"></span><span>  </span><span id="local-6989586621679538509"><span class="annot"><span class="annottext">fmtKind :: Kind -&gt; String
</span><a href="#local-6989586621679538509"><span class="hs-identifier hs-var hs-var">fmtKind</span></a></span></span><span> </span><span id="local-6989586621679538508"><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538508"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([String] -&gt; String) -&gt; [String] -&gt; String
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;*&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; [String] -&gt; [String]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String -&gt; [String]
forall a. Kind -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Kind
</span><a href="#local-6989586621679538508"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; -&gt; *&quot;</span></span><span>
</span><span id="line-306"></span><span class="annot"><a href="IR.Types.Inference.html#checkKind"><span class="hs-identifier hs-var">checkKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Infer ()
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span class="hs-comment">{- | Unravel an annotation into a 'Type' according to some inferred 'Type'.

This is necessary because not all annotations are well-formed types; instead,
they may be annotations lifted from annotations in function definitions and
patterns, where data constructor patterns need to be looked up and unpacked.
-}</span><span>
</span><span id="line-314"></span><span class="annot"><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-type">unravelAnnotation</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Type.html#Annotation"><span class="hs-identifier hs-type">Annotation</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-315"></span><span id="unravelAnnotation"><span class="annot"><span class="annottext">unravelAnnotation :: Type
-&gt; Annotation
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var hs-var">unravelAnnotation</span></a></span></span><span> </span><span id="local-6989586621679538506"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538506"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.Types.Type.html#AnnType"><span class="hs-identifier hs-type">T.AnnType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#unfreeze"><span class="hs-identifier hs-var">U.unfreeze</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span id="local-6989586621679538504"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538504"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-316"></span><span>  </span><span id="local-6989586621679538503"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538503"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#rewriteHoles"><span class="hs-identifier hs-var">rewriteHoles</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538506"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538504"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-317"></span><span>  </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Set TVarId -&gt; [TVarId]
forall a. Set a -&gt; [a]
</span><span class="hs-identifier hs-var">S.toList</span></span><span> </span><span class="annot"><span class="annottext">(Set TVarId -&gt; [TVarId]) -&gt; Set TVarId -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Set TVarId
forall t i. HasFreeVars t i =&gt; t -&gt; Set i
</span><a href="Common.Identifiers.html#freeVars"><span class="hs-identifier hs-var">freeVars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538503"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538503"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-318"></span><span class="annot"><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var">unravelAnnotation</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; ([Type], Type)
</span><a href="IR.Types.Unification.html#unfoldArrow"><span class="hs-identifier hs-var">U.unfoldArrow</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679538500"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538500"><span class="hs-identifier hs-var">us</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538499"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538499"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.Types.Type.html#AnnArrows"><span class="hs-identifier hs-type">T.AnnArrows</span></a></span><span> </span><span id="local-6989586621679538497"><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538497"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span id="local-6989586621679538496"><span class="annot"><span class="annottext">Annotation
</span><a href="#local-6989586621679538496"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-319"></span><span>  </span><span class="annot"><span class="annottext">(([Type], Type) -&gt; Type) -&gt; [Type] -&gt; Type -&gt; Type
forall a b c. ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c
</span><span class="hs-identifier hs-var">curry</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span>
</span><span id="line-320"></span><span>    </span><span class="annot"><span class="annottext">([Type] -&gt; Type -&gt; Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; Annotation
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; [Type]
-&gt; [Annotation]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</span><span class="hs-identifier hs-var">zipWithM</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Annotation
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var">unravelAnnotation</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538500"><span class="hs-identifier hs-var">us</span></a></span><span> </span><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538497"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-321"></span><span>    </span><span class="annot"><span class="annottext">ReaderT
  InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Type -&gt; Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Annotation
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var">unravelAnnotation</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Kind -&gt; [Type] -&gt; [Type]
forall a. Kind -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">drop</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Annotation] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538497"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538500"><span class="hs-identifier hs-var">us</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538499"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Annotation
</span><a href="#local-6989586621679538496"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-322"></span><span class="annot"><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var">unravelAnnotation</span></a></span><span> </span><span id="local-6989586621679538493"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538493"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.Types.Type.html#AnnDCon"><span class="hs-identifier hs-type">T.AnnDCon</span></a></span><span> </span><span id="local-6989586621679538491"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538491"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span id="local-6989586621679538490"><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538490"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-323"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679538489"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538489"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679538488"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538488"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([Type], Type)
</span><a href="IR.Types.Unification.html#unfoldArrow"><span class="hs-identifier hs-var">U.unfoldArrow</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; ([Type], Type))
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ([Type], Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Infer Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; Infer Scheme
forall i. Identifiable i =&gt; i -&gt; Infer Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538491"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-324"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538488"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Infer ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538493"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-325"></span><span>  </span><span class="annot"><span class="annottext">Bool -&gt; Infer () -&gt; Infer ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538489"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; Kind -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">[Annotation] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538490"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Infer () -&gt; Infer ()) -&gt; Infer () -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-326"></span><span>    </span><span class="annot"><span class="annottext">String -&gt; Infer ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Infer ()) -&gt; String -&gt; Infer ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; String) -&gt; String -&gt; String
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-327"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Wrong number of arguments in pattern for constructor &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679538491"><span class="hs-identifier hs-var">dc</span></a></span><span>
</span><span id="line-328"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Expected: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538489"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-329"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Got: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Kind -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Annotation] -&gt; Kind
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Kind
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538490"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-330"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-331"></span><span>  </span><span class="annot"><span class="annottext">(Type
 -&gt; Annotation
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; [Type] -&gt; [Annotation] -&gt; Infer ()
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m ()
</span><span class="hs-identifier hs-var">zipWithM_</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Annotation
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#unravelAnnotation"><span class="hs-identifier hs-var">unravelAnnotation</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538489"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[Annotation]
</span><a href="#local-6989586621679538490"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-332"></span><span>  </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538488"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-333"></span><span>
</span><span id="line-334"></span><span class="hs-comment">-- | Rewrite each 'Type' 'Hole' in the RHS according to the LHS.</span><span>
</span><span id="line-335"></span><span class="annot"><a href="IR.Types.Inference.html#rewriteHoles"><span class="hs-identifier hs-type">rewriteHoles</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-336"></span><span id="rewriteHoles"><span class="annot"><span class="annottext">rewriteHoles :: Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#rewriteHoles"><span class="hs-identifier hs-var hs-var">rewriteHoles</span></a></span></span><span> </span><span id="local-6989586621679538487"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538487"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Hole"><span class="hs-identifier hs-var">U.Hole</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538487"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-337"></span><span class="annot"><a href="IR.Types.Inference.html#rewriteHoles"><span class="hs-identifier hs-var">rewriteHoles</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.Types.Unification.html#TCon"><span class="hs-identifier hs-type">U.TCon</span></a></span><span> </span><span id="local-6989586621679538485"><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538485"><span class="hs-identifier hs-var">ud</span></a></span></span><span> </span><span id="local-6989586621679538484"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538484"><span class="hs-identifier hs-var">us</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.Types.Unification.html#TCon"><span class="hs-identifier hs-type">U.TCon</span></a></span><span> </span><span id="local-6989586621679538483"><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538483"><span class="hs-identifier hs-var">td</span></a></span></span><span> </span><span id="local-6989586621679538482"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538482"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538485"><span class="hs-identifier hs-var">ud</span></a></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; TConId -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538483"><span class="hs-identifier hs-var">td</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TConId -&gt; [Type] -&gt; Type
</span><a href="IR.Types.Unification.html#TCon"><span class="hs-identifier hs-var">U.TCon</span></a></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538485"><span class="hs-identifier hs-var">ud</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; Type
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; [Type]
-&gt; [Type]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</span><span class="hs-identifier hs-var">zipWithM</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
</span><a href="IR.Types.Inference.html#rewriteHoles"><span class="hs-identifier hs-var">rewriteHoles</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538484"><span class="hs-identifier hs-var">us</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679538482"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-339"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-340"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type constructor mismatch in annotation: &quot;</span></span><span>
</span><span id="line-341"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Annotated: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538483"><span class="hs-identifier hs-var">td</span></a></span><span>
</span><span id="line-342"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Actual: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679538485"><span class="hs-identifier hs-var">ud</span></a></span><span>
</span><span id="line-343"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-344"></span><span class="annot"><a href="IR.Types.Inference.html#rewriteHoles"><span class="hs-identifier hs-var">rewriteHoles</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679538481"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538481"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679538481"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-345"></span></pre></body></html>