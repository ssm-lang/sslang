<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE OverloadedStrings #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE PartialTypeSignatures #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-partial-type-signatures #-}</span><span>
</span><span id="line-6"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">IR.Types.Inference</span><span>
</span><span id="line-7"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#inferProgram"><span class="hs-identifier">inferProgram</span></a></span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="IR.IR.html"><span class="hs-identifier">IR.IR</span></a></span><span>
</span><span id="line-11"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="IR.SegmentLets.html"><span class="hs-identifier">IR.SegmentLets</span></a></span><span>                 </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="IR.SegmentLets.html#segmentDefs"><span class="hs-identifier">segmentDefs</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="IR.Types.Type.html"><span class="hs-identifier">IR.Types.Type</span></a></span><span>                 </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="IR.Types.Unification.html"><span class="hs-identifier">IR.Types.Unification</span></a></span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">U</span></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="IR.Types.Unification.html"><span class="hs-identifier">IR.Types.Unification</span></a></span><span>           </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#%3C%3A%3D"><span class="hs-operator">(&lt;:=)</span></a></span><span>
</span><span id="line-15"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator">(=:=)</span></a></span><span>
</span><span id="line-16"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Common.Compiler.html"><span class="hs-identifier">Common.Compiler</span></a></span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Compiler</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Common.Identifiers.html"><span class="hs-identifier">Common.Identifiers</span></a></span><span>             </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifiable"><span class="hs-identifier">Identifiable</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-20"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifier"><span class="hs-identifier">Identifier</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-21"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">IsString</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#TVarId"><span class="hs-identifier">TVarId</span></a></span><span>
</span><span id="line-23"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#fromId"><span class="hs-identifier">fromId</span></a></span><span>
</span><span id="line-24"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.Identifiers.html#showId"><span class="hs-identifier">showId</span></a></span><span>
</span><span id="line-25"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>                  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-operator">(&lt;=&lt;)</span></span><span>
</span><span id="line-28"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">forM</span></span><span>
</span><span id="line-29"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">forM_</span></span><span>
</span><span id="line-30"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unless</span></span><span>
</span><span id="line-31"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">when</span></span><span>
</span><span id="line-32"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">zipWithM</span></span><span>
</span><span id="line-33"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span>                 </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Bifunctor</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span>                      </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>                     </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">fromJust</span></span><span>
</span><span id="line-37"></span><span>                                                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span>
</span><span id="line-38"></span><span>                                                </span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span>                      </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">S</span></span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span class="annot"><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-type">var</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.Identifiers.html#TVarId"><span class="hs-identifier hs-type">TVarId</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-42"></span><span id="var"><span class="annot"><span class="annottext">var :: TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var hs-var">var</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-keyword">infixr</span><span> </span><span class="hs-number">5</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-type">-:&gt;</span></a></span><span>
</span><span id="line-45"></span><span class="annot"><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-type">(-:&gt;)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-46"></span><span id="-%3A%3E"><span class="annot"><span class="annottext">-:&gt; :: Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var hs-var">(-:&gt;)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Unification.html#Arrow"><span class="hs-identifier hs-var">U.Arrow</span></a></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-keyword">newtype</span><span> </span><span id="InferCtx"><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-var">InferCtx</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InferCtx"><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-var">InferCtx</span></a></span></span><span>
</span><span id="line-49"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="varMap"><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varMap"><span class="hs-identifier hs-var hs-var">varMap</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifier"><span class="hs-identifier hs-type">Identifier</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-keyword">type</span><span> </span><span id="Infer"><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-var">Infer</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#InferM"><span class="hs-identifier hs-type">U.InferM</span></a></span><span> </span><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-type">InferCtx</span></a></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="annot"><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-type">checkAgainst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span>
</span><span id="line-55"></span><span id="checkAgainst"><span class="annot"><span class="annottext">checkAgainst :: [Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var hs-var">checkAgainst</span></a></span></span><span> </span><span id="local-6989586621679518992"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518992"><span class="hs-identifier hs-var">anns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="#local-6989586621679518991"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Type]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518992"><span class="hs-identifier hs-var">anns</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-57"></span><span>  </span><span id="local-6989586621679518991"><span class="annot"><span class="annottext">check :: [Type] -&gt; Type -&gt; Infer Type
</span><a href="#local-6989586621679518991"><span class="hs-identifier hs-var hs-var">check</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>            </span><span id="local-6989586621679518989"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518989"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Infer Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518989"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-58"></span><span>  </span><span class="annot"><a href="#local-6989586621679518991"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Type.html#Hole"><span class="hs-identifier hs-var">T.Hole</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679518987"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518987"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679518986"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518986"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518987"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518986"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-59"></span><span>  </span><span class="annot"><a href="#local-6989586621679518991"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679518985"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518985"><span class="hs-identifier hs-var">a</span></a></span></span><span>      </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679518984"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518984"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679518983"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518983"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-60"></span><span>    </span><span id="local-6989586621679518982"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518982"><span class="hs-identifier hs-var">t'</span></a></span></span><span>        </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall ctx. Type -&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#unfreezeAnn"><span class="hs-identifier hs-var">U.unfreezeAnn</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518983"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518985"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-61"></span><span>    </span><span id="local-6989586621679518978"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679518978"><span class="hs-identifier hs-var">checksOut</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518983"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; InferM InferCtx Bool
forall ctx. Type -&gt; Type -&gt; InferM ctx Bool
</span><a href="IR.Types.Unification.html#%3C%3A%3D"><span class="hs-operator hs-var">&lt;:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518982"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><span class="annottext">Bool
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679518978"><span class="hs-identifier hs-var">checksOut</span></a></span><span> </span><span class="annot"><span class="annottext">(ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-63"></span><span>      </span><span class="annot"><span class="annottext">String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-64"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type annotation is too general:&quot;</span></span><span>
</span><span id="line-65"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Annotation: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518985"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-66"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Actual type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518983"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-67"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Instantiated ann: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518982"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-68"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518984"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518982"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-70"></span><span>
</span><span id="line-71"></span><span class="annot"><a href="IR.Types.Inference.html#inferProgram"><span class="hs-identifier hs-type">inferProgram</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Program"><span class="hs-identifier hs-type">Program</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.Compiler.html#Pass"><span class="hs-identifier hs-type">Compiler.Pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Program"><span class="hs-identifier hs-type">Program</span></a></span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span id="inferProgram"><span class="annot"><span class="annottext">inferProgram :: Program [Type] -&gt; Pass (Program Type)
</span><a href="IR.Types.Inference.html#inferProgram"><span class="hs-identifier hs-var hs-var">inferProgram</span></a></span></span><span> </span><span id="local-6989586621679518974"><span class="annot"><span class="annottext">Program [Type]
</span><a href="#local-6989586621679518974"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; InferM InferCtx (Program Type) -&gt; Pass (Program Type)
forall ctx a. ctx -&gt; InferM ctx a -&gt; Pass a
</span><a href="IR.Types.Unification.html#runInfer"><span class="hs-identifier hs-var">U.runInfer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Identifier Scheme -&gt; InferCtx
</span><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-var">InferCtx</span></a></span><span> </span><span class="annot"><span class="annottext">Map Identifier Scheme
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(InferM InferCtx (Program Type) -&gt; Pass (Program Type))
-&gt; InferM InferCtx (Program Type) -&gt; Pass (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-73"></span><span>  </span><span id="local-6989586621679518971"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518971"><span class="hs-identifier hs-var">ebs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">((VarId, Type)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
-&gt; [(VarId, Type)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(VarId, Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
</span><a href="IR.Types.Inference.html#externBindings"><span class="hs-identifier hs-var">externBindings</span></a></span><span> </span><span class="annot"><span class="annottext">([(VarId, Type)]
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; [(VarId, Type)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program [Type] -&gt; [(VarId, Type)]
forall t. Program t -&gt; [(VarId, Type)]
</span><a href="IR.IR.html#externDecls"><span class="hs-identifier hs-var hs-var">externDecls</span></a></span><span> </span><span class="annot"><span class="annottext">Program [Type]
</span><a href="#local-6989586621679518974"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-74"></span><span>  </span><span id="local-6989586621679518967"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518967"><span class="hs-identifier hs-var">dbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[[(Binder, Scheme)]] -&gt; [(Binder, Scheme)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[(Binder, Scheme)]] -&gt; [(Binder, Scheme)])
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">((TConId, TypeDef)
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; [(TConId, TypeDef)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(TConId, TypeDef)
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#typedefBindings"><span class="hs-identifier hs-var">typedefBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Program [Type] -&gt; [(TConId, TypeDef)]
forall t. Program t -&gt; [(TConId, TypeDef)]
</span><a href="IR.IR.html#typeDefs"><span class="hs-identifier hs-var hs-var">typeDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program [Type]
</span><a href="#local-6989586621679518974"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; InferM InferCtx (Program Type) -&gt; InferM InferCtx (Program Type)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518971"><span class="hs-identifier hs-var">ebs</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)] -&gt; [(Binder, Scheme)] -&gt; [(Binder, Scheme)]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518967"><span class="hs-identifier hs-var">dbs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(InferM InferCtx (Program Type) -&gt; InferM InferCtx (Program Type))
-&gt; InferM InferCtx (Program Type) -&gt; InferM InferCtx (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679518961"><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679518961"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518960"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518960"><span class="hs-identifier hs-var">ds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(VarId, Expr Type)] -&gt; ([VarId], [Expr Type])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([(VarId, Expr Type)] -&gt; ([VarId], [Expr Type]))
-&gt; (([(Binder, Expr Type)], ()) -&gt; [(VarId, Expr Type)])
-&gt; ([(Binder, Expr Type)], ())
-&gt; ([VarId], [Expr Type])
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Binder, Expr Type) -&gt; (VarId, Expr Type))
-&gt; [(Binder, Expr Type)] -&gt; [(VarId, Expr Type)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Binder -&gt; VarId) -&gt; (Binder, Expr Type) -&gt; (VarId, Expr Type)
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">Binder -&gt; VarId
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([(Binder, Expr Type)] -&gt; [(VarId, Expr Type)])
-&gt; (([(Binder, Expr Type)], ()) -&gt; [(Binder, Expr Type)])
-&gt; ([(Binder, Expr Type)], ())
-&gt; [(VarId, Expr Type)]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">([(Binder, Expr Type)], ()) -&gt; [(Binder, Expr Type)]
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">(([(Binder, Expr Type)], ()) -&gt; ([VarId], [Expr Type]))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     ([(Binder, Expr Type)], ())
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     ([VarId], [Expr Type])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr [Type])]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     ([(Binder, Expr Type)], ())
forall a.
[(Binder, Expr [Type])]
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-var">withDefs</span></a></span><span>
</span><span id="line-77"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((VarId, Expr [Type]) -&gt; (Binder, Expr [Type]))
-&gt; [(VarId, Expr [Type])] -&gt; [(Binder, Expr [Type])]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(VarId -&gt; Binder) -&gt; (VarId, Expr [Type]) -&gt; (Binder, Expr [Type])
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([(VarId, Expr [Type])] -&gt; [(Binder, Expr [Type])])
-&gt; [(VarId, Expr [Type])] -&gt; [(Binder, Expr [Type])]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program [Type] -&gt; [(VarId, Expr [Type])]
forall t. Program t -&gt; [(VarId, Expr t)]
</span><a href="IR.IR.html#programDefs"><span class="hs-identifier hs-var hs-var">programDefs</span></a></span><span> </span><span class="annot"><span class="annottext">Program [Type]
</span><a href="#local-6989586621679518974"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-78"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span>    </span><span id="local-6989586621679518954"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518954"><span class="hs-identifier hs-var">ds'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Expr Type
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; [Expr Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span>
</span><span id="line-80"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Expr Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">((Type
  -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
 -&gt; Expr Type
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; (Type
    -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; Expr Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall ctx. Type -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#freeze"><span class="hs-identifier hs-var">U.freeze</span></a></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type)
-&gt; (Type -&gt; Infer Type)
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Type
forall (m :: * -&gt; *) b c a.
Monad m =&gt;
(b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&lt;=&lt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Infer Type
forall ctx. Type -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#applyBindings"><span class="hs-identifier hs-var">U.applyBindings</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Infer Type) -&gt; (Scheme -&gt; Type) -&gt; Scheme -&gt; Infer Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Type
forall t. SchemeOf t -&gt; t
</span><a href="IR.Types.Type.html#unScheme"><span class="hs-identifier hs-var">T.unScheme</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; (Type
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Type
-&gt; Infer Type
forall (m :: * -&gt; *) b c a.
Monad m =&gt;
(b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&lt;=&lt;</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall ctx. HasFreeUVars ctx =&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#generalize"><span class="hs-identifier hs-var">U.generalize</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-81"></span><span>      </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518960"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="annottext">Program Type -&gt; InferM InferCtx (Program Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Program Type -&gt; InferM InferCtx (Program Type))
-&gt; Program Type -&gt; InferM InferCtx (Program Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Program [Type]
</span><a href="#local-6989586621679518974"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">programDefs :: [(VarId, Expr Type)]
</span><a href="IR.IR.html#programDefs"><span class="hs-identifier hs-var">programDefs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarId] -&gt; [Expr Type] -&gt; [(VarId, Expr Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[VarId]
</span><a href="#local-6989586621679518961"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518954"><span class="hs-identifier hs-var">ds'</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span class="annot"><a href="IR.Types.Inference.html#externBindings"><span class="hs-identifier hs-type">externBindings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#VarId"><span class="hs-identifier hs-type">VarId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span id="externBindings"><span class="annot"><span class="annottext">externBindings :: (VarId, Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
</span><a href="IR.Types.Inference.html#externBindings"><span class="hs-identifier hs-var hs-var">externBindings</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679518949"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518949"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518948"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518948"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-86"></span><span>  </span><span id="local-6989586621679518947"><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679518947"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall ctx. HasFreeUVars ctx =&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#generalize"><span class="hs-identifier hs-var">U.generalize</span></a></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#unfreeze"><span class="hs-identifier hs-var">U.unfreeze</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518948"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-87"></span><span>  </span><span class="annot"><span class="annottext">(Binder, Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518949"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679518947"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="annot"><a href="IR.Types.Inference.html#typedefBindings"><span class="hs-identifier hs-type">typedefBindings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#TConId"><span class="hs-identifier hs-type">TConId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#TypeDef"><span class="hs-identifier hs-type">TypeDef</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-90"></span><span id="typedefBindings"><span class="annot"><span class="annottext">typedefBindings :: (TConId, TypeDef)
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#typedefBindings"><span class="hs-identifier hs-var hs-var">typedefBindings</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679518945"><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679518945"><span class="hs-identifier hs-var">tc</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#TypeDef"><span class="hs-identifier hs-type">TypeDef</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">variants :: TypeDef -&gt; [(DConId, TypeVariant)]
</span><a href="IR.IR.html#variants"><span class="hs-identifier hs-var">variants</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679518942"><span class="annot"><span class="annottext">[(DConId, TypeVariant)]
</span><a href="#local-6989586621679518942"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">targs :: TypeDef -&gt; [TVarId]
</span><a href="IR.IR.html#targs"><span class="hs-identifier hs-var">targs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679518940"><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518940"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-91"></span><span>  </span><span class="annot"><span class="annottext">[(DConId, TypeVariant)]
-&gt; ((DConId, TypeVariant)
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[(DConId, TypeVariant)]
</span><a href="#local-6989586621679518942"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="annot"><span class="annottext">(((DConId, TypeVariant)
  -&gt; ReaderT
       InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; ((DConId, TypeVariant)
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679518939"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518939"><span class="hs-identifier hs-var">dc</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518938"><span class="annot"><span class="annottext">TypeVariant
</span><a href="#local-6989586621679518938"><span class="hs-identifier hs-var">tv</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-92"></span><span>    </span><span id="local-6989586621679518937"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518937"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#unfreeze"><span class="hs-identifier hs-var">U.unfreeze</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; [Type])
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">TypeVariant
</span><a href="#local-6989586621679518938"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-93"></span><span>      </span><span class="annot"><a href="IR.IR.html#VariantUnnamed"><span class="hs-identifier hs-type">VariantUnnamed</span></a></span><span> </span><span id="local-6989586621679518935"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518935"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Type]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518935"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-94"></span><span>      </span><span class="annot"><a href="IR.IR.html#VariantNamed"><span class="hs-identifier hs-type">VariantNamed</span></a></span><span>   </span><span class="annot"><span class="annottext">[(VarId, Type)]
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#todo"><span class="hs-identifier hs-var">Compiler.todo</span></a></span><span>
</span><span id="line-95"></span><span>        </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;typedefBindings cannot yet handle variants with named fields&quot;</span></span><span>
</span><span id="line-96"></span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679518932"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679518932"><span class="hs-identifier hs-var hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TConId -&gt; [Type] -&gt; Type
</span><a href="IR.Types.Unification.html#TCon"><span class="hs-identifier hs-var">U.TCon</span></a></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679518945"><span class="hs-identifier hs-var">tc</span></a></span><span> </span><span class="annot"><span class="annottext">([Type] -&gt; Type) -&gt; [Type] -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; Type) -&gt; [TVarId] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Unification.html#TVar"><span class="hs-identifier hs-var">U.TVar</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518940"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-98"></span><span>        </span><span id="local-6989586621679518930"><span class="annot"><span class="annottext">s :: Scheme
</span><a href="#local-6989586621679518930"><span class="hs-identifier hs-var hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518940"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518937"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518932"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span>    </span><span id="local-6989586621679518927"><span class="annot"><span class="annottext">Set IntVar
</span><a href="#local-6989586621679518927"><span class="hs-identifier hs-var">ftvs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; InferM InferCtx (Set IntVar)
forall a ctx. HasFreeUVars a =&gt; a -&gt; InferM ctx (Set IntVar)
</span><a href="IR.Types.Unification.html#freeUVars"><span class="hs-identifier hs-var">U.freeUVars</span></a></span><span> </span><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679518930"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-101"></span><span>    </span><span class="annot"><span class="annottext">Bool
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Set IntVar
forall a. Set a
</span><span class="hs-identifier hs-var">S.empty</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar -&gt; Set IntVar -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar
</span><a href="#local-6989586621679518927"><span class="hs-identifier hs-var">ftvs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-102"></span><span>      </span><span class="annot"><span class="annottext">String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-103"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type definition contains unbound type variables:&quot;</span></span><span>
</span><span id="line-104"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;        &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unwords</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(IntVar -&gt; String) -&gt; [IntVar] -&gt; [String]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">IntVar -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">([IntVar] -&gt; [String]) -&gt; [IntVar] -&gt; [String]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar -&gt; [IntVar]
forall a. Set a -&gt; [a]
</span><span class="hs-identifier hs-var">S.toList</span></span><span> </span><span class="annot"><span class="annottext">Set IntVar
</span><a href="#local-6989586621679518927"><span class="hs-identifier hs-var">ftvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;for type : &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">TConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">TConId
</span><a href="#local-6989586621679518945"><span class="hs-identifier hs-var">tc</span></a></span><span>
</span><span id="line-106"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;from data constructor: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518939"><span class="hs-identifier hs-var">dc</span></a></span><span>
</span><span id="line-107"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span>    </span><span class="annot"><span class="annottext">(Binder, Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Binder, Scheme)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VarId -&gt; Binder
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(VarId -&gt; Binder) -&gt; VarId -&gt; Binder
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; VarId
forall a b. (Identifiable a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#fromId"><span class="hs-identifier hs-var">fromId</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518939"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Scheme
</span><a href="#local-6989586621679518930"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span id="local-6989586621679519112"><span class="annot"><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-type">withDefs</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679519112"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679519112"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-113"></span><span id="withDefs"><span class="annot"><span class="annottext">withDefs :: [(Binder, Expr [Type])]
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-var hs-var">withDefs</span></a></span></span><span> </span><span id="local-6989586621679518922"><span class="annot"><span class="annottext">[(Binder, Expr [Type])]
</span><a href="#local-6989586621679518922"><span class="hs-identifier hs-var">defs</span></a></span></span><span> </span><span id="local-6989586621679518921"><span class="annot"><span class="annottext">Infer a
</span><a href="#local-6989586621679518921"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[(Binder, Expr [Type])]] -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="#local-6989586621679518920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">([[(Binder, Expr [Type])]] -&gt; Infer ([(Binder, Expr Type)], a))
-&gt; [[(Binder, Expr [Type])]] -&gt; Infer ([(Binder, Expr Type)], a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr [Type])] -&gt; [[(Binder, Expr [Type])]]
forall t. Show t =&gt; [Def t] -&gt; [[Def t]]
</span><a href="IR.SegmentLets.html#segmentDefs"><span class="hs-identifier hs-var">segmentDefs</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr [Type])]
</span><a href="#local-6989586621679518922"><span class="hs-identifier hs-var">defs</span></a></span><span>
</span><span id="line-114"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-115"></span><span>  </span><span class="annot"><a href="#local-6989586621679518920"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>  </span><span id="local-6989586621679518920"><span class="annot"><span class="annottext">go :: [[(Binder, Expr [Type])]] -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="#local-6989586621679518920"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Binder, Expr [Type])] -&gt; ([Binder], [Expr [Type]])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679518919"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518919"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518918"><span class="annot"><span class="annottext">[Expr [Type]]
</span><a href="#local-6989586621679518918"><span class="hs-identifier hs-var">es</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679518917"><span class="annot"><span class="annottext">[[(Binder, Expr [Type])]]
</span><a href="#local-6989586621679518917"><span class="hs-identifier hs-var">dss</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-117"></span><span>    </span><span class="hs-comment">-- Create fresh unification variable for each binder</span><span>
</span><span id="line-118"></span><span>    </span><span id="local-6989586621679518916"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518916"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Binder -&gt; Infer Type)
-&gt; [Binder]
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Infer Type -&gt; Binder -&gt; Infer Type
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Infer Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518919"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span>    </span><span class="hs-comment">-- Create empty scheme for each binder's unification variable</span><span>
</span><span id="line-121"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679518913"><span class="annot"><span class="annottext">ss :: [Scheme]
</span><a href="#local-6989586621679518913"><span class="hs-identifier hs-var hs-var">ss</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; [Type] -&gt; [Scheme]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518916"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span>    </span><span class="hs-comment">-- Infer definitions with those schemes in scope</span><span>
</span><span id="line-124"></span><span>    </span><span id="local-6989586621679518912"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518912"><span class="hs-identifier hs-var">es'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)] -&gt; Infer [Expr Type] -&gt; Infer [Expr Type]
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; [Scheme] -&gt; [(Binder, Scheme)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518919"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Scheme]
</span><a href="#local-6989586621679518913"><span class="hs-identifier hs-var">ss</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Infer [Expr Type] -&gt; Infer [Expr Type])
-&gt; Infer [Expr Type] -&gt; Infer [Expr Type]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Expr [Type]
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; [Expr [Type]] -&gt; Infer [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr [Type]]
</span><a href="#local-6989586621679518918"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span>    </span><span class="hs-comment">-- Unify unification variables with the inferred type of each definition</span><span>
</span><span id="line-127"></span><span>    </span><span class="annot"><span class="annottext">[(Type, Expr Type)]
-&gt; ((Type, Expr Type)
    -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m ()
</span><span class="hs-identifier hs-var">forM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Expr Type] -&gt; [(Type, Expr Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518916"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518912"><span class="hs-identifier hs-var">es'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(((Type, Expr Type)
  -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; ((Type, Expr Type)
    -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679518910"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518910"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span id="local-6989586621679518908"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518908"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518910"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518908"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span>    </span><span id="local-6989586621679518907"><span class="annot"><span class="annottext">[Scheme]
</span><a href="#local-6989586621679518907"><span class="hs-identifier hs-var">ss'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Expr Type]
-&gt; (Expr Type
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Scheme]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518912"><span class="hs-identifier hs-var">es'</span></a></span><span> </span><span class="annot"><span class="annottext">((Expr Type
  -&gt; ReaderT
       InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Scheme])
-&gt; (Expr Type
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) [Scheme]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679518906"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518906"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Bool
forall t. Expr t -&gt; Bool
</span><a href="IR.IR.html#isValue"><span class="hs-identifier hs-var">isValue</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518906"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-130"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall ctx. HasFreeUVars ctx =&gt; Type -&gt; InferM ctx Scheme
</span><a href="IR.Types.Unification.html#generalize"><span class="hs-identifier hs-var">U.generalize</span></a></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518906"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-131"></span><span>      </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518906"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span>    </span><span class="annot"><span class="annottext">([(Binder, Expr Type)] -&gt; [(Binder, Expr Type)])
-&gt; ([(Binder, Expr Type)], a) -&gt; ([(Binder, Expr Type)], a)
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; [Expr Type] -&gt; [(Binder, Expr Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518919"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518912"><span class="hs-identifier hs-var">es'</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
-&gt; [(Binder, Expr Type)] -&gt; [(Binder, Expr Type)]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(([(Binder, Expr Type)], a) -&gt; ([(Binder, Expr Type)], a))
-&gt; Infer ([(Binder, Expr Type)], a)
-&gt; Infer ([(Binder, Expr Type)], a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; Infer ([(Binder, Expr Type)], a)
-&gt; Infer ([(Binder, Expr Type)], a)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; [Scheme] -&gt; [(Binder, Scheme)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518919"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">[Scheme]
</span><a href="#local-6989586621679518907"><span class="hs-identifier hs-var">ss'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[[(Binder, Expr [Type])]] -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="#local-6989586621679518920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[[(Binder, Expr [Type])]]
</span><a href="#local-6989586621679518917"><span class="hs-identifier hs-var">dss</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-134"></span><span>  </span><span class="annot"><a href="#local-6989586621679518920"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[[(Binder, Expr [Type])]]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(a -&gt; ([(Binder, Expr Type)], a))
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Infer a
</span><a href="#local-6989586621679518921"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-type">inferExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="IR.Types.Type.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Expr"><span class="hs-identifier hs-type">Expr</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-137"></span><span id="inferExpr"><span class="annot"><span class="annottext">inferExpr :: Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var hs-var">inferExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Var"><span class="hs-identifier hs-type">Var</span></a></span><span> </span><span id="local-6989586621679518903"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518903"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621679518902"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518902"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-138"></span><span>  </span><span id="local-6989586621679518901"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518901"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">VarId
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall i.
Identifiable i =&gt;
i
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518903"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-139"></span><span>  </span><span class="annot"><span class="annottext">VarId -&gt; Type -&gt; Expr Type
forall t. VarId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Var"><span class="hs-identifier hs-var">Var</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518903"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518902"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518901"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-140"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Data"><span class="hs-identifier hs-type">Data</span></a></span><span> </span><span id="local-6989586621679518898"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518898"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621679518897"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518897"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-141"></span><span>  </span><span id="local-6989586621679518896"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518896"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">DConId
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall i.
Identifiable i =&gt;
i
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518898"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-142"></span><span>  </span><span class="annot"><span class="annottext">DConId -&gt; Type -&gt; Expr Type
forall t. DConId -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Data"><span class="hs-identifier hs-var">Data</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518898"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518897"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518896"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-143"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621679518894"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679518894"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679518893"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518893"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-144"></span><span>  </span><span id="local-6989586621679518892"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518892"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Literal
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupLit"><span class="hs-identifier hs-var">lookupLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679518894"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-145"></span><span>  </span><span class="annot"><span class="annottext">Literal -&gt; Type -&gt; Expr Type
forall t. Literal -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Lit"><span class="hs-identifier hs-var">Lit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679518894"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518893"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518892"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-146"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679518889"><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518889"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679518888"><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518888"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679518887"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518887"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-147"></span><span>  </span><span id="local-6989586621679518886"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518886"><span class="hs-identifier hs-var">f'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518889"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-148"></span><span>  </span><span id="local-6989586621679518885"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518885"><span class="hs-identifier hs-var">a'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518888"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-149"></span><span>  </span><span id="local-6989586621679518884"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518884"><span class="hs-identifier hs-var">rt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Infer Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-150"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518886"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518885"><span class="hs-identifier hs-var">a'</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518884"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-151"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518886"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518885"><span class="hs-identifier hs-var">a'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518887"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518884"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-152"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Let"><span class="hs-identifier hs-type">Let</span></a></span><span> </span><span id="local-6989586621679518882"><span class="annot"><span class="annottext">[(Binder, Expr [Type])]
</span><a href="#local-6989586621679518882"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span id="local-6989586621679518881"><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518881"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679518880"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518880"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-153"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679518879"><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679518879"><span class="hs-identifier hs-var">ds'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518878"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518878"><span class="hs-identifier hs-var">e'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr [Type])]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; Infer ([(Binder, Expr Type)], Expr Type)
forall a.
[(Binder, Expr [Type])]
-&gt; Infer a -&gt; Infer ([(Binder, Expr Type)], a)
</span><a href="IR.Types.Inference.html#withDefs"><span class="hs-identifier hs-var">withDefs</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr [Type])]
</span><a href="#local-6989586621679518882"><span class="hs-identifier hs-var">ds</span></a></span><span> </span><span class="annot"><span class="annottext">(ReaderT
   InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
 -&gt; Infer ([(Binder, Expr Type)], Expr Type))
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; Infer ([(Binder, Expr Type)], Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518881"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-154"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Expr Type)] -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. [(Binder, Expr t)] -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Let"><span class="hs-identifier hs-var">Let</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Expr Type)]
</span><a href="#local-6989586621679518879"><span class="hs-identifier hs-var">ds'</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518878"><span class="hs-identifier hs-var">e'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518880"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518878"><span class="hs-identifier hs-var">e'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-155"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Lambda"><span class="hs-identifier hs-type">Lambda</span></a></span><span> </span><span id="local-6989586621679518876"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679518876"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679518875"><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518875"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679518874"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518874"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-156"></span><span>  </span><span id="local-6989586621679518873"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518873"><span class="hs-identifier hs-var">at</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Infer Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-157"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679518876"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518873"><span class="hs-identifier hs-var">at</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(ReaderT
   InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-158"></span><span>    </span><span id="local-6989586621679518872"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518872"><span class="hs-identifier hs-var">b'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518875"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-159"></span><span>    </span><span class="annot"><span class="annottext">Binder -&gt; Expr Type -&gt; Type -&gt; Expr Type
forall t. Binder -&gt; Expr t -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Lambda"><span class="hs-identifier hs-var">Lambda</span></a></span><span> </span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679518876"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518872"><span class="hs-identifier hs-var">b'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518874"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518873"><span class="hs-identifier hs-var">at</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518872"><span class="hs-identifier hs-var">b'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span id="local-6989586621679518870"><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518870"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679518869"><span class="annot"><span class="annottext">[(Alt, Expr [Type])]
</span><a href="#local-6989586621679518869"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span id="local-6989586621679518868"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518868"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-161"></span><span>  </span><span id="local-6989586621679518867"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518867"><span class="hs-identifier hs-var">s'</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518870"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-162"></span><span>  </span><span id="local-6989586621679518866"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518866"><span class="hs-identifier hs-var">rt</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Infer Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span id="local-6989586621679518865"><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679518865"><span class="hs-identifier hs-var">as'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr [Type])]
-&gt; ((Alt, Expr [Type])
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Alt, Expr Type)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><span class="hs-identifier hs-var">forM</span></span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr [Type])]
</span><a href="#local-6989586621679518869"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">(((Alt, Expr [Type])
  -&gt; ReaderT
       InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Alt, Expr Type)])
-&gt; ((Alt, Expr [Type])
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Alt, Expr Type)]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679518864"><span class="annot"><span class="annottext">Alt
</span><a href="#local-6989586621679518864"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518863"><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518863"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-164"></span><span>    </span><span id="local-6989586621679518862"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518862"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Alt
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518867"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Alt
</span><a href="#local-6989586621679518864"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-165"></span><span>    </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
forall a. [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var">withBindings</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518862"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">(ReaderT
   InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type))
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-166"></span><span>      </span><span id="local-6989586621679518860"><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518860"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
</span><a href="#local-6989586621679518863"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-167"></span><span>      </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518866"><span class="hs-identifier hs-var">rt</span></a></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518860"><span class="hs-identifier hs-var">c'</span></a></span><span>
</span><span id="line-168"></span><span>      </span><span class="annot"><span class="annottext">(Alt, Expr Type)
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Alt, Expr Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Alt
</span><a href="#local-6989586621679518864"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518860"><span class="hs-identifier hs-var">c'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-169"></span><span>  </span><span class="annot"><span class="annottext">Expr Type -&gt; [(Alt, Expr Type)] -&gt; Type -&gt; Expr Type
forall t. Expr t -&gt; [(Alt, Expr t)] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Match"><span class="hs-identifier hs-var">Match</span></a></span><span> </span><span class="annot"><span class="annottext">Expr Type
</span><a href="#local-6989586621679518867"><span class="hs-identifier hs-var">s'</span></a></span><span> </span><span class="annot"><span class="annottext">[(Alt, Expr Type)]
</span><a href="#local-6989586621679518865"><span class="hs-identifier hs-var">as'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518868"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518866"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-170"></span><span class="annot"><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#Prim"><span class="hs-identifier hs-type">Prim</span></a></span><span> </span><span id="local-6989586621679518858"><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679518858"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679518857"><span class="annot"><span class="annottext">[Expr [Type]]
</span><a href="#local-6989586621679518857"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span id="local-6989586621679518856"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518856"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-171"></span><span>  </span><span id="local-6989586621679518855"><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518855"><span class="hs-identifier hs-var">es'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Expr [Type]
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type))
-&gt; [Expr [Type]] -&gt; Infer [Expr Type]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Expr [Type]
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
</span><a href="IR.Types.Inference.html#inferExpr"><span class="hs-identifier hs-var">inferExpr</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr [Type]]
</span><a href="#local-6989586621679518857"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-172"></span><span>  </span><span id="local-6989586621679518854"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518854"><span class="hs-identifier hs-var">rt</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Infer Type
forall ctx. InferM ctx Type
</span><a href="IR.Types.Unification.html#fresh"><span class="hs-identifier hs-var">U.fresh</span></a></span><span>
</span><span id="line-173"></span><span>  </span><span id="local-6989586621679518853"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518853"><span class="hs-identifier hs-var">t</span></a></span></span><span>   </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
-&gt; Primitive
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Expr [Type]] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Expr [Type]]
</span><a href="#local-6989586621679518857"><span class="hs-identifier hs-var">es</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679518858"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-174"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518853"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Expr Type -&gt; Type) -&gt; [Expr Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Expr Type -&gt; Type
forall t. Expr t -&gt; t
</span><a href="IR.IR.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518855"><span class="hs-identifier hs-var">es'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518854"><span class="hs-identifier hs-var">rt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-175"></span><span>  </span><span class="annot"><span class="annottext">Primitive -&gt; [Expr Type] -&gt; Type -&gt; Expr Type
forall t. Primitive -&gt; [Expr t] -&gt; t -&gt; Expr t
</span><a href="IR.IR.html#Prim"><span class="hs-identifier hs-var">Prim</span></a></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="#local-6989586621679518858"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[Expr Type]
</span><a href="#local-6989586621679518855"><span class="hs-identifier hs-var">es'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Expr Type)
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) (Expr Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Infer Type
</span><a href="IR.Types.Inference.html#checkAgainst"><span class="hs-identifier hs-var">checkAgainst</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518856"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518854"><span class="hs-identifier hs-var">rt</span></a></span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span class="annot"><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-type">inferAlt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Type"><span class="hs-identifier hs-type">U.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-178"></span><span id="inferAlt"><span class="annot"><span class="annottext">inferAlt :: Type
-&gt; Alt
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var hs-var">inferAlt</span></a></span></span><span> </span><span id="local-6989586621679518850"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518850"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltData"><span class="hs-identifier hs-type">AltData</span></a></span><span> </span><span id="local-6989586621679518848"><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518848"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679518847"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518847"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679518846"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518846"><span class="hs-identifier hs-var">ats</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518845"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518845"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([Type], Type)
</span><a href="IR.Types.Unification.html#unfoldArrow"><span class="hs-identifier hs-var">U.unfoldArrow</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; ([Type], Type))
-&gt; Infer Type
-&gt; ReaderT
     InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ([Type], Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">DConId
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall i.
Identifiable i =&gt;
i
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518848"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518850"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518845"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-181"></span><span>  </span><span class="annot"><span class="annottext">Bool
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518846"><span class="hs-identifier hs-var">ats</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">[Binder] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518847"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-182"></span><span>    </span><span class="annot"><span class="annottext">String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall (m :: * -&gt; *) a. MonadError Error m =&gt; String -&gt; m a
</span><a href="Common.Compiler.html#typeError"><span class="hs-identifier hs-var">Compiler.typeError</span></a></span><span> </span><span class="annot"><span class="annottext">(String
 -&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ())
-&gt; String
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-183"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Wrong number of arguments for data constructor: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">DConId -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">DConId
</span><a href="#local-6989586621679518848"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-184"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Expected: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518846"><span class="hs-identifier hs-var">ats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-185"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Got: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Binder] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518847"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-187"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679518842"><span class="annot"><span class="annottext">as' :: [Alt]
</span><a href="#local-6989586621679518842"><span class="hs-identifier hs-var hs-var">as'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Binder -&gt; Alt) -&gt; [Binder] -&gt; [Alt]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Binder -&gt; Alt
</span><a href="IR.IR.html#AltDefault"><span class="hs-identifier hs-var">AltDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679518847"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="hs-comment">-- TODO: remove for nested patterns, just use as</span><span>
</span><span id="line-188"></span><span>  </span><span class="annot"><span class="annottext">[[(Binder, Scheme)]] -&gt; [(Binder, Scheme)]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[(Binder, Scheme)]] -&gt; [(Binder, Scheme)])
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Type
 -&gt; Alt
 -&gt; ReaderT
      InferCtx
      (ExceptT Error (IntBindingT TypeF Pass))
      [(Binder, Scheme)])
-&gt; [Type]
-&gt; [Alt]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [[(Binder, Scheme)]]
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</span><span class="hs-identifier hs-var">zipWithM</span></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Alt
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
</span><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518846"><span class="hs-identifier hs-var">ats</span></a></span><span> </span><span class="annot"><span class="annottext">[Alt]
</span><a href="#local-6989586621679518842"><span class="hs-identifier hs-var">as'</span></a></span><span>
</span><span id="line-189"></span><span class="annot"><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span id="local-6989586621679518840"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518840"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltLit"><span class="hs-identifier hs-type">AltLit</span></a></span><span> </span><span id="local-6989586621679518838"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679518838"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-190"></span><span>  </span><span id="local-6989586621679518837"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518837"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; Infer Type
forall ctx. Scheme -&gt; InferM ctx Type
</span><a href="IR.Types.Unification.html#instantiate"><span class="hs-identifier hs-var">U.instantiate</span></a></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; Infer Type)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; Infer Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Literal
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupLit"><span class="hs-identifier hs-var">lookupLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621679518838"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-191"></span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518840"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
-&gt; Type
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) ()
forall ctx. Type -&gt; Type -&gt; InferM ctx ()
</span><a href="IR.Types.Unification.html#%3D%3A%3D"><span class="hs-operator hs-var">=:=</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518837"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-192"></span><span>  </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-193"></span><span class="annot"><a href="IR.Types.Inference.html#inferAlt"><span class="hs-identifier hs-var">inferAlt</span></a></span><span> </span><span id="local-6989586621679518836"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518836"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#AltDefault"><span class="hs-identifier hs-type">AltDefault</span></a></span><span> </span><span id="local-6989586621679518835"><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679518835"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
-&gt; ReaderT
     InferCtx
     (ExceptT Error (IntBindingT TypeF Pass))
     [(Binder, Scheme)]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Binder
</span><a href="#local-6989586621679518835"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518836"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-type">lookupPrim</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.IR.html#Primitive"><span class="hs-identifier hs-type">Primitive</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span>
</span><span id="line-196"></span><span id="lookupPrim"><span class="annot"><span class="annottext">lookupPrim :: Int
-&gt; Primitive
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var hs-var">lookupPrim</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#New"><span class="hs-identifier hs-var">New</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-197"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Dup"><span class="hs-identifier hs-var">Dup</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-198"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Drop"><span class="hs-identifier hs-var">Drop</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-199"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Deref"><span class="hs-identifier hs-var">Deref</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-200"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Assign"><span class="hs-identifier hs-var">Assign</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-201"></span><span>  </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-202"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#After"><span class="hs-identifier hs-var">After</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-comment">-- return $ T.forall [&quot;a&quot;] $ U.Time -:&gt; U.Ref (var &quot;a&quot;) -:&gt; var &quot;a&quot; -:&gt; U.Unit</span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-comment">-- TODO: ^ use this one</span><span>
</span><span id="line-205"></span><span>  </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="IR.Types.Unification.html#Ref"><span class="hs-identifier hs-var">U.Ref</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-206"></span><span class="hs-comment">-- lookupPrim _   Now         = return $ T.forall [] $ U.Unit -:&gt; U.Time</span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-comment">-- TODO: ^ use this one</span><span>
</span><span id="line-208"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Now"><span class="hs-identifier hs-var">Now</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-209"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#CQuote"><span class="hs-identifier hs-type">CQuote</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-210"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Loop"><span class="hs-identifier hs-var">Loop</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-211"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Break"><span class="hs-identifier hs-var">Break</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span> </span><span class="hs-comment">-- TODO: this is should be void?</span><span>
</span><span id="line-212"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#FfiCall"><span class="hs-identifier hs-type">FfiCall</span></a></span><span> </span><span id="local-6989586621679518820"><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518820"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarId
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall i.
Identifiable i =&gt;
i
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var">lookupBinding</span></a></span><span> </span><span class="annot"><span class="annottext">VarId
</span><a href="#local-6989586621679518820"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-213"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#CCall"><span class="hs-identifier hs-type">CCall</span></a></span><span>   </span><span class="annot"><span class="annottext">CSym
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="hs-comment">-- Any type</span><span>
</span><span id="line-214"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#PrimOp"><span class="hs-identifier hs-type">PrimOp</span></a></span><span>  </span><span class="annot"><span class="annottext">PrimOp
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="IR.Types.Inference.html#-%3A%3E"><span class="hs-operator hs-var">-:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-215"></span><span class="hs-comment">-- TODO: ^ this should actually be returning bool for some ops</span><span>
</span><span id="line-216"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span id="local-6989586621679518817"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679518817"><span class="hs-identifier hs-var">len</span></a></span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Par"><span class="hs-identifier hs-var">Par</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518815"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518814"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518813"><span class="hs-identifier hs-var">ret</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-217"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-218"></span><span>  </span><span id="local-6989586621679518815"><span class="annot"><span class="annottext">tvs :: [TVarId]
</span><a href="#local-6989586621679518815"><span class="hs-identifier hs-var hs-var">tvs</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [TVarId] -&gt; [TVarId]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679518817"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">([TVarId] -&gt; [TVarId]) -&gt; [TVarId] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; TVarId) -&gt; [Int] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; TVarId -&gt; TVarId
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; TVarId) -&gt; (Int -&gt; TVarId) -&gt; Int -&gt; TVarId
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; TVarId
forall a b. (Show a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#showId"><span class="hs-identifier hs-var">showId</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-219"></span><span>  </span><span id="local-6989586621679518814"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679518814"><span class="hs-identifier hs-var hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; Type) -&gt; [TVarId] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518815"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-220"></span><span>  </span><span id="local-6989586621679518813"><span class="annot"><span class="annottext">ret :: Type
</span><a href="#local-6989586621679518813"><span class="hs-identifier hs-var hs-var">ret</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type
</span><a href="IR.Types.Unification.html#tuple"><span class="hs-identifier hs-var">U.tuple</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518814"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-221"></span><span class="annot"><a href="IR.Types.Inference.html#lookupPrim"><span class="hs-identifier hs-var">lookupPrim</span></a></span><span> </span><span id="local-6989586621679518810"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679518810"><span class="hs-identifier hs-var">len</span></a></span></span><span> </span><span class="annot"><span class="annottext">Primitive
</span><a href="IR.IR.html#Wait"><span class="hs-identifier hs-var">Wait</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518808"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Scheme) -&gt; Type -&gt; Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([Type], Type) -&gt; Type
</span><a href="IR.Types.Unification.html#foldArrow"><span class="hs-identifier hs-var">U.foldArrow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679518807"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679518806"><span class="hs-identifier hs-var">ret</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-222"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-223"></span><span>  </span><span id="local-6989586621679518808"><span class="annot"><span class="annottext">tvs :: [TVarId]
</span><a href="#local-6989586621679518808"><span class="hs-identifier hs-var hs-var">tvs</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; [TVarId] -&gt; [TVarId]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679518810"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">([TVarId] -&gt; [TVarId]) -&gt; [TVarId] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; TVarId) -&gt; [Int] -&gt; [TVarId]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">TVarId
</span><span class="hs-string">&quot;a&quot;</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; TVarId -&gt; TVarId
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; TVarId) -&gt; (Int -&gt; TVarId) -&gt; Int -&gt; TVarId
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; TVarId
forall a b. (Show a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#showId"><span class="hs-identifier hs-var">showId</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-224"></span><span>  </span><span id="local-6989586621679518807"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679518807"><span class="hs-identifier hs-var hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TVarId -&gt; Type) -&gt; [TVarId] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TVarId -&gt; Type
</span><a href="IR.Types.Inference.html#var"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">[TVarId]
</span><a href="#local-6989586621679518808"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-225"></span><span>  </span><span id="local-6989586621679518806"><span class="annot"><span class="annottext">ret :: Type
</span><a href="#local-6989586621679518806"><span class="hs-identifier hs-var hs-var">ret</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span class="annot"><a href="IR.Types.Inference.html#lookupLit"><span class="hs-identifier hs-type">lookupLit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="IR.IR.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span>
</span><span id="line-228"></span><span id="lookupLit"><span class="annot"><span class="annottext">lookupLit :: Literal
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupLit"><span class="hs-identifier hs-var hs-var">lookupLit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="IR.IR.html#LitIntegral"><span class="hs-identifier hs-type">LitIntegral</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#I32"><span class="hs-identifier hs-var">U.I32</span></a></span><span>
</span><span id="line-229"></span><span class="hs-comment">-- TODO: ^ integral typeclasses</span><span>
</span><span id="line-230"></span><span class="annot"><a href="IR.Types.Inference.html#lookupLit"><span class="hs-identifier hs-var">lookupLit</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="IR.IR.html#LitEvent"><span class="hs-identifier hs-var">LitEvent</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TVarId] -&gt; Type -&gt; Scheme
forall (l :: * -&gt; *) t.
(Functor l, Foldable l) =&gt;
l TVarId -&gt; t -&gt; SchemeOf t
</span><a href="IR.Types.Type.html#forall"><span class="hs-identifier hs-var">T.forall</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="IR.Types.Unification.html#Unit"><span class="hs-identifier hs-var">U.Unit</span></a></span><span>
</span><span id="line-231"></span><span>
</span><span id="line-232"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#HasFreeUVars"><span class="hs-identifier hs-type">U.HasFreeUVars</span></a></span><span> </span><span class="annot"><a href="IR.Types.Inference.html#InferCtx"><span class="hs-identifier hs-type">InferCtx</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-233"></span><span>  </span><span id="local-6989586621679518801"><span class="annot"><span class="annottext">freeUVars :: InferCtx -&gt; InferM ctx (Set IntVar)
</span><a href="#local-6989586621679518801"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeUVars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Set IntVar] -&gt; Set IntVar)
-&gt; ReaderT
     ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
-&gt; InferM ctx (Set IntVar)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">[Set IntVar] -&gt; Set IntVar
forall (f :: * -&gt; *) a. (Foldable f, Ord a) =&gt; f (Set a) -&gt; Set a
</span><span class="hs-identifier hs-var">S.unions</span></span><span> </span><span class="annot"><span class="annottext">(ReaderT ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
 -&gt; InferM ctx (Set IntVar))
-&gt; (InferCtx
    -&gt; ReaderT
         ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar])
-&gt; InferCtx
-&gt; InferM ctx (Set IntVar)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Scheme -&gt; InferM ctx (Set IntVar))
-&gt; [Scheme]
-&gt; ReaderT
     ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Scheme -&gt; InferM ctx (Set IntVar)
forall a ctx. HasFreeUVars a =&gt; a -&gt; InferM ctx (Set IntVar)
</span><a href="IR.Types.Unification.html#freeUVars"><span class="hs-identifier hs-var">U.freeUVars</span></a></span><span> </span><span class="annot"><span class="annottext">([Scheme]
 -&gt; ReaderT
      ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar])
-&gt; (InferCtx -&gt; [Scheme])
-&gt; InferCtx
-&gt; ReaderT
     ctx (ExceptT Error (IntBindingT TypeF Pass)) [Set IntVar]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Map Identifier Scheme -&gt; [Scheme]
forall k a. Map k a -&gt; [a]
</span><span class="hs-identifier hs-var">M.elems</span></span><span> </span><span class="annot"><span class="annottext">(Map Identifier Scheme -&gt; [Scheme])
-&gt; (InferCtx -&gt; Map Identifier Scheme) -&gt; InferCtx -&gt; [Scheme]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varMap"><span class="hs-identifier hs-var hs-var">varMap</span></a></span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span id="local-6989586621679519130"><span class="annot"><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-type">withBindings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Common.Identifiers.html#Binder"><span class="hs-identifier hs-type">Binder</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679519130"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679519130"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-236"></span><span id="withBindings"><span class="annot"><span class="annottext">withBindings :: [(Binder, Scheme)] -&gt; Infer a -&gt; Infer a
</span><a href="IR.Types.Inference.html#withBindings"><span class="hs-identifier hs-var hs-var">withBindings</span></a></span></span><span> </span><span id="local-6989586621679518798"><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518798"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(InferCtx -&gt; InferCtx) -&gt; Infer a -&gt; Infer a
forall r (m :: * -&gt; *) a. MonadReader r m =&gt; (r -&gt; r) -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">U.local</span></span><span>
</span><span id="line-237"></span><span>  </span><span class="annot"><span class="annottext">((InferCtx -&gt; InferCtx) -&gt; Infer a -&gt; Infer a)
-&gt; (InferCtx -&gt; InferCtx) -&gt; Infer a -&gt; Infer a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679518796"><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679518796"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679518796"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">varMap :: Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varMap"><span class="hs-identifier hs-var">varMap</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Identifier, Scheme)
 -&gt; Map Identifier Scheme -&gt; Map Identifier Scheme)
-&gt; Map Identifier Scheme
-&gt; [(Identifier, Scheme)]
-&gt; Map Identifier Scheme
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Identifier
 -&gt; Scheme -&gt; Map Identifier Scheme -&gt; Map Identifier Scheme)
-&gt; (Identifier, Scheme)
-&gt; Map Identifier Scheme
-&gt; Map Identifier Scheme
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">Identifier
-&gt; Scheme -&gt; Map Identifier Scheme -&gt; Map Identifier Scheme
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insert</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varMap"><span class="hs-identifier hs-var hs-var">varMap</span></a></span><span> </span><span class="annot"><span class="annottext">InferCtx
</span><a href="#local-6989586621679518796"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(Identifier, Scheme)]
</span><a href="#local-6989586621679518792"><span class="hs-identifier hs-var">vs</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-238"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-239"></span><span>  </span><span id="local-6989586621679518792"><span class="annot"><span class="annottext">vs :: [(Identifier, Scheme)]
</span><a href="#local-6989586621679518792"><span class="hs-identifier hs-var hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Binder, Scheme) -&gt; Maybe (Identifier, Scheme))
-&gt; [(Binder, Scheme)] -&gt; [(Identifier, Scheme)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">(Binder, Scheme) -&gt; Maybe (Identifier, Scheme)
forall a a b.
(Identifiable a, Identifiable a) =&gt;
(Maybe a, b) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679518791"><span class="hs-identifier hs-var">unBind</span></a></span><span> </span><span class="annot"><span class="annottext">[(Binder, Scheme)]
</span><a href="#local-6989586621679518798"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-240"></span><span>  </span><span id="local-6989586621679518791"><span class="annot"><span class="annottext">unBind :: (Maybe a, b) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679518791"><span class="hs-identifier hs-var hs-var">unBind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679518790"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679518790"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679518789"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679518789"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, b) -&gt; Maybe (a, b)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a
forall a b. (Identifiable a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#fromId"><span class="hs-identifier hs-var">fromId</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679518790"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679518789"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-241"></span><span>  </span><span class="annot"><a href="#local-6989586621679518791"><span class="hs-identifier hs-var">unBind</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe a, b)
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (a, b)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span id="local-6989586621679519066"><span class="annot"><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-type">lookupBinding</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.Identifiers.html#Identifiable"><span class="hs-identifier hs-type">Identifiable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679519066"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679519066"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="IR.Types.Inference.html#Infer"><span class="hs-identifier hs-type">Infer</span></a></span><span> </span><span class="annot"><a href="IR.Types.Unification.html#Scheme"><span class="hs-identifier hs-type">U.Scheme</span></a></span></span><span>
</span><span id="line-244"></span><span id="lookupBinding"><span class="annot"><span class="annottext">lookupBinding :: i
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
</span><a href="IR.Types.Inference.html#lookupBinding"><span class="hs-identifier hs-var hs-var">lookupBinding</span></a></span></span><span> </span><span id="local-6989586621679518788"><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679518788"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-245"></span><span>  </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) InferCtx
forall r (m :: * -&gt; *). MonadReader r m =&gt; m r
</span><span class="hs-identifier hs-var">U.ask</span></span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) InferCtx
-&gt; (InferCtx
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
-&gt; (Scheme
    -&gt; ReaderT
         InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; Maybe Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Error
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">U.throwError</span></span><span> </span><span class="annot"><span class="annottext">Error
</span><a href="#local-6989586621679518784"><span class="hs-identifier hs-var">unbound</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Scheme
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Maybe Scheme
 -&gt; ReaderT
      InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme)
-&gt; (InferCtx -&gt; Maybe Scheme)
-&gt; InferCtx
-&gt; ReaderT InferCtx (ExceptT Error (IntBindingT TypeF Pass)) Scheme
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Identifier -&gt; Map Identifier Scheme -&gt; Maybe Scheme
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">M.lookup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">i -&gt; Identifier
forall a b. (Identifiable a, Identifiable b) =&gt; a -&gt; b
</span><a href="Common.Identifiers.html#fromId"><span class="hs-identifier hs-var">fromId</span></a></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679518788"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Identifier Scheme -&gt; Maybe Scheme)
-&gt; (InferCtx -&gt; Map Identifier Scheme) -&gt; InferCtx -&gt; Maybe Scheme
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">InferCtx -&gt; Map Identifier Scheme
</span><a href="IR.Types.Inference.html#varMap"><span class="hs-identifier hs-var hs-var">varMap</span></a></span><span>
</span><span id="line-246"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-247"></span><span>  </span><span id="local-6989586621679518784"><span class="annot"><span class="annottext">unbound :: Error
</span><a href="#local-6989586621679518784"><span class="hs-identifier hs-var hs-var">unbound</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ErrorMsg -&gt; Error
</span><a href="Common.Compiler.html#TypeError"><span class="hs-identifier hs-var">Compiler.TypeError</span></a></span><span> </span><span class="annot"><span class="annottext">(ErrorMsg -&gt; Error) -&gt; ErrorMsg -&gt; Error
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ErrorMsg
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ErrorMsg) -&gt; String -&gt; ErrorMsg
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Unbound variable: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">i -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679518788"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-248"></span></pre></body></html>