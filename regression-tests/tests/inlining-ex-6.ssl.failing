/*
This file has a bunch of notes as well as a test program with examples of 
dead, oncesafe, multisafe, onceunsafe, multiunsafe, and callsite inline (no loopbreaker example though!)
This test case fails because we have only implemented pre and post inline unconditionally so far.

simplExpr :: Subst -> InScopeSet
          -> InExpr -> Context
          -> OutExpr

*/

type Size
  Big Int
  SmallEnough

getVal sz = match sz
              Big val = val
              _ = 0


main cin cout = 
  // dead d
  let d = 5

  //oncesafe q
  let q = 5
  let r = q + 1

  //multisafe t
  let t  = 57         
  let u = SmallEnough
  let v = match u 
               SmallEnough = t 
               Big _ = t + 1

  //onceunsafe w
  let w = 5
  let lambda0 = (fun x { x + 1 + w })

  //multiunsafe e
  let e = 45
  let lambda1 = (fun y { y + 1 + e })
  let f = e + 48

  // 6.1 example from paper
  let a = Big 5000
  let b = a
  let c = getVal b + getVal b + getVal b
  
  ()

/*
add a b = a + b

type Stuff
  Stuff Int Int Int

// if x is in rhs of y then we can see x in r otherwise we can't
main cin cout =
  let x = 2
      y = 3
      r = x + y
  after 1, cout <- r + 48    // Should print 5
  wait cout
  after 1, cout <- 10
  wait cout


/*
DOESN'T WORK
y = 3
tldr: x is once safe so sub is x suspex 2
UnexpectedError (ErrorMsg "\"[\\\"START topdef VarId add has OccInfo: \\\\\\\"fromList [(VarId a,OnceSafe),(VarId add,Dead),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Dead),(VarId main,Dead)]\\\\\\\" END\\\",\\\"START topdef VarId main has OccInfo: \\\\\\\"fromList [(VarId a,OnceSafe),(VarId add,OnceSafe),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Never),(VarId main,Dead),(VarId r,OnceSafe),(VarId x,OnceSafe),(VarId y,OnceSafe)]\\\\\\\" END\\\"]\"")
substitution: fromList [(VarId x,SuspEx (Lit (LitIntegral 2) (TCon Int32 [])) (fromList []))]

WORKS:
y = 3 + x
tldr: x is never so sub is empty
UnexpectedError (ErrorMsg "\"[\\\"START topdef VarId add has OccInfo: \\\\\\\"fromList [(VarId a,OnceSafe),(VarId add,Dead),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Dead),(VarId main,Dead)]\\\\\\\" END\\\",\\\"START topdef VarId main has OccInfo: \\\\\\\"fromList [(VarId a,OnceSafe),(VarId add,OnceSafe),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Never),(VarId main,Dead),(VarId r,OnceSafe),(VarId x,Never),(VarId y,OnceSafe)]\\\\\\\" END\\\"]\"")
substitution: fromList []
*/

/*
add a b = a + b

// changes: 
// 1) x has to be in yet
// 2) no r
// need to change the way that simplExpr for let works cus our interpretation is wrong
// let is nested singleton lolololololol
main cin cout =
  let x = 2
      y = x + 1
  putd cout x
  //body of top let: 

  /*

  sslc: 
  old binders: [(Just (VarId x),Lit (LitIntegral 2) (TCon Int32 []))]
  substitution: fromList [(VarId x,DoneEx (Lit (LitIntegral 2) (TCon Int32 [])))]
  body: Let [
    (Just (VarId y),Prim (PrimOp PrimAdd) [Var (VarId x) (TCon Int32 []),Lit (LitIntegral 1) (TCon Int32 [])] (TCon Int32 []))] (Var (VarId x) (TCon Int32 [])) (TCon Int32 [])

  subs' = {x, DoneEx 2 {}}
  body =  Let [y, (+) []]
  body' = simplExpr subs' ins body cont

  Let [
    Binder: (Just (VarId y),
    rhs: Prim (PrimOp PrimAdd) [Var (VarId x) (TCon Int32 []),Lit (LitIntegral 1) (TCon Int32 [])] (TCon Int32 []))
  ] 
  Body: (Var (VarId x) (TCon Int32 [])) (TCon Int32 [])
  */
//      r = add x y
//  after 1, cout <- x + 48    // Should print 5
//  wait cout
//  after 1, cout <- 10
//  wait cout
/*

/*
(Nothing, {x, (DoneEx 2 {})}) // from looking at x
(Nothing, {})                 // from looking at y

after fold: {x, (DoneEx 2 {})}

simplExpr {} ins 2 cont -> returns 2
*/
*/




###### Testing add1
stack exec sslc -- tests/add1.ssl > out/add1.c
UnexpectedError (ErrorMsg "\"[\\\"START topdef VarId 
main has OccInfo: \\\\\\\"fromList [(VarId a,Dead),(VarId add,Dead),(VarId b,Dead),(VarId cin,Dead),(VarId cout,Never),(VarId main,Dead),(VarId x,Never),(VarId y,Dead)]\\\\\\\" END\\\",\\\"START topdef VarId add has OccInfo: \\\\\\\"fromList [(VarId a,OnceSafe),(VarId add,Dead),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Never),(VarId main,Dead),(VarId x,Never),(VarId y,Dead)]\\\\\\\" END\\\"]\"")
###### FAILED


*/

/*
Occurence info:
UnexpectedError (ErrorMsg "\"[\\\"START topdef VarId 
add has OccInfo: \\\\\\\"fromList [
  (VarId a,OnceSafe),
  (VarId add,Dead),
  (VarId b,OnceSafe),
  (VarId cin,Dead),
  (VarId cout,Dead),
  (VarId main,Dead)]\\\\\\\" END\\\",\\\"START topdef VarId 
  
main has OccInfo: \\\\\\\"fromList [
  (VarId a,OnceSafe),
  (VarId add,OnceSafe),
  (VarId b,OnceSafe),
  (VarId cin,Dead),
  (VarId cout,Never),
  (VarId main,Dead),
  (VarId r,OnceSafe),
  (VarId x,OnceSafe),
  (VarId y,OnceSafe)]\\\\\\\" END\\\"]\"")

original:
main cin cout =
  let x = 2
      y = x + 3
      r = add x y
  after 1, cout <- r + 48    // Should print 5
  wait cout
  after 1, cout <- 10
  wait cout

level 1: 
Nothing, {x (SuspEx 2         {})}
Nothing, {y (SuspEx 3         {})}
Nothing, {r (SuspEx (add x y) {})}

Soure of Problem is Either 
1) the simplifier encounters y, looks it up in the substitution, does not find it, and does NOT throw an error
2) we never encounter y, so we never inline it

{(x, (SuspEx 2{})),
 (y, (SuspEx 3{})),
 (r, (SuspEx (add x y) {})
}
*/

*/

