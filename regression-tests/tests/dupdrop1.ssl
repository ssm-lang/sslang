// Example designed to test the InsertRefCounting module

type MyType
  Foo Int
  Bar

add a b =
  a + b      // Becomes (+) (dup a) (dup b)

main cin cout =
  let x = 5       // remains "5"
      y = 3
      z = Foo 42  // becomes a call of the "__Foo" function
      w = z       // becomes "dup z"
  let c = add x y           // c = 5 + 3 = 8
  after 1, cout <- c + 48   // "8"
  wait cout
  after 1, cout <- 10
  wait cout

  let a = Foo 42
      _ = a
  17

  match z
    Foo x_ = x_ + 1
    Bar = 42

  let d = match add x y
           10 = 5
           _ = 3
  after 1, cout <- d + 48   // add 5 3 = 7, so d = "3" //after 1, cout <- let __pat_anon1 = add x y
  wait cout
  after 1, cout <- 10
  wait cout

  /*
  I think the problem is we either need to inline x everywhere, or inline x nowhere

  lifted:
  let d = let __pat_anon1 = add x y
          match __pat_anon1
            10 = 5
            _ = 3
  after 1, cout <- d + 48
  wait cout
  after 1, cout <- 10
  wait cout

  inlined:
  after 1, cout <- let __pat_anon1 = add x y
  match __pat_anon1
    10 = 5
    _ = 3 + 48
  wait cout
  after 1, cout <- 10
  wait cout

  UnexpectedError (ErrorMsg "\"
  [\\\"START   topdef VarId __Foo has OccInfo: \\\\\\\"fromList 
  [(VarId __Foo,ConstructorFunc),
  (VarId __arg0,Never),
  (VarId __pat_anon0,Never),
  (VarId __pat_anon1,Never),
  (VarId a,ConstructorFunc),
  (VarId add,ConstructorFunc),
  (VarId b,ConstructorFunc),
  
  (VarId c,OnceSafe),(VarId cin,ConstructorFunc),(VarId cout,ConstructorFunc),(VarId d,OnceSafe),(VarId main,ConstructorFunc),(VarId w,Dead),(VarId x,Never),(VarId y,Never),(VarId z,Never)]\\\\\\\" END\\\",
  
  \\\"START    topdef VarId add has OccInfo: \\\\\\\"fromList [(VarId __Foo,ConstructorFunc),(VarId __arg0,Never),(VarId __pat_anon0,Never),(VarId __pat_anon1,Never),(VarId a,Never),(VarId add,ConstructorFunc),(VarId b,Never),(VarId c,OnceSafe),(VarId cin,ConstructorFunc),(VarId cout,ConstructorFunc),(VarId d,OnceSafe),(VarId main,ConstructorFunc),(VarId w,Dead),(VarId x,Never),(VarId y,Never),(VarId z,Never)]\\\\\\\" END\\\",\\\
  
  
  "START topdef VarId main has OccInfo: \\\\\\\"fromList 
  [(VarId __Foo,Never),
  (VarId __arg0,Never),
  (VarId __pat_anon0,Never),
  (VarId __pat_anon1,Never),
  (VarId a,Never),
  (VarId add,Never),
  (VarId b,Never),
  (VarId c,Never),
  (VarId cin,ConstructorFunc),
  (VarId cout,Never),
  (VarId d,Never),
  (VarId main,ConstructorFunc),(VarId w,ConstructorFunc),(VarId x,Never),(VarId y,Never),(VarId z,Never)]\\\\\\\" END\\\"]\"")
  
  ----------------------------- THE NEW THING: ----------------------------------------------
  -- Using Simplify1, x and y are getting inlined and shouldnt be. d should be inlined and is. 
  -- Using Simplify2, x and y are not getting inlined (which is good), but d is marked oncesafe and isn't inlined (which is not correct).
  -- Var x and Var y have occInfo NEVER so we should not delete it lol but we do anyways for some reason rn ¯\_(ツ)_/¯
  
  UnexpectedError (ErrorMsg "\"[\\\
  "START topdef VarId __Foo has OccInfo: \\\\\\\"fromList [(VarId __Foo,Dead),(VarId __arg0,OnceSafe),(VarId a,Dead),(VarId add,Dead),(VarId b,Dead),(VarId cin,Dead),(VarId cout,Dead),(VarId main,Dead)]\\\\\\\" END\\\",\\\
  "START topdef VarId add has OccInfo: \\\\\\\"fromList [(VarId __Foo,Dead),(VarId __arg0,OnceSafe),(VarId a,OnceSafe),(VarId add,Dead),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Dead),(VarId main,Dead)]\\\\\\\" END\\\",\\\
  "START topdef VarId main has OccInfo: \\\\\\\"fromList [(VarId __Foo,Never),(VarId __arg0,OnceSafe),(VarId __pat_anon0,Never),(VarId __pat_anon1,Never),(VarId a,Never),(VarId add,Never),(VarId b,OnceSafe),(VarId c,OnceSafe),(VarId cin,Dead),(VarId cout,Never),(VarId d,OnceSafe),(VarId main,Dead),(VarId w,Dead),(VarId x,Never),(VarId y,Never),(VarId z,Never)]\\\\\\\" END\\\"]\"")
  
  Simplify2:
  ➜  ericfeng regression-tests git:(add-simple-inliner ↑1 U:5 ?:6 ✗) stack exec sslc -- --dump-ir-inlined tests/dupdrop1.ssl 
type MyType 
  Foo Int32
  Bar 


__Foo (__arg0 : Int32) -> MyType = 
  Foo __arg0

add (a : Int32) (b : Int32) -> Int32 = 
  a + b

main (cin : a1) (cout : (& Int32)) -> () = 
  let z = __Foo 42
  let c = add x y
  after 1, cout <- c + 48
  wait cout
  after 1, cout <- 10
  wait cout
  let a = __Foo 42
  a
  17
  match z
    Bar  = 42
    Foo __pat_anon0 = __pat_anon0 + 1
  let d = let __pat_anon1 = add x y
          match __pat_anon1
            10 = 5
            _ = 3
  after 1, cout <- d + 48
  wait cout
  after 1, cout <- 10
  wait cout
  */