add a b = a + b

// changes: 
// 1) x has to be in yet
// 2) no r
main cin cout =
  let x = 2
      y = x + 1
  x
//      r = add x y
//  after 1, cout <- x + 48    // Should print 5
//  wait cout
//  after 1, cout <- 10
//  wait cout
/*

/*
(Nothing, {x, (DoneEx 2 {})}) // from looking at x
(Nothing, {})                 // from looking at y

after fold: {x, (DoneEx 2 {})}

simplExpr {} ins 2 cont -> returns 2
*/




###### Testing add1
stack exec sslc -- tests/add1.ssl > out/add1.c
UnexpectedError (ErrorMsg "\"[\\\"START topdef VarId 
main has OccInfo: \\\\\\\"fromList [(VarId a,Dead),(VarId add,Dead),(VarId b,Dead),(VarId cin,Dead),(VarId cout,Never),(VarId main,Dead),(VarId x,Never),(VarId y,Dead)]\\\\\\\" END\\\",\\\"START topdef VarId add has OccInfo: \\\\\\\"fromList [(VarId a,OnceSafe),(VarId add,Dead),(VarId b,OnceSafe),(VarId cin,Dead),(VarId cout,Never),(VarId main,Dead),(VarId x,Never),(VarId y,Dead)]\\\\\\\" END\\\"]\"")
###### FAILED


*/

/*
Occurence info:
UnexpectedError (ErrorMsg "\"[\\\"START topdef VarId 
add has OccInfo: \\\\\\\"fromList [
  (VarId a,OnceSafe),
  (VarId add,Dead),
  (VarId b,OnceSafe),
  (VarId cin,Dead),
  (VarId cout,Dead),
  (VarId main,Dead)]\\\\\\\" END\\\",\\\"START topdef VarId 
  
main has OccInfo: \\\\\\\"fromList [
  (VarId a,OnceSafe),
  (VarId add,OnceSafe),
  (VarId b,OnceSafe),
  (VarId cin,Dead),
  (VarId cout,Never),
  (VarId main,Dead),
  (VarId r,OnceSafe),
  (VarId x,OnceSafe),
  (VarId y,OnceSafe)]\\\\\\\" END\\\"]\"")

original:
main cin cout =
  let x = 2
      y = x + 3
      r = add x y
  after 1, cout <- r + 48    // Should print 5
  wait cout
  after 1, cout <- 10
  wait cout

level 1: 
Nothing, {x (SuspEx 2         {})}
Nothing, {y (SuspEx 3         {})}
Nothing, {r (SuspEx (add x y) {})}

Soure of Problem is Either 
1) the simplifier encounters y, looks it up in the substitution, does not find it, and does NOT throw an error
2) we never encounter y, so we never inline it

{(x, (SuspEx 2{})),
 (y, (SuspEx 3{})),
 (r, (SuspEx (add x y) {})
}
*/