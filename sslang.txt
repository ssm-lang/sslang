-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/sedwards-lab/sslang#README</a>
@package sslang
@version 0.1.0.0


-- | Module for the <a>Default</a> type class.
module Common.Default

-- | Types with default values.
class Default a
def :: Default a => a


-- | Helpers for pretty-printing sslang, including common ASCII tokens.
module Common.Pretty

-- | <tt>typeAnn t d</tt> annotates document <tt>d</tt> with type
--   annotation <tt>t</tt>.
--   
--   Only used by spaghetti so constrained by Dumpy instead of Pretty for
--   now.
typeAnn :: Dumpy t => t -> Doc ann -> Doc ann

-- | <pre>
--   =&gt;
--   </pre>
drarrow :: Doc ann

-- | <pre>
--   &lt;-
--   </pre>
larrow :: Doc ann

-- | <pre>
--   -&gt;
--   </pre>
rarrow :: Doc ann

-- | <pre>
--   ||
--   </pre>
dbar :: Doc ann

-- | <pre>
--   |
--   </pre>
bar :: Doc ann

-- | <pre>
--   &amp;
--   </pre>
amp :: Doc ann

-- | Constructs a separator-delimited block <a>Doc</a> out of a list of
--   <a>Doc</a>s.
block :: Doc ann -> [Doc ann] -> Doc ann

-- | Number of spaces to indent
indentNo :: Int

-- | Format with a document of infinite width, preventing wraparound.
spaghetti :: Dumpy t => t -> String

-- | Lengthy Typeclass: print an ugly but parseable representation of the
--   AST
--   
--   <ul>
--   <li>Translates from IR to Doc representation in one-to-one
--   fashion</li>
--   <li>No simplifications</li>
--   <li>No whitespace formatting</li>
--   <li>Type annotates everything</li>
--   </ul>
class Dumpy a
dumpy :: Dumpy a => a -> Doc ann


-- | The types of identifiers used across the compiler.
--   
--   The types <a>VarId</a>, <a>TVarId</a>, <a>DConId</a>, and
--   <a>TConId</a> are used in the IR for data variables, type variables,
--   data constructors, and type constructors, which each inhabit a
--   separate namespace. The underlying <a>Identifier</a> type is used in
--   the AST, before these different kinds of identifiers are
--   differentiated by the lowering phase.
--   
--   These are defined as newtypes (rather than as type aliases) that
--   ultimately abstract over the underlying <a>String</a> Identifier. We
--   do this for a few reasons:
--   
--   <ul>
--   <li>The particular newtype carries semantic meaning in the IR, e.g.,
--   <a>VarId</a> is an identifier for data variables and nothing else.
--   This prevents semantically distinct items from being used in place of
--   one another (without explicit coercion). For example, this will
--   prevent accidentally using a type variable identifier as a data
--   constructor.</li>
--   <li>In the future, this may be extended to carry other (non-semantic)
--   metadata, such as source code location.</li>
--   <li>It allows us to freely attach typeclass instances to this type
--   without FlexibleInstances (since <a>String</a> is a type synonym for
--   <tt>[Char]</tt>).</li>
--   </ul>
--   
--   Users should never need to specifically use the data constructor for
--   each newtype, e.g., <tt>VarId (Identifier "foo")</tt>. Instead, each
--   identifier belongs to the <a>IsString</a> typeclass, that can be
--   written as <tt>fromString "foo"</tt>, so that the appropriate type can
--   be inferred from the context where the identifier is used.
--   Furthermore, the <a>fromString</a> call can be automatically inserted
--   by the OverloadedStrings GHC extension, meaning we can just write
--   <tt>"foo"</tt>.
--   
--   All identifier types are instances of the <a>Identifiable</a>
--   typeclass, which allows us to write generic functions that operate
--   over any kind of identifier. One can explicitly convert from an
--   identifier to another using the handy <a>fromId</a> helper; which
--   <i>specific</i> type of identifier may be inferred from the outer
--   context, or explicitly annotated (e.g., <tt>fromId i :: VarId</tt> to
--   construct a <a>VarId</a> out of identifier <tt>i</tt>).
module Common.Identifiers

-- | A type that may be used as a Sslang identifier.
class (IsString i, Ord i) => Identifiable i
ident :: Identifiable i => i -> String

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | Explicitly convert between two types of identifiers.
fromId :: (Identifiable a, Identifiable b) => a -> b

-- | Identifier for type constructors, e.g., <tt>Option</tt>.
newtype TConId
TConId :: Identifier -> TConId

-- | ToIdentifier for type variable, e.g., <tt>a</tt>.
newtype TVarId
TVarId :: Identifier -> TVarId

-- | Identifier for data constructors, e.g., <tt>None</tt>.
newtype DConId
DConId :: Identifier -> DConId

-- | Identifier for data variables, e.g., <tt>x</tt>.
newtype VarId
VarId :: Identifier -> VarId

-- | de Bruijn index for type variables, e.g., <tt>'0</tt>
newtype TVarIdx
TVarIdx :: Int -> TVarIdx

-- | Identifier for C symbols, e.g., <tt>printf</tt>.
newtype CSym
CSym :: Identifier -> CSym

-- | A name to be bound; <a>Nothing</a> represents a wildcard, e.g.,
--   <tt>let _ = ...</tt>.
type Binder = Maybe VarId

-- | A generic Sslang identifier.
--   
--   Used as the type for identifiers in the AST.
--   
--   Also used as the base type for other identifiers (e.g., <a>TConId</a>,
--   <a>VarId</a>), which derive their typeclass instances from this.
newtype Identifier
Identifier :: String -> Identifier

-- | Whether an identifier refers to a type or data constructor.
isCons :: Identifiable a => a -> Bool

-- | Whether an identifier refers to a type or data variable.
isVar :: Identifiable a => a -> Bool

-- | Mangle all identifiers in some data structure.
--   
--   This function is useful for preserving the general syntactic structure
--   of a datum without inspecting the <i>specific</i> identifiers used
--   within. This is useful for comparing ASTs modulo alpha renaming.
--   
--   The <tt>Proxy i</tt> parameter is used to specify exactly which kind
--   of identifier to mangle. For instance, to mangle all <a>VarId</a>
--   nodes:
--   
--   <pre>
--   mangleVarId :: Data a =&gt; a -&gt; a
--   mangleVarId = mangle (Proxy :: VarId)
--   </pre>
mangle :: (Identifiable i, Data i, Data a) => Proxy i -> a -> a

-- | Mangle all type and data variable identifiers.
mangleVars :: Data a => a -> a
instance Data.Data.Data Common.Identifiers.Identifier
instance GHC.Classes.Ord Common.Identifiers.Identifier
instance GHC.Classes.Eq Common.Identifiers.Identifier
instance Prettyprinter.Internal.Pretty Common.Identifiers.TConId
instance GHC.Base.Monoid Common.Identifiers.TConId
instance GHC.Base.Semigroup Common.Identifiers.TConId
instance Common.Identifiers.Identifiable Common.Identifiers.TConId
instance Data.String.IsString Common.Identifiers.TConId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.TConId
instance Data.Data.Data Common.Identifiers.TConId
instance GHC.Classes.Ord Common.Identifiers.TConId
instance GHC.Classes.Eq Common.Identifiers.TConId
instance Prettyprinter.Internal.Pretty Common.Identifiers.TVarId
instance GHC.Base.Monoid Common.Identifiers.TVarId
instance GHC.Base.Semigroup Common.Identifiers.TVarId
instance Common.Identifiers.Identifiable Common.Identifiers.TVarId
instance Data.String.IsString Common.Identifiers.TVarId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.TVarId
instance Data.Data.Data Common.Identifiers.TVarId
instance GHC.Classes.Ord Common.Identifiers.TVarId
instance GHC.Classes.Eq Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty Common.Identifiers.DConId
instance GHC.Base.Monoid Common.Identifiers.DConId
instance GHC.Base.Semigroup Common.Identifiers.DConId
instance Common.Identifiers.Identifiable Common.Identifiers.DConId
instance Data.String.IsString Common.Identifiers.DConId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.DConId
instance Data.Data.Data Common.Identifiers.DConId
instance GHC.Classes.Ord Common.Identifiers.DConId
instance GHC.Show.Show Common.Identifiers.DConId
instance GHC.Classes.Eq Common.Identifiers.DConId
instance Prettyprinter.Internal.Pretty Common.Identifiers.VarId
instance GHC.Base.Monoid Common.Identifiers.VarId
instance GHC.Base.Semigroup Common.Identifiers.VarId
instance Common.Identifiers.Identifiable Common.Identifiers.VarId
instance Data.String.IsString Common.Identifiers.VarId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.VarId
instance Data.Data.Data Common.Identifiers.VarId
instance GHC.Classes.Ord Common.Identifiers.VarId
instance GHC.Show.Show Common.Identifiers.VarId
instance GHC.Classes.Eq Common.Identifiers.VarId
instance Prettyprinter.Internal.Pretty Common.Identifiers.CSym
instance GHC.Base.Monoid Common.Identifiers.CSym
instance GHC.Base.Semigroup Common.Identifiers.CSym
instance Common.Identifiers.Identifiable Common.Identifiers.CSym
instance Data.String.IsString Common.Identifiers.CSym
instance Language.C.Quote.Base.ToIdent Common.Identifiers.CSym
instance Data.Data.Data Common.Identifiers.CSym
instance GHC.Classes.Ord Common.Identifiers.CSym
instance GHC.Show.Show Common.Identifiers.CSym
instance GHC.Classes.Eq Common.Identifiers.CSym
instance Data.Data.Data Common.Identifiers.TVarIdx
instance GHC.Classes.Ord Common.Identifiers.TVarIdx
instance GHC.Classes.Eq Common.Identifiers.TVarIdx
instance GHC.Show.Show Common.Identifiers.TVarIdx
instance Prettyprinter.Internal.Pretty Common.Identifiers.TVarIdx
instance GHC.Show.Show Common.Identifiers.TVarId
instance GHC.Show.Show Common.Identifiers.TConId
instance Data.String.IsString Common.Identifiers.Identifier
instance Common.Identifiers.Identifiable Common.Identifiers.Identifier
instance GHC.Show.Show Common.Identifiers.Identifier
instance Language.C.Quote.Base.ToIdent Common.Identifiers.Identifier
instance GHC.Base.Semigroup Common.Identifiers.Identifier
instance GHC.Base.Monoid Common.Identifiers.Identifier
instance Prettyprinter.Internal.Pretty Common.Identifiers.Identifier


-- | Bindings to the ssm-runtime library.
module Codegen.LibSSM

-- | Identifiers in C.
newtype CIdent
CIdent :: Identifier -> CIdent

-- | Construct a type name from a C identifier.
ctype :: CIdent -> Type

-- | Construct an expression from a C identifier.
cexpr :: CIdent -> Exp

-- | Construct an expression of the size of a C type.
csizeof :: Type -> Exp

-- | Construct an integer literal in C.
cint :: Int -> Exp
ccall :: Exp -> [Exp] -> Exp
amp :: Exp -> Exp
star :: Exp -> Exp

-- | Natively supported sizes in C.
data CSize
Size8 :: CSize
Size16 :: CSize
Size32 :: CSize
Size64 :: CSize

-- | Convert a <a>CSize</a> into an integer.
size_to_int :: CSize -> Int

-- | Convert a <a>CSize</a> into some string identifier of the size.
size_to_string :: IsString s => CSize -> s

-- | <tt>enum ssm_error</tt>, an enumeration of possible runtime errors.
data SSMError

-- | Reserved for unforeseen, non-user-facing errors.
INTERNAL_ERROR :: SSMError

-- | Tried to insert into full ready queue.
EXHAUSTED_ACT_QUEUE :: SSMError

-- | Tried to insert into full event queue.
EXHAUSTED_EVENT_QUEUE :: SSMError

-- | Could not allocate more memory.
EXHAUSTED_MEMORY :: SSMError

-- | Tried to exceed available recursion depth.
EXHAUSTED_PRIORITY :: SSMError

-- | Not yet ready to perform the requested action.
NOT_READY :: SSMError

-- | Specified invalid time.
INVALID_TIME :: SSMError

-- | Invalid memory layout.
INVALID_MEMORY :: SSMError

-- | <tt>SSM_THROW</tt>, throw a runtime error.
throw :: SSMError -> Exp

-- | <tt>ssm_word_t</tt>, the largest supported machine word size.
word_t :: Type

-- | <tt>ssm_value_t</tt>, runtime representation for sslang values.
value_t :: Type

-- | Name of the <tt>packed_val</tt> field in a <a>value_t</a>.
packed_val :: CIdent

-- | Name of the <tt>heap_ptr</tt> field in a <a>value_t</a>.
heap_ptr :: CIdent

-- | <tt>ssm_marshal</tt>, construct a <a>value_t</a> out of a 31-bit
--   integral value.
marshal :: Exp -> Exp

-- | <tt>ssm_unmarshal</tt>, extract 31-bit integral value out of a
--   <a>value_t</a>.
unmarshal :: Exp -> Exp

-- | <tt>ssm_on_heap</tt>, whether a <a>value_t</a> points to something on
--   the heap.
on_heap :: Exp -> Exp

-- | <tt>ssm_dup</tt>, increment the reference count of a value.
dup :: Exp -> Exp

-- | <tt>ssm_dups</tt>, increment the reference count on a vector of
--   values.
dups :: Exp -> Exp -> Exp

-- | <tt>ssm_drop</tt>, drop the reference count of a value and free if
--   necessary.
drop :: Exp -> Exp

-- | <tt>ssm_time_t</tt>, 64-bit time type.
time_t :: Type

-- | <tt>struct ssm_time</tt>, the heap-representation of a <a>time_t</a>.
time_obj_t :: Type

-- | <tt>SSM_NEVER</tt>, a <a>time_t</a> that is never reached.
never :: Exp

-- | <tt>ssm_now</tt>, the current time.
now :: Exp

-- | <tt>ssm_new_time</tt>, allocate a <a>time_obj_t</a> on the heap.
new_time :: Exp -> Exp

-- | <tt>ssm_time_read</tt>, read the time in a <a>time_obj_t</a>.
read_time :: Exp -> Exp

-- | <tt>ssm_priority_t</tt>, thread priority.
priority_t :: Type

-- | <tt>ssm_depth_t</tt>, thread depth.
depth_t :: Type

-- | <tt>SSM_ROOT_PRIORITY</tt>, the depth of the root process.
root_priority :: Exp

-- | <tt>SSM_ROOT_DEPTH</tt>, the depth of the root process.
root_depth :: Exp

-- | <tt>ssm_act_t</tt>, the generic activation record type.
act_t :: Type

-- | Name of the program counter field in an <a>act_t</a>.
act_pc :: CIdent

-- | Name of the caller field in an <a>act_t</a>.
act_caller :: CIdent

-- | Name of the depth field in an <a>act_t</a>.
act_depth :: CIdent

-- | Name of the priority field in an <a>act_t</a>.
act_priority :: CIdent

-- | <tt>ssm_trigger_t</tt>, nodes in the linked list of triggers.
trigger_t :: Type

-- | <tt>ssm_enter</tt>, allocate and initialize activation record.
enter :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_leave</tt>, deallocate an activation record before leaving.
leave :: Exp -> Exp -> Exp

-- | <tt>ssm_has_children</tt>, returns non-zero if <tt>act</tt> has at
--   least one child.
has_children :: Exp -> Exp

-- | <tt>ssm_activate</tt>, schedule an activation record on the ready
--   queue.
activate :: Exp -> Exp

-- | <tt>ssm_top_parent</tt>, Name of top level parent activation record
top_parent :: Exp

-- | <tt>ssm_sv_t</tt>, polymorphic scheduled variables.
sv_t :: Type

-- | <tt>ssm_new_sv</tt>, allocate a new <a>sv_t</a> on the heap.
new_sv :: Exp -> Exp

-- | <tt>ssm_to_sv</tt>, retrieve the <a>sv_t</a> pointer pointed to by a
--   <a>value_t</a>.
to_sv :: Exp -> Exp

-- | <tt>ssm_deref</tt>, read the value of an <a>sv_t</a> pointed to by a
--   <a>value_t</a>.
deref :: Exp -> Exp

-- | <tt>ssm_assign</tt>, assign to a scheduled variable.
assign :: Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_later</tt>, schedule a delayed assignment to a scheduled
--   variable.
later :: Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_sensitize</tt>, sensitize a trigger to a variable.
sensitize :: Exp -> Exp -> Exp

-- | <tt>ssm_sensitize</tt>, sensitize a trigger to a variable.
desensitize :: Exp -> Exp

-- | <tt>ssm_new_adt</tt>, allocate a new ADT object on the heap.
new_adt :: Int -> DConId -> Exp

-- | <tt>ssm_adt_field</tt>, access the <tt>i</tt>th field of an ADT
--   object. Assignable.
adt_field :: Exp -> Int -> Exp

-- | <tt>ssm_tag</tt>, extract the tag of an ADT value.
adt_tag :: Exp -> Exp

-- | <tt>ssm_closure1_t</tt>, the (template) type of a closure with a
--   single argument.
closure1_t :: Type

-- | Inintializer for a "static" closure that contains no arguments.
--   
--   FIXME: An ugly hack that shouldn't exist because John didn't have the
--   foresight to provide an interface to define static closures.
static_closure :: Exp -> Int -> Initializer

-- | Promote a static object to an <tt>ssm_value_t</tt> (warning: hacky!).
static_value :: CIdent -> Exp

-- | <tt>ssm_new_closure</tt>, allocate a new closure object on the heap.
new_closure :: CIdent -> Int -> Exp

-- | <tt>ssm_closure_push</tt>, add a new argument to a closure.
closure_push :: Exp -> Exp -> Exp

-- | <tt>ssm_closure_pop</tt>, remove an argument from a closure.
closure_pop :: Exp -> Exp

-- | <tt>ssm_closure_apply</tt>, apply a closure to an argument.
closure_apply :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_closure_apply</tt>, apply a closure to an argument, consuming
--   the closure.
closure_apply_final :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_closure_free</tt>, free a closure (without performing
--   reference counting).
closure_free :: Exp -> Exp

-- | Name of the pseudonymous macro from the Linux kernel.
container_of :: CIdent

-- | Name of program initialization hook, called to set up program with
--   runtime.
program_init :: CIdent

-- | Name of program destruction hook, called before gracefully exiting
--   program.
program_exit :: CIdent

-- | Name of stdout handler enter function, used to bind stdout for POSIX
--   platforms. NOTE: this is a hack
stdout_handler_enter :: CIdent

-- | Name of stdin handler spawner, used to bind stdin for POSIX platforms.
--   NOTE: this is a hack
stdin_handler_spawn :: CIdent

-- | Name of stdin handler killer, used to destroy handler thread on POSIX.
--   NOTE: this is a hack
stdin_handler_kill :: CIdent

-- | Obtain the name of a process activation record struct.
act_typename :: VarId -> CIdent

-- | Identifier for act member in act struct.
act_member :: CIdent

-- | Obtain the type of a process activation record.
act_ :: VarId -> Type

-- | Obtain the process-specific activation record from a generic one.
to_act :: Exp -> VarId -> Exp

-- | Obtain the name for the enter function of a routine.
enter_ :: VarId -> CIdent

-- | Obtain the name for the static closure of a routine.
closure_ :: VarId -> CIdent

-- | Obtain the name of the step function of a routine.
step_ :: VarId -> CIdent

-- | Obtain the name of each trigger for a routine.
trig_ :: Int -> CIdent

-- | Obtain the name of a temporary variable.
tmp_ :: Int -> CIdent

-- | Obtain the name of a label.
label_ :: Int -> CIdent

-- | Obtain the name of an argument variable.
arg_ :: Int -> CIdent

-- | Obtain the name of an argument variable.
argv :: CIdent

-- | Name of return argument.
ret_val :: CIdent

-- | Identifier for generic (inner) struct act.
actg :: CIdent

-- | Identifier for specialized (outer) struct act.
acts :: CIdent

-- | Access activation record member.
acts_ :: CIdent -> Exp

-- | Name of the caller argument of an enter call.
enter_caller :: CIdent

-- | Name of the priority argument of an enter call.
enter_priority :: CIdent

-- | Name of the depth argument of an enter call.
enter_depth :: CIdent

-- | Label to jump to terminate execution.
leave_label :: CIdent

-- | Cast to a signed integer of a particular size.
cast_to_signed :: CSize -> Exp -> Exp

-- | Cast to an unsigned integer of a particular size.
cast_to_unsigned :: CSize -> Exp -> Exp

-- | Cast to an integer of a particular size and signedness.
cast_to_int :: Bool -> CSize -> Exp -> Exp

-- | Shift left by the specified amount.
shl :: Exp -> Exp -> Exp

-- | Shift right by the specified amount.
shr :: Exp -> Exp -> Exp
instance GHC.Base.Monoid Codegen.LibSSM.CIdent
instance GHC.Base.Semigroup Codegen.LibSSM.CIdent
instance Language.C.Quote.Base.ToIdent Codegen.LibSSM.CIdent
instance Common.Identifiers.Identifiable Codegen.LibSSM.CIdent
instance Data.String.IsString Codegen.LibSSM.CIdent
instance GHC.Classes.Ord Codegen.LibSSM.CIdent
instance GHC.Classes.Eq Codegen.LibSSM.CIdent
instance GHC.Classes.Ord Codegen.LibSSM.CSize
instance GHC.Classes.Eq Codegen.LibSSM.CSize
instance GHC.Show.Show Codegen.LibSSM.SSMError
instance Language.C.Quote.Base.ToIdent Codegen.LibSSM.SSMError


-- | Data types and helpers used to compose the compiler pipeline.
module Common.Compiler

-- | Type for error messages.
data ErrorMsg

-- | Types of compiler errors that can be thrown during compilation.
data Error

-- | Halt compiler to dump output (not an error)
Dump :: String -> Error

-- | Internal error; should be unreachable
UnexpectedError :: ErrorMsg -> Error

-- | Round peg in square hole
TypeError :: ErrorMsg -> Error

-- | Identifier is out of scope
ScopeError :: ErrorMsg -> Error

-- | Invalid naming convention at binding
NameError :: ErrorMsg -> Error

-- | Malformed pattern
PatternError :: ErrorMsg -> Error

-- | Error encountered by scanner
LexError :: ErrorMsg -> Error

-- | Error encountered by parser
ParseError :: ErrorMsg -> Error

-- | Types of compiler warnings that can be logged during compilation.
data Warning

-- | Warning about type
TypeWarning :: ErrorMsg -> Warning

-- | Warning related to identifier names
NameWarning :: ErrorMsg -> Warning

-- | Warning related to patterns
PatternWarning :: ErrorMsg -> Warning

-- | The compiler pipeline monad; supports throwing errors, logging, etc.
newtype Pass a
Pass :: PassMonad a -> Pass a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Invoke a compiler <a>Pass</a>.
runPass :: Pass a -> Either Error (a, [Warning])

-- | Dump pretty-printable output from within a compiler pass.
dump :: Pretty a => a -> Pass x

-- | Report unexpected compiler error and halt pipeline.
unexpected :: MonadError Error m => String -> m a

-- | Log a compiler warning.
warn :: MonadWriter [Warning] m => Warning -> m ()

-- | Execute compiler pass in I/O monad, exiting upon exception.
passIO :: Pass a -> IO (a, [Warning])

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | Throw a type error with some String error message.
typeError :: MonadError Error m => String -> m a
instance GHC.Base.Monoid Common.Compiler.ErrorMsg
instance GHC.Base.Semigroup Common.Compiler.ErrorMsg
instance GHC.Show.Show Common.Compiler.ErrorMsg
instance GHC.Classes.Eq Common.Compiler.Error
instance GHC.Show.Show Common.Compiler.Error
instance GHC.Classes.Eq Common.Compiler.Warning
instance GHC.Show.Show Common.Compiler.Warning
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Common.Compiler.Pass
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Common.Compiler.Pass
instance GHC.Base.Monad Common.Compiler.Pass
instance GHC.Base.Applicative Common.Compiler.Pass
instance GHC.Base.Functor Common.Compiler.Pass
instance Control.Monad.Fail.MonadFail Common.Compiler.Pass
instance Data.String.IsString Common.Compiler.ErrorMsg
instance GHC.Classes.Eq Common.Compiler.ErrorMsg


-- | Sslang abstract syntax tree.
module Front.Ast

-- | A complete program: a list of top-level definitions.
newtype Program
Program :: [TopDef] -> Program

-- | A top-level definition.
data TopDef

-- | Bind a (data) value to a variable
TopDef :: Definition -> TopDef

-- | Define an algebraic data type
TopType :: TypeDef -> TopDef

-- | Inlined block of C definitions
TopCDefs :: String -> TopDef

-- | Declare external symbol for FFI
TopExtern :: ExternDecl -> TopDef

-- | Associate a type with a symbol
data ExternDecl
ExternDecl :: Identifier -> Typ -> ExternDecl

-- | An algebraic data type definition.
data TypeDef
TypeDef :: Identifier -> [Identifier] -> [TypeVariant] -> TypeDef

-- | The name of the type, e.g., <tt>Option</tt>
[typeName] :: TypeDef -> Identifier

-- | List of type parameters, e.g., <tt>a</tt>
[typeParams] :: TypeDef -> [Identifier]

-- | List of variants, e.g., <tt>Some</tt>, <tt>None</tt>
[typeVariants] :: TypeDef -> [TypeVariant]

-- | A type variant, i.e., a data constructor.
data TypeVariant
VariantUnnamed :: Identifier -> [Typ] -> TypeVariant

-- | A value definition.
data Definition
DefFn :: Identifier -> [Pat] -> TypFn -> Expr -> Definition
DefPat :: Pat -> Expr -> Definition

-- | A pattern appearing on the LHS of a definition or match arm
data Pat

-- | Match anything, i.e., <tt>_</tt>
PatWildcard :: Pat

-- | Variable or data constructor, e.g., <tt>v</tt> or <tt>Some</tt>
PatId :: Identifier -> Pat

-- | Literal match, e.g., <tt>1</tt>
PatLit :: Literal -> Pat

-- | Pattern alias, e.g., <tt>a @ <a>pat</a></tt>
PatAs :: Identifier -> Pat -> Pat

-- | Match on a tuple, e.g., <tt>(<a>pat</a>, <a>pat</a>)</tt>
PatTup :: [Pat] -> Pat

-- | Match on multiple patterns, e.g., <tt>Some a</tt>
PatApp :: [Pat] -> Pat

-- | Match with type annotation, e.g., <tt><a>pat</a>: Type</tt>
PatAnn :: Typ -> Pat -> Pat

-- | Function type annotation
data TypFn
TypReturn :: TypAnn -> TypFn
TypProper :: TypAnn -> TypFn
TypNone :: TypFn

-- | TODO: type classes
type TypAnn = Typ

-- | A type definition
data Typ
TCon :: Identifier -> Typ
TApp :: Typ -> Typ -> Typ
TTuple :: [Typ] -> Typ
TArrow :: Typ -> Typ -> Typ

-- | An expression
data Expr
Id :: Identifier -> Expr
Lit :: Literal -> Expr
Apply :: Expr -> Expr -> Expr
Lambda :: [Pat] -> Expr -> Expr
OpRegion :: Expr -> OpRegion -> Expr
NoExpr :: Expr
Let :: [Definition] -> Expr -> Expr
While :: Expr -> Expr -> Expr
Loop :: Expr -> Expr
Par :: [Expr] -> Expr
IfElse :: Expr -> Expr -> Expr -> Expr
After :: Expr -> Expr -> Expr -> Expr
Assign :: Expr -> Expr -> Expr
Constraint :: Expr -> TypAnn -> Expr
Wait :: [Expr] -> Expr
Seq :: Expr -> Expr -> Expr
Break :: Expr
Match :: Expr -> [(Pat, Expr)] -> Expr
CQuote :: String -> Expr
CCall :: Identifier -> [Expr] -> Expr

-- | An operator region: a flat list of alternating expressions and
--   operators that is initially parsed flat but will be restructured into
--   a tree by the operator precedence parser.
data OpRegion
NextOp :: Identifier -> Expr -> OpRegion -> OpRegion
EOR :: OpRegion

-- | A literal
data Literal
LitInt :: Integer -> Literal
LitString :: String -> Literal
LitRat :: Rational -> Literal
LitChar :: Char -> Literal
LitEvent :: Literal

-- | Fixity declaration for binary operators.
data Fixity
Infixl :: Int -> Identifier -> Fixity
Infixr :: Int -> Identifier -> Fixity

-- | Collect a type application into the type constructor and its
--   arguments.
collectTApp :: Typ -> (Typ, [Typ])

-- | Collect a curried application into the function and its list of
--   arguments.
collectApp :: Expr -> (Expr, [Expr])

-- | Unwrap a (potential) top-level data definition.
getTopDataDef :: TopDef -> Maybe Definition

-- | Unwrap a (potential) top-level type definition.
getTopTypeDef :: TopDef -> Maybe TypeDef

-- | Unwrap a (potential) top-level C inline block.
getTopCDefs :: TopDef -> Maybe String

-- | Unwrap a (potential) top-level external definition.
getTopExtern :: TopDef -> Maybe ExternDecl

-- | Unzip a list of top-level declarations into their counterparts.
getTops :: [TopDef] -> ([TypeDef], [String], [ExternDecl], [Definition])
instance GHC.Show.Show Front.Ast.Typ
instance GHC.Classes.Eq Front.Ast.Typ
instance GHC.Show.Show Front.Ast.TypFn
instance GHC.Classes.Eq Front.Ast.TypFn
instance GHC.Show.Show Front.Ast.TypeVariant
instance GHC.Classes.Eq Front.Ast.TypeVariant
instance GHC.Show.Show Front.Ast.TypeDef
instance GHC.Classes.Eq Front.Ast.TypeDef
instance GHC.Show.Show Front.Ast.ExternDecl
instance GHC.Classes.Eq Front.Ast.ExternDecl
instance GHC.Show.Show Front.Ast.Literal
instance GHC.Classes.Eq Front.Ast.Literal
instance GHC.Show.Show Front.Ast.Pat
instance GHC.Classes.Eq Front.Ast.Pat
instance GHC.Show.Show Front.Ast.OpRegion
instance GHC.Classes.Eq Front.Ast.OpRegion
instance GHC.Show.Show Front.Ast.Expr
instance GHC.Classes.Eq Front.Ast.Expr
instance GHC.Show.Show Front.Ast.Definition
instance GHC.Classes.Eq Front.Ast.Definition
instance GHC.Show.Show Front.Ast.TopDef
instance GHC.Classes.Eq Front.Ast.TopDef
instance GHC.Show.Show Front.Ast.Program
instance GHC.Classes.Eq Front.Ast.Program
instance Prettyprinter.Internal.Pretty Front.Ast.Program
instance Common.Pretty.Dumpy Front.Ast.Program
instance Prettyprinter.Internal.Pretty Front.Ast.TopDef
instance Prettyprinter.Internal.Pretty Front.Ast.Definition
instance Prettyprinter.Internal.Pretty Front.Ast.Expr
instance Prettyprinter.Internal.Pretty Front.Ast.Pat
instance Prettyprinter.Internal.Pretty Front.Ast.Literal
instance Prettyprinter.Internal.Pretty Front.Ast.ExternDecl
instance Prettyprinter.Internal.Pretty Front.Ast.TypeDef
instance Prettyprinter.Internal.Pretty Front.Ast.TypeVariant
instance Prettyprinter.Internal.Pretty Front.Ast.TypFn
instance Prettyprinter.Internal.Pretty Front.Ast.Typ


-- | Identifiers, associated metadata, and reserved identifiers.
module Front.Identifiers

-- | Where an identifier comes from.
data IdKind

-- | User- and library-defined identifiers, e.g., <tt>foo</tt>.
User :: IdKind

-- | Builtin identifiers, e.g., <tt>new</tt> and <tt>deref</tt>.
Builtin :: IdKind

-- | Unused, but user should not be able to define.
Reserved :: IdKind

-- | Metadata associated with a data identifier.
newtype DataInfo
DataInfo :: IdKind -> DataInfo
[dataKind] :: DataInfo -> IdKind

-- | Metadata associated with a type identifier.
newtype TypInfo
TypInfo :: IdKind -> TypInfo
[typKind] :: TypInfo -> IdKind

-- | Map of builtin types.
builtinTypes :: Map Identifier TypInfo

-- | Map of builtin data.
builtinData :: Map Identifier DataInfo
instance GHC.Classes.Eq Front.Identifiers.IdKind
instance GHC.Show.Show Front.Identifiers.IdKind
instance Common.Default.Default Front.Identifiers.TypInfo
instance Common.Default.Default Front.Identifiers.DataInfo


-- | Parse OpRegion nodes inside of an AST <a>Program</a>.
module Front.ParseOperators

-- | Parse OpRegion nodes inside of an AST <a>Program</a>.
parseOperators :: Program -> Pass Program

-- | Fixity declaration for binary operators.
data Fixity
Infixl :: Int -> Identifier -> Fixity
Infixr :: Int -> Identifier -> Fixity

module Front.Pattern.Common
data CInfo
CInfo :: Identifier -> Identifier -> Int -> CInfo
[cName] :: CInfo -> Identifier
[cType] :: CInfo -> Identifier
[cArity] :: CInfo -> Int
data TInfo
TInfo :: Identifier -> Set Identifier -> TInfo
[tName] :: TInfo -> Identifier
[tCSet] :: TInfo -> Set Identifier
buildTypeMap :: [TypeDef] -> Map Identifier TInfo
buildConsMap :: [TypeDef] -> Map Identifier CInfo
instance GHC.Show.Show Front.Pattern.Common.CInfo
instance GHC.Classes.Eq Front.Pattern.Common.CInfo
instance GHC.Show.Show Front.Pattern.Common.TInfo
instance GHC.Classes.Eq Front.Pattern.Common.TInfo

module Front.Pattern.Desugar
type Equation = ([Pat], Expr)
type Arm = (Pat, Expr)
data DesugarCtx
DesugarCtx :: Map Identifier TInfo -> Map Identifier CInfo -> Int -> DesugarCtx
[typeMap] :: DesugarCtx -> Map Identifier TInfo
[consMap] :: DesugarCtx -> Map Identifier CInfo
[anonCount] :: DesugarCtx -> Int
newtype DesugarFn a
DesugarFn :: StateT DesugarCtx Pass a -> DesugarFn a
runDesugarFn :: DesugarFn a -> DesugarCtx -> Pass a
freshVar :: DesugarFn Identifier
buildCtx :: [TypeDef] -> DesugarCtx
desugarProgram :: Program -> Pass Program
desugarTopDefs :: [TopDef] -> DesugarFn [TopDef]
desugarDefs :: [Definition] -> DesugarFn [Definition]
desugarDef :: Definition -> DesugarFn Definition
desugarExprs :: [Expr] -> DesugarFn [Expr]
desugarExpr :: Expr -> DesugarFn Expr
desugarOpRegion :: OpRegion -> DesugarFn OpRegion
desugarMatch :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchGen :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchVar :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchWild :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchCons :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchLit :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchTup :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchIdCons :: [Equation] -> DesugarFn [Equation]
desugarMatchAsAnn :: [Identifier] -> [Equation] -> DesugarFn [Equation]
partitionEqs :: [Equation] -> [[Equation]]
substId :: Identifier -> Identifier -> Expr -> Expr
singleLet :: Identifier -> Expr -> Expr -> Expr
singleAlias :: Identifier -> Identifier -> Expr -> Expr
singleAliasWithTyp :: Identifier -> Identifier -> Typ -> Expr -> Expr
getConstructors :: Identifier -> DesugarFn (Set Identifier)
getArity :: Identifier -> DesugarFn Int
getCInfo :: Identifier -> DesugarFn CInfo
getTInfo :: Identifier -> DesugarFn TInfo
foldrM :: Monad m => (a -> b -> m b) -> b -> [a] -> m b
throwDesugarError :: DesugarFn a
throwInexhaustionError :: DesugarFn a
instance Control.Monad.State.Class.MonadState Front.Pattern.Desugar.DesugarCtx Front.Pattern.Desugar.DesugarFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Pattern.Desugar.DesugarFn
instance Control.Monad.Fail.MonadFail Front.Pattern.Desugar.DesugarFn
instance GHC.Base.Monad Front.Pattern.Desugar.DesugarFn
instance GHC.Base.Applicative Front.Pattern.Desugar.DesugarFn
instance GHC.Base.Functor Front.Pattern.Desugar.DesugarFn

module Front.Pattern.Vector
data PatVec
PatVec :: Int -> [Pat] -> PatVec
[ncol] :: PatVec -> Int
[toList] :: PatVec -> [Pat]
fromList :: [Pat] -> PatVec
singleton :: Pat -> PatVec
extend :: PatVec -> PatVec -> PatVec
append :: Pat -> PatVec -> PatVec
hd :: PatVec -> Pat
tl :: PatVec -> PatVec
specialize :: PatVec -> PatVec
specializeWild :: Int -> PatVec -> PatVec
instance GHC.Show.Show Front.Pattern.Vector.PatVec
instance GHC.Classes.Eq Front.Pattern.Vector.PatVec

module Front.Pattern.Matrix
data PatMat
PatMat :: Int -> Int -> [PatVec] -> PatMat
[nrow] :: PatMat -> Int
[ncol] :: PatMat -> Int
[toList] :: PatMat -> [PatVec]
singleCol :: [Pat] -> PatMat
singleRow :: [Pat] -> PatMat
fromPatVec :: PatVec -> PatMat
emptyWithCols :: Int -> PatMat
hd :: PatMat -> PatVec
tl :: PatMat -> PatMat
extend :: PatMat -> PatMat -> PatMat
prepend :: PatVec -> PatMat -> PatMat
specializeLit :: Literal -> PatMat -> PatMat
specializeTup :: Int -> PatMat -> PatMat
specializeCons :: Int -> Identifier -> PatMat -> PatMat
defaultize :: PatMat -> PatMat
instance GHC.Show.Show Front.Pattern.Matrix.PatMat
instance GHC.Classes.Eq Front.Pattern.Matrix.PatMat

module Front.Pattern.Anomaly
data AnomalyCtx
AnomalyCtx :: Map Identifier TInfo -> Map Identifier CInfo -> AnomalyCtx
[typeMap] :: AnomalyCtx -> Map Identifier TInfo
[consMap] :: AnomalyCtx -> Map Identifier CInfo
newtype AnomalyFn a
AnomalyFn :: ReaderT AnomalyCtx Pass a -> AnomalyFn a
buildCtx :: [TypeDef] -> AnomalyCtx

-- | Run a AnomalyFn computation.
runAnomalyFn :: AnomalyFn a -> AnomalyCtx -> Pass a
checkProgram :: Program -> Pass ()
checkDefs :: [Definition] -> AnomalyFn ()
checkDef :: Definition -> AnomalyFn ()
checkExprs :: [Expr] -> AnomalyFn ()
checkExpr :: Expr -> AnomalyFn ()
checkOpRegion :: OpRegion -> AnomalyFn ()
checkPats :: [Pat] -> AnomalyFn ()
checkUselessArm :: [Pat] -> AnomalyFn ()
checkExhaustive :: [Pat] -> AnomalyFn ()
useful :: PatVec -> PatMat -> AnomalyFn Bool
usefulWildLit :: LitType -> PatVec -> PatMat -> AnomalyFn Bool
samplePat :: PatMat -> Maybe Pat
hasCompleteCons :: Set Identifier -> PatMat -> Bool
hasCompleteLit :: LitType -> PatMat -> Bool
wellFormed :: PatVec -> PatMat -> AnomalyFn ()
wellFormedPat :: Pat -> PatMat -> AnomalyFn ()
wellFormedCons :: TInfo -> PatMat -> AnomalyFn ()
wellFormedTup :: Int -> PatMat -> AnomalyFn ()
wellFormedLit :: Literal -> PatMat -> AnomalyFn ()
wellFormedWild :: PatMat -> AnomalyFn ()
data LitType
LitIntT :: LitType
LitStringT :: LitType
LitRatT :: LitType
LitCharT :: LitType
LitEventT :: LitType
litToType :: Literal -> LitType
askCInfo :: Identifier -> AnomalyFn CInfo
askTInfo :: Identifier -> AnomalyFn TInfo

-- | Report <a>Identifier</a> for error reporting.
showId :: Identifier -> ErrorMsg
showSet :: Set Identifier -> ErrorMsg
throwMalformedError :: AnomalyFn a
instance Control.Monad.Reader.Class.MonadReader Front.Pattern.Anomaly.AnomalyCtx Front.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Front.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Fail.MonadFail Front.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Monad Front.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Applicative Front.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Functor Front.Pattern.Anomaly.AnomalyFn
instance GHC.Show.Show Front.Pattern.Anomaly.LitType
instance GHC.Classes.Eq Front.Pattern.Anomaly.LitType

module Front.Pattern
desugarProgram :: Program -> Pass Program
checkAnomaly :: Program -> Pass ()


-- | Check scoping rules and naming conventions for identifiers.
--   
--   Here, we ensure that all identifiers that appear in the AST only
--   appear after they are previously declared or defined.
--   
--   Identifiers can be segregated into two categories: data identifiers,
--   which produce expressions, and type identifiers, which produce types
--   (more accurately, type expressions). These inhabit separate namespaces
--   and are distinguished by the different contexts in which they are
--   used.
--   
--   Of each category, there are two kinds of identifiers: constructors and
--   variables. Constructors must begin with an upper case letter or a
--   colon (<tt>:</tt>); all other identifiers are variables (see
--   <a>isCons</a> and <a>isVar</a>). For instance, data constructors name
--   the variants of an algebraic data type, while data variables name
--   values bound by a let-binding, a pattern-match, or a lambda.
--   Meanwhile, type constructors are points in the type system defined by
--   the user, while type variables are universally quantified in each type
--   expression.
--   
--   Consider the following example:
--   
--   @@ type Bool = True False
--   
--   type Either t u = Left t Right u
--   
--   liftEither b x y: Bool -&gt; a -&gt; b -&gt; Either a b = match b True
--   = Left x False = Right y @@
--   
--   Data variables are <tt>switch</tt>, <tt>b</tt>, <tt>x</tt>, and
--   <tt>y</tt>; data constructors are <tt>True</tt>, <tt>False</tt>,
--   <tt>Left</tt>, and <tt>Right</tt>. Type variables are <tt>t</tt>,
--   <tt>u</tt>, <tt>a</tt>, and <tt>b</tt>; type constructors are
--   <tt>Bool</tt> and <tt>Either</tt>.
--   
--   The grammar as it appears in the parser does not actually distinguish
--   between any of these kinds of identifiers, so it is the responsibility
--   of this module to check that, a data constructor does not appear where
--   a data variable is expected, e.g., <tt>let F x = e</tt>, or vice
--   versa, e.g., <tt>let f (x Y) = e</tt>.
module Front.Scope

-- | Check the scoping of a <a>Program</a>.
scopeProgram :: Program -> Pass ()
instance Control.Monad.Reader.Class.MonadReader Front.Scope.ScopeCtx Front.Scope.ScopeFn
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Front.Scope.ScopeFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Scope.ScopeFn
instance Control.Monad.Fail.MonadFail Front.Scope.ScopeFn
instance GHC.Base.Monad Front.Scope.ScopeFn
instance GHC.Base.Applicative Front.Scope.ScopeFn
instance GHC.Base.Functor Front.Scope.ScopeFn


-- | Sslang source code tokens.
module Front.Token

-- | Tokens extracted from source text.
newtype Token
Token :: (Span, TokenType) -> Token

-- | Extract the <a>TokenType</a> from a <a>Token</a>.
tokenType :: Token -> TokenType

-- | The location of a token in the source text.
data Span
Span :: Int -> Int -> Int -> Int -> Span
[tokPos] :: Span -> Int
[tokLen] :: Span -> Int
[tokLine] :: Span -> Int
[tokCol] :: Span -> Int

-- | The types of tokens that can appear in a sslang source file.
data TokenType
TEOF :: TokenType
TType :: TokenType
TIf :: TokenType
TElse :: TokenType
TWhile :: TokenType
TDo :: TokenType
TPar :: TokenType
TLoop :: TokenType
TLet :: TokenType
TMatch :: TokenType
TAfter :: TokenType
TWait :: TokenType
TFun :: TokenType
TExtern :: TokenType
TEq :: TokenType
TLarrow :: TokenType
TRarrow :: TokenType
TDRarrow :: TokenType
TDBar :: TokenType
TColon :: TokenType
TSemicolon :: TokenType
TBar :: TokenType
TComma :: TokenType
TUnderscore :: TokenType
TAt :: TokenType
TAmpersand :: TokenType
TLparen :: TokenType
TRparen :: TokenType
TLbrace :: TokenType
TRbrace :: TokenType
TLbracket :: TokenType
TRbracket :: TokenType
TInteger :: Integer -> TokenType
TString :: String -> TokenType
TId :: Identifier -> TokenType
TOp :: Identifier -> TokenType
TCSym :: Identifier -> TokenType
TCQuote :: String -> TokenType
TCBlock :: String -> TokenType

-- | Pretty print a list of tokens.
prettyTokens :: [Token] -> String
instance GHC.Show.Show Front.Token.Span
instance GHC.Classes.Eq Front.Token.Span
instance GHC.Show.Show Front.Token.TokenType
instance GHC.Classes.Eq Front.Token.TokenType
instance GHC.Classes.Eq Front.Token.Token
instance GHC.Show.Show Front.Token.Token
instance Prettyprinter.Internal.Pretty Front.Token.Token
instance Prettyprinter.Internal.Pretty Front.Token.TokenType
instance Prettyprinter.Internal.Pretty Front.Token.Span


-- | Scanner for sslang.
--   
--   In addition to tokenizing the input text stream, this scanner is
--   responsible for the following:
--   
--   <ul>
--   <li>Insert implicit open braces after any block-starting token, if
--   necessary;</li>
--   <li>Insert implicit separators for aligned lines within the same
--   block; and</li>
--   <li>Insert implicit close braces if an implicit block closed, either
--   by a decrease in indentation, or by the closure of a surrounding
--   explicit block.</li>
--   </ul>
--   
--   As such, the scanner's state is enriched with a stack of contexts
--   which it uses to perform basic delimiter matching. It also relies on
--   epsilon transitions to emit implicit tokens.
module Front.Scanner

-- | Extract a token stream from an input string.
scanTokens :: String -> Pass [Token]

-- | Extract a stream of token types (without span) from an input string.
scanTokenTypes :: String -> Pass [TokenType]

-- | Used to integrate with Happy parser.
lexerForHappy :: (Token -> Alex a) -> Alex a

-- | Tokens extracted from source text.
newtype Token
Token :: (Span, TokenType) -> Token

-- | The types of tokens that can appear in a sslang source file.
data TokenType
TEOF :: TokenType
TType :: TokenType
TIf :: TokenType
TElse :: TokenType
TWhile :: TokenType
TDo :: TokenType
TPar :: TokenType
TLoop :: TokenType
TLet :: TokenType
TMatch :: TokenType
TAfter :: TokenType
TWait :: TokenType
TFun :: TokenType
TExtern :: TokenType
TEq :: TokenType
TLarrow :: TokenType
TRarrow :: TokenType
TDRarrow :: TokenType
TDBar :: TokenType
TColon :: TokenType
TSemicolon :: TokenType
TBar :: TokenType
TComma :: TokenType
TUnderscore :: TokenType
TAt :: TokenType
TAmpersand :: TokenType
TLparen :: TokenType
TRparen :: TokenType
TLbrace :: TokenType
TRbrace :: TokenType
TLbracket :: TokenType
TRbracket :: TokenType
TInteger :: Integer -> TokenType
TString :: String -> TokenType
TId :: Identifier -> TokenType
TOp :: Identifier -> TokenType
TCSym :: Identifier -> TokenType
TCQuote :: String -> TokenType
TCBlock :: String -> TokenType

-- | The location of a token in the source text.
data Span
Span :: Int -> Int -> Int -> Int -> Span
[tokPos] :: Span -> Int
[tokLen] :: Span -> Int
[tokLine] :: Span -> Int
[tokCol] :: Span -> Int

-- | User-facing syntax error.
syntaxErr :: String -> Alex a

-- | Internal compiler error for unreachable code.
internalErr :: String -> Alex a

-- | Convert Alex's String-encoded errors to Sslang <a>Error</a>.
liftErr :: String -> Error
instance GHC.Show.Show Front.Scanner.AlexPosn
instance GHC.Classes.Eq Front.Scanner.AlexPosn
instance GHC.Show.Show Front.Scanner.ScannerContext
instance GHC.Base.Functor Front.Scanner.Alex
instance GHC.Base.Applicative Front.Scanner.Alex
instance GHC.Base.Monad Front.Scanner.Alex


-- | Parser for sslang token stream.
--   
--   To check for shift<i>reduce and reduce</i>reduce conflicts, generate
--   parser manually:
--   
--   <pre>
--   happy -i Parser.y -o /dev/null
--   </pre>
--   
--   Then check <tt>Parser.info</tt>.
module Front.Parser

-- | Parse a <a>String</a> and yield a <a>Program</a>.
parseProgram :: String -> Pass Program


-- | Front end of the compiler pipeline.
--   
--   Throughout this stage, high-level syntax is progressively parsed and
--   desugared into simpler AST constructs.
module Front

-- | Operation modes for the front end compiler stage.
data Mode

-- | Compile end-to-end (default).
Continue :: Mode

-- | Print the token stream from the scanner.
DumpTokens :: Mode

-- | Print the initial parsed AST, before operators are parsed.
DumpAst :: Mode

-- | Print the AST after operators are parsed.
DumpAstParsed :: Mode

-- | Print the AST after all desugaring, just before lowering.
DumpAstFinal :: Mode

-- | Compiler options for the front end compiler stage.
newtype Options
Options :: Mode -> Options
[optMode] :: Options -> Mode

-- | CLI options for the front end compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Parse a fully-formed AST from some String input.
parseAst :: Options -> String -> Pass Program

-- | Semantic checking on an AST.
checkAst :: Options -> Program -> Pass ()

-- | Front end compiler stage.
run :: Options -> String -> Pass Program
instance GHC.Show.Show Front.Mode
instance GHC.Classes.Eq Front.Mode
instance GHC.Show.Show Front.Options
instance GHC.Classes.Eq Front.Options
instance Common.Default.Default Front.Options


-- | Common definitions for the type system(s) used in this compiler.
--   
--   The following is a sketch of the type pipeline (from top to bottom):
--   
--   Types.Ast: type classes + polymorphic types + implicit types (to be
--   inferred)
--   
--   (type inference)
--   
--   Types.Classes: type classes + polymorphic types
--   
--   (typeclass instantiation)
--   
--   Types.Poly: polymorphic types
--   
--   (monomophisation)
--   
--   Types.Flat: concrete only
module IR.Types.TypeSystem

-- | The number of arguments a type constructor will take.
type Arity = Int

-- | Builtin type constructors that should be preserved across all type
--   systems.
data Builtin t

-- | Singleton type <tt>()</tt>
Unit :: Builtin t

-- | Uninhabited type <tt>!</tt>, coerces with anything
Void :: Builtin t

-- | Reference of <tt>&amp;</tt>
Ref :: t -> Builtin t

-- | Function arrow <tt>a -&gt; b</tt>
Arrow :: t -> t -> Builtin t

-- | Tuple with two or more fields
Tuple :: [t] -> Builtin t

-- | Two's complement binary type with size in bits
Integral :: Int -> Builtin t

-- | A type system must allow us to construct and access underlying
--   builtins.
--   
--   Instances should satisfy the following law:
--   
--   <ul>
--   <li><pre>injectBuiltin . projectBuiltin = Just</pre></li>
--   </ul>
class TypeSystem t
projectBuiltin :: TypeSystem t => Builtin t -> t
injectBuiltin :: TypeSystem t => t -> Maybe (Builtin t)

-- | Helper to construct <a>Unit</a> type in any <a>TypeSystem</a>.
unit :: TypeSystem t => t

-- | Helper to construct <a>Void</a> type in any <a>TypeSystem</a>.
void :: TypeSystem t => t

-- | Helper to construct <a>Ref</a> type in any <a>TypeSystem</a>.
ref :: TypeSystem t => t -> t

-- | Helper to construct <a>Arrow</a> type in any <a>TypeSystem</a>.
arrow :: TypeSystem t => t -> t -> t

-- | Helper to unwrap <a>Ref</a> in any <a>TypeSystem</a>.
deref :: TypeSystem t => t -> Maybe t

-- | Helper to unwrap <a>Arrow</a> in any <a>TypeSystem</a>.
dearrow :: TypeSystem t => t -> Maybe (t, t)

-- | Helper to construct tuples from list of types, accounting for size
--   &lt; 2.
tuple :: TypeSystem t => [t] -> t

-- | Helper to construct integral type.
int :: TypeSystem t => Int -> t

-- | Decompose an <a>Arrow</a> type into a list of argument types and a
--   return type.
collectArrow :: TypeSystem t => t -> ([t], t)

-- | The type definition associated with a type constructor.
--   
--   A definition for `data MyList a = Cons a (MyList a) | Nil` looks like:
--   
--   <pre>
--   TypeDef { targs = [a]
--           , [ (<a>Cons</a>, VariantUnnamed [TVar a, TCon (<a>MyList</a> [TVar a])])
--             , (<a>Nil</a>, VariantUnnamed [])
--             ]
--           }
--   </pre>
--   
--   (Data constructors for identifiers are omitted for brevity.)
--   
--   Note that for a flat type system, where all type constructors are
--   nullary, targs will just be set to [].
data TypeDef t
TypeDef :: [(DConId, TypeVariant t)] -> [TVarId] -> TypeDef t
[variants] :: TypeDef t -> [(DConId, TypeVariant t)]
[targs] :: TypeDef t -> [TVarId]

-- | Arguments to a data constructor, whose fields may or may not be named
data TypeVariant t

-- | A record with named fields
VariantNamed :: [(VarId, t)] -> TypeVariant t

-- | An algebraic type with unnamed fields
VariantUnnamed :: [t] -> TypeVariant t

-- | The number of fields in a <a>TypeVariant</a>.
variantFields :: TypeVariant t -> Int
instance Data.Data.Data t => Data.Data.Data (IR.Types.TypeSystem.Builtin t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (IR.Types.TypeSystem.Builtin t)
instance GHC.Show.Show t => GHC.Show.Show (IR.Types.TypeSystem.Builtin t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Types.TypeSystem.Builtin t)
instance Data.Data.Data t => Data.Data.Data (IR.Types.TypeSystem.TypeVariant t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Types.TypeSystem.TypeVariant t)
instance GHC.Show.Show t => GHC.Show.Show (IR.Types.TypeSystem.TypeVariant t)
instance Data.Data.Data t => Data.Data.Data (IR.Types.TypeSystem.TypeDef t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Types.TypeSystem.TypeDef t)
instance GHC.Show.Show t => GHC.Show.Show (IR.Types.TypeSystem.TypeDef t)
instance GHC.Base.Functor IR.Types.TypeSystem.TypeDef
instance GHC.Base.Functor IR.Types.TypeSystem.TypeVariant
instance GHC.Base.Functor IR.Types.TypeSystem.Builtin
instance Prettyprinter.Internal.Pretty t => Prettyprinter.Internal.Pretty (IR.Types.TypeSystem.Builtin t)
instance Common.Pretty.Dumpy t => Common.Pretty.Dumpy (IR.Types.TypeSystem.Builtin t)


-- | Type system supporting (parametric) polymorphism.
--   
--   Based on the Hindley-Milner-Damas type system and the definitions in
--   OCaml and Caml Light.
--   
--   This is written with the intention of being a lower-level type system,
--   one that a more expressive type system compiles down into. Notably,
--   this type system does not support aliases, records (data constructors
--   with named field), etc. These will have been instantiated/desugared by
--   this point.
--   
--   This type system also does not support type classes or any sort of
--   higher-kinded polymorphism. This is due to following restrictions:
--   
--   <ul>
--   <li>No partially-applied type constructors; whenever a type
--   constructor appears in a type expression, it is fully applied. e.g.,
--   <tt>Option</tt> by itself is not allowed, but <tt>Option Int</tt>
--   is.</li>
--   <li>No abstraction over type constructors; the head (left-most term)
--   of a type application must be a concrete type constructor. e.g.,
--   <tt>'1 '2</tt> is not allowed.</li>
--   <li>No quantifiers inside of type expressions; all quantifiers must be
--   top-level (also known as prenex normal form, or PNF). This is what
--   distinguishes HM from System F, and what makes the former decidable
--   while the latter undecidable.</li>
--   </ul>
module IR.Types.Poly

-- | The language of type expressions, e.g., what appears in a type
--   signature.
data Type

-- | Builtin types
TBuiltin :: Builtin Type -> Type

-- | Type constructor, e.g., <tt>Option '0</tt>
TCon :: TConId -> [Type] -> Type

-- | Type variables, e.g., <tt>'0</tt>
TVar :: TVarId -> Type

-- | Builtin type constructors that should be preserved across all type
--   systems.
data Builtin t

-- | Singleton type <tt>()</tt>
Unit :: Builtin t

-- | Uninhabited type <tt>!</tt>, coerces with anything
Void :: Builtin t

-- | Reference of <tt>&amp;</tt>
Ref :: t -> Builtin t

-- | Function arrow <tt>a -&gt; b</tt>
Arrow :: t -> t -> Builtin t

-- | Tuple with two or more fields
Tuple :: [t] -> Builtin t

-- | Two's complement binary type with size in bits
Integral :: Int -> Builtin t
instance Data.Data.Data IR.Types.Poly.Type
instance GHC.Show.Show IR.Types.Poly.Type
instance GHC.Classes.Eq IR.Types.Poly.Type
instance IR.Types.TypeSystem.TypeSystem IR.Types.Poly.Type
instance Prettyprinter.Internal.Pretty IR.Types.Poly.Type
instance Common.Pretty.Dumpy IR.Types.Poly.Type


-- | Types with Typeclasses, e.g., after type inference
--   
--   For now, just the polymorphic types.
module IR.Types.Classes

-- | Builtin type constructors that should be preserved across all type
--   systems.
data Builtin t

-- | Singleton type <tt>()</tt>
Unit :: Builtin t

-- | Uninhabited type <tt>!</tt>, coerces with anything
Void :: Builtin t

-- | Reference of <tt>&amp;</tt>
Ref :: t -> Builtin t

-- | Function arrow <tt>a -&gt; b</tt>
Arrow :: t -> t -> Builtin t

-- | Tuple with two or more fields
Tuple :: [t] -> Builtin t

-- | Two's complement binary type with size in bits
Integral :: Int -> Builtin t

-- | The language of type expressions, e.g., what appears in a type
--   signature.
data Type

-- | Builtin types
TBuiltin :: Builtin Type -> Type

-- | Type constructor, e.g., Option '0
TCon :: TConId -> [Type] -> Type

-- | Type variables, e.g., '0
TVar :: TVarId -> Type

-- | Type scheme.
data Scheme
Forall :: [TVarId] -> Type -> Scheme
instance Data.Data.Data IR.Types.Classes.Type
instance GHC.Classes.Ord IR.Types.Classes.Type
instance GHC.Classes.Eq IR.Types.Classes.Type
instance GHC.Show.Show IR.Types.Classes.Scheme
instance Data.Data.Data IR.Types.Classes.Scheme
instance GHC.Classes.Ord IR.Types.Classes.Scheme
instance GHC.Classes.Eq IR.Types.Classes.Scheme
instance Prettyprinter.Internal.Pretty IR.Types.Classes.Scheme
instance IR.Types.TypeSystem.TypeSystem IR.Types.Classes.Type
instance Prettyprinter.Internal.Pretty IR.Types.Classes.Type
instance GHC.Show.Show IR.Types.Classes.Type


-- | Type annotations, as collected from the Ast.
module IR.Types.Annotated

-- | Builtin type constructors that should be preserved across all type
--   systems.
data Builtin t

-- | Singleton type <tt>()</tt>
Unit :: Builtin t

-- | Uninhabited type <tt>!</tt>, coerces with anything
Void :: Builtin t

-- | Reference of <tt>&amp;</tt>
Ref :: t -> Builtin t

-- | Function arrow <tt>a -&gt; b</tt>
Arrow :: t -> t -> Builtin t

-- | Tuple with two or more fields
Tuple :: [t] -> Builtin t

-- | Two's complement binary type with size in bits
Integral :: Int -> Builtin t

-- | A single term may be annotated by zero or more types.
--   
--   When multiple exist, it should be assumed that they are equivalent, in
--   the sense that they can be unified.
--   
--   Type annotations can be added using <a>&lt;&gt;</a> (from
--   <a>Semigroup</a>), while <a>mempty</a> represents no type annotation.
newtype Type
Type :: [TypeAnnote] -> Type

-- | A type annotation.
data TypeAnnote

-- | Builtin types
TBuiltin :: Builtin Type -> TypeAnnote

-- | Type constructor, e.g., Option '0
TCon :: TConId -> [Type] -> TypeAnnote

-- | Type variables, e.g., '0
TVar :: TVarId -> TypeAnnote

-- | Convenience helper for no type annotations.
untyped :: Type
instance GHC.Base.Monoid IR.Types.Annotated.Type
instance GHC.Base.Semigroup IR.Types.Annotated.Type
instance Data.Data.Data IR.Types.Annotated.Type
instance GHC.Show.Show IR.Types.Annotated.Type
instance GHC.Classes.Eq IR.Types.Annotated.Type
instance Data.Data.Data IR.Types.Annotated.TypeAnnote
instance GHC.Classes.Eq IR.Types.Annotated.TypeAnnote
instance GHC.Show.Show IR.Types.Annotated.TypeAnnote
instance IR.Types.TypeSystem.TypeSystem IR.Types.Annotated.Type
instance Prettyprinter.Internal.Pretty IR.Types.Annotated.Type
instance Prettyprinter.Internal.Pretty IR.Types.Annotated.TypeAnnote


-- | Sslang's intermediate representation and its associated helpers.
module IR.IR

-- | Top-level compilation unit.
--   
--   <tt>t</tt> is the type system in use, e.g., <a>IR.Types.Flat</a>
data Program t
Program :: VarId -> String -> [(VarId, t)] -> [(VarId, Expr t)] -> [(TConId, TypeDef t)] -> Program t
[programEntry] :: Program t -> VarId
[cDefs] :: Program t -> String
[externDecls] :: Program t -> [(VarId, t)]
[programDefs] :: Program t -> [(VarId, Expr t)]
[typeDefs] :: Program t -> [(TConId, TypeDef t)]

-- | A name to be bound; <a>Nothing</a> represents a wildcard, e.g.,
--   <tt>let _ = ...</tt>.
type Binder = Maybe VarId

-- | Literal values supported by the language.
--   
--   Note that these don't carry any connotation of type: <tt>1</tt> just
--   means <tt>1</tt>,
data Literal
LitIntegral :: Integer -> Literal
LitBool :: Bool -> Literal
LitEvent :: Literal

-- | Primitive operations.
--   
--   These should be the kinds of functions one may expect to be available
--   as operators in C, or as instructions in an assembly language.
--   
--   For simplicity and consistency, they should be:
--   
--   <ul>
--   <li>Pure (i.e., side-effectful iff operands are side-effectful, i.e.,
--   no <tt>=</tt>)</li>
--   <li>Strict in all operands (i.e., no <tt>&amp;&amp;</tt> or
--   <tt>||</tt>)</li>
--   </ul>
--   
--   We can instead implement short-circuit control flow using match
--   statements.
data PrimOp

-- | negation, i.e., -x
PrimNeg :: PrimOp

-- | logical not, i.e., !x
PrimNot :: PrimOp

-- | bitwise not, i.e., ~x
PrimBitNot :: PrimOp

-- | addition, i.e., x + y
PrimAdd :: PrimOp

-- | subtraction, i.e., x - y
PrimSub :: PrimOp

-- | multiplication, i.e., x * y
PrimMul :: PrimOp

-- | division, i.e., x / y
PrimDiv :: PrimOp

-- | modulus, i.e., x % y
PrimMod :: PrimOp

-- | bitwise-and, i.e., x &amp; y
PrimBitAnd :: PrimOp

-- | bitwise-or, i.e., x | y
PrimBitOr :: PrimOp

-- | equality, i.e., x == y
PrimEq :: PrimOp

-- | equality, i.e., x != y
PrimNeq :: PrimOp

-- | greater than, i.e., x &gt; y
PrimGt :: PrimOp

-- | greater than or equal to, i.e., x &gt;= y
PrimGe :: PrimOp

-- | less than, i.e., x &lt; y
PrimLt :: PrimOp

-- | less than or equal to, i.e., x &lt;= y
PrimLe :: PrimOp

-- | Primitive functions for side-effects and imperative control flow.
data Primitive

-- | <tt>New e</tt> allocates a schedule variable initialized to
--   <tt>e</tt>, and returns a reference to it.
New :: Primitive

-- | <tt>Dup r</tt> dups the reference <tt>r</tt> and returns <tt>r</tt>.
Dup :: Primitive

-- | <tt>Drop e r</tt> evaluates to <tt>e</tt>, but also drops <tt>r</tt>.
Drop :: Primitive

-- | <tt>Deref r</tt> dereferences reference <tt>r</tt> to obtain its
--   value.
Deref :: Primitive

-- | <tt>Assign r e</tt> instantly assigns value <tt>e</tt> to reference
--   <tt>r</tt>.
Assign :: Primitive

-- | <tt>After t r e</tt> assigns <tt>e</tt> to reference <tt>r</tt> after
--   time <tt>t</tt>.
After :: Primitive

-- | <tt>Par es+</tt> evaluates expressions <tt>es</tt> concurrently.
Par :: Primitive

-- | <tt>Wait rs+</tt> waits for an assignment to any reference in
--   <tt>rs</tt>.
Wait :: Primitive

-- | <tt>Loop b</tt> loops body <tt>b</tt> forever.
Loop :: Primitive

-- | <tt>Break</tt> breaks out of the innermost loop.
Break :: Primitive

-- | <tt>Now</tt> obtains the value of the current instant
Now :: Primitive

-- | Inlined C expression code.
PrimOp :: PrimOp -> Primitive

-- | Primitive operator.
CQuote :: String -> Primitive

-- | Direct call to arbitrary C function (NOTE: HACKY).
CCall :: CSym -> Primitive

-- | Call to well-typed extern symbol.
FfiCall :: VarId -> Primitive

-- | Expressions, based on the let-polymorphic lambda calculus.
--   
--   <tt>t</tt> represents the type of this expression, e.g., <a>Flat</a>.
--   At various stages, this may represent a richer or simpler type system.
--   The type is embedded in each data constructor so as to type-annotate
--   the entire expression tree.
--   
--   Designed for side effects with call-by-value evaluation order. Basic
--   sequencing can be recovered through let-bindings:
--   
--   <pre>
--   let _ = stmt1 in
--   let _ = stmt2 in
--   ...
--   </pre>
--   
--   Effects of <tt>stmt1</tt> take place before that of <tt>stmt2</tt>.
data Expr t

-- | <tt>Var n t</tt> is a variable named <tt>n</tt> of type <tt>t</tt>.
Var :: VarId -> t -> Expr t

-- | <tt>Data d t</tt> is a data constructor named <tt>d</tt> of type
--   <tt>t</tt>.
Data :: DConId -> t -> Expr t

-- | <tt>Lit l t</tt> is a literal value <tt>l</tt> of type <tt>t</tt>.
Lit :: Literal -> t -> Expr t

-- | <tt>App f a t</tt> applies function <tt>f</tt> to argument <tt>a</tt>,
--   producing a value of type <tt>t</tt>.
App :: Expr t -> Expr t -> t -> Expr t

-- | <tt>Let [(n, v)] b t</tt> binds value <tt>v</tt> to variable
--   <tt>v</tt> in its body <tt>b</tt>.
--   
--   The bindings list may only be of length greater than 1 for a set of
--   mutually co-recursive functions.
Let :: [(Binder, Expr t)] -> Expr t -> t -> Expr t

-- | <tt>Lambda v b t</tt> constructs an anonymous function of type
--   <tt>t</tt> that binds a value to parameter <tt>v</tt> in its body
--   <tt>b</tt>.
Lambda :: Binder -> Expr t -> t -> Expr t

-- | <tt>Match s alts t</tt> pattern-matches on scrutinee <tt>s</tt>
--   against alternatives <tt>alts</tt>, each producing a value of type
--   <tt>t</tt>.
Match :: Expr t -> [(Alt, Expr t)] -> t -> Expr t

-- | <tt>Prim p es t</tt> applies primitive <tt>p</tt> arguments
--   <tt>es</tt>, producing a value of type <tt>t</tt>.
Prim :: Primitive -> [Expr t] -> t -> Expr t

-- | An alternative in a pattern-match.
data Alt

-- | <tt>AltData d vs</tt> matches data constructor <tt>d</tt>, and names
--   dcon members <tt>vs</tt>.
AltData :: DConId -> [Binder] -> Alt

-- | <tt>AltLit l</tt> matches against literal <tt>l</tt>, producing
--   expression <tt>e</tt>.
AltLit :: Literal -> Alt

-- | <tt>AltDefault v</tt> matches anything, and bound to name <tt>v</tt>.
AltDefault :: Binder -> Alt

-- | Identifier for data variables, e.g., <tt>x</tt>.
newtype VarId
VarId :: Identifier -> VarId

-- | Identifier for type constructors, e.g., <tt>Option</tt>.
newtype TConId
TConId :: Identifier -> TConId

-- | Identifier for data constructors, e.g., <tt>None</tt>.
newtype DConId
DConId :: Identifier -> DConId

-- | Predicate of whether an expression "looks about right".
--   
--   Description left deliberately vague so that we have the flexibility to
--   strengthen this predicate. For now, we just check that all primitives
--   are applied to the right number of arguments.
--   
--   This predicate also provides a template to recursively traverse
--   through all sub-expressions of an expression.
wellFormed :: Expr t -> Bool

-- | Collect a curried list of function arguments from a nesting of
--   lambdas.
collectLambda :: Expr t -> ([Binder], Expr t)

-- | Create a lambda chain given a list of argument-type pairs and a body.
makeLambdaChain :: TypeSystem t => [(Binder, t)] -> Expr t -> Expr t
extract :: Comonad w => w a -> a

-- | Apply a function to zero or more arguments.
--   
--   <a>zipApp</a> is the inverse of <a>unzipApp</a>.
zipApp :: Expr t -> [(Expr t, t)] -> Expr t

-- | Collect a curried application into the function and argument list.
--   
--   The type accompanying each argument represents type produced by the
--   application, and is extracted from the <a>App</a> node that this
--   function unwraps.
--   
--   For example, the term <tt>f a b</tt> (where <tt>a: A</tt> and <tt>b:
--   B</tt>) would be represented by the following AST: @<tt> (App (App
--   (Var f (A -&gt; B -&gt; C)) (Var a A) (B -&gt; C)) (Var b B) C) </tt>@
--   
--   which, when unzipped, gives:
--   
--   @<tt> (Var f (A -&gt; B -&gt; C)) [(Var a A, B -&gt; C), (Var b B, C)]
--   </tt>@
--   
--   <a>unzipApp</a> is the inverse of <a>zipApp</a>.
unzipApp :: Expr t -> (Expr t, [(Expr t, t)])
instance Data.Data.Data IR.IR.Literal
instance GHC.Show.Show IR.IR.Literal
instance GHC.Classes.Eq IR.IR.Literal
instance Data.Data.Data IR.IR.PrimOp
instance GHC.Show.Show IR.IR.PrimOp
instance GHC.Classes.Eq IR.IR.PrimOp
instance Data.Data.Data IR.IR.Primitive
instance GHC.Show.Show IR.IR.Primitive
instance GHC.Classes.Eq IR.IR.Primitive
instance Data.Data.Data IR.IR.Alt
instance GHC.Show.Show IR.IR.Alt
instance GHC.Classes.Eq IR.IR.Alt
instance Data.Data.Data t => Data.Data.Data (IR.IR.Expr t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Expr t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Expr t)
instance Data.Data.Data t => Data.Data.Data (IR.IR.Program t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Program t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Program t)
instance GHC.Base.Functor IR.IR.Program
instance (Prettyprinter.Internal.Pretty t, IR.Types.TypeSystem.TypeSystem t) => Prettyprinter.Internal.Pretty (IR.IR.Program t)
instance (Common.Pretty.Dumpy t, IR.Types.TypeSystem.TypeSystem t) => Common.Pretty.Dumpy (IR.IR.Program t)
instance GHC.Base.Functor IR.IR.Expr
instance Control.Comonad.Comonad IR.IR.Expr
instance Data.Foldable.Foldable IR.IR.Expr
instance Prettyprinter.Internal.Pretty (IR.IR.Expr ())
instance Common.Pretty.Dumpy t => Common.Pretty.Dumpy (IR.IR.Expr t)
instance Prettyprinter.Internal.Pretty IR.IR.Alt
instance Common.Pretty.Dumpy IR.IR.Alt
instance Prettyprinter.Internal.Pretty IR.IR.PrimOp
instance Common.Pretty.Dumpy IR.IR.PrimOp
instance Prettyprinter.Internal.Pretty IR.IR.Literal
instance Common.Pretty.Dumpy IR.IR.Literal


-- | Infer types for optionally annotated program.
--   
--   For now, this module implements a very crude form of pure,
--   syntax-directed type inference where type annotations can be locally
--   and immediately inferred, without the help of a type
--   environment/context.
module IR.TypeChecker

-- | Typing Environment
data TypeCtx
TypeCtx :: Map VarId Type -> Map DConId Type -> TypeCtx
[varMap] :: TypeCtx -> Map VarId Type
[dConMap] :: TypeCtx -> Map DConId Type
newtype InferFn a
InferFn :: StateT TypeCtx Pass a -> InferFn a

-- | Run a InferFn computation.
runInferFn :: InferFn a -> Pass a

-- | Insert a variable ID and its type into current typing context.
insertVar :: VarId -> Type -> InferFn ()

-- | Replace the current typing context with a new one.
replaceCtx :: TypeCtx -> InferFn ()

-- | Look up the type of a variable in the current typing context given its
--   variable ID.
lookupVar :: VarId -> InferFn (Maybe Type)

-- | Look up the type of a data constructor in the typing context.
lookupDCon :: DConId -> InferFn (Maybe Type)

-- | Infer all the program defs of the given program.
inferProgram :: Program Type -> Pass (Program Type)

-- | Pass all program typeDefs through the typechecker
--   
--   Change Ann.Type to Classes.Type For each ADT, save ('DConId, 'TConId)
--   key-value pairs in typing context for future use
inferADT :: [(TConId, TypeDef Type)] -> InferFn [(TConId, TypeDef Type)]
inferExterns :: [(VarId, Type)] -> InferFn [(VarId, Type)]

-- | Top level inference.
--   
--   This will infer the (VarId, Expr) pair sequentially and add the
--   infered types into the type context so that these info can be used
--   when infering the following expressions.
inferProgramDefs :: [(VarId, Expr Type)] -> InferFn [(VarId, Expr Type)]

-- | Infer a single expression <tt>e</tt>.
--   
--   This function will also infer any nested expressions inside <tt>e</tt>
--   and all expressions in the return value will have Classes.Type as its
--   type. Error will be thrown if the type annotation is in inconsistent
--   with the true true or the expression is known.
inferExpr :: Expr Type -> InferFn (Expr Type)

-- | Infer the type of a Primitive expression.
inferPrim :: Expr Type -> InferFn (Expr Type)

-- | Check type of a binary integer operation.
inferPrimBinop :: PrimOp -> Expr Type -> Expr Type -> InferFn (Expr Type)

-- | Helper function to support local modificaton of type context.
withNewScope :: InferFn a -> InferFn a

-- | Helper function to do type inference with the knowledge of the correct
--   type for a binding.
withVty :: Expr Type -> Binder -> Type -> InferFn ()

-- | Transfrom an Ann.Type to Classes.Type.
anns2Class :: Type -> InferFn Type
ann2Class :: TypeAnnote -> InferFn Type
instance Control.Monad.State.Class.MonadState IR.TypeChecker.TypeCtx IR.TypeChecker.InferFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.TypeChecker.InferFn
instance Control.Monad.Fail.MonadFail IR.TypeChecker.InferFn
instance GHC.Base.Monad IR.TypeChecker.InferFn
instance GHC.Base.Applicative IR.TypeChecker.InferFn
instance GHC.Base.Functor IR.TypeChecker.InferFn


-- | Substitute AST nodes with magical primitives.
module IR.SubstMagic

-- | Substitute AST nodes with magical primitives.
--   
--   Implemented as a syb-style generic tree traversal.
--   
--   Example usage:
--   
--   @@ -- Given: myExpr :: Expr Poly.Type
--   
--   <ul>
--   <li>- Do: substMagic (Proxy :: Proxy Poly.Type) myExpr</li>
--   <li>- Given: myProm :: Program Annotated.Type</li>
--   <li>- Do: substMagic (Proxy :: Proxy Annotated.Type) myProg @@</li>
--   </ul>
substMagic :: (TypeSystem t, Data t, Data a) => Proxy t -> a -> a


-- | Lower the representation of a sslang Ast into sslang IR.
--   
--   This pass expects prior desugaring passes to ensure that:
--   
--   <ul>
--   <li>Op regions are unflatted into proper applications.</li>
--   <li>Patterns in definitions consist of only (annotated) identifiers or
--   wildcards.</li>
--   </ul>
module IR.LowerAst

-- | Lower an AST <tt>Program</tt> into IR.
lowerProgram :: Program -> Pass (Program Type)


-- | Lift lambda definitions into the global scope.
--   
--   This pass is responsible for moving nested lambda definitions into the
--   global scope and performing necessary callsite adjustments.
module IR.LambdaLift

-- | Entry-point to lambda lifting.
--   
--   Maps over top level definitions and lifts out lambda definitions to
--   create a new Program with the relative order of user definitions
--   preserved.
liftProgramLambdas :: Program Type -> Pass (Program Type)
instance Control.Monad.State.Class.MonadState IR.LambdaLift.LiftCtx IR.LambdaLift.LiftFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.LambdaLift.LiftFn
instance Control.Monad.Fail.MonadFail IR.LambdaLift.LiftFn
instance GHC.Base.Monad IR.LambdaLift.LiftFn
instance GHC.Base.Applicative IR.LambdaLift.LiftFn
instance GHC.Base.Functor IR.LambdaLift.LiftFn


-- | Insert reference counting primitives.
module IR.InsertRefCounting

-- | Entry-point to insert dup/drops.
insertRefCounting :: Program Type -> Pass (Program Type)

module IR.ClassInstantiation
instProgram :: Program Type -> Pass (Program Type)


-- | Infer types for IR of optionally annotated program using Hindley
--   Milner type inference algorithm with union find tree data structure.
--   
--   There are three main stages of the algorithm 1. Assign symbolic
--   typenames During this stage, we walk through each expression
--   recursively, initialize its type by either assigning a fresh type
--   variable or looking it up in the type context at that point, and
--   generate a list of type equations to record the relationships between
--   types. We also collapse the list of type annotations into the most
--   specific one and put that information into a type equation as well to
--   bring it into the later inference. Note that we will be modifying the
--   expression monad simultaneously to record its new type info. 2. Solve
--   type equations using unification. During this stage, we solve the type
--   equations generated in the last stage and build a union find tree.
--   This stage should be merged with stage 1 in the future. 3. Find the
--   type of the expression. During this stage, we walk through each
--   expression recursively and assign it with its inferred type by loop up
--   the root of its temporary type in the union find tree.
--   
--   The three stages are encaptured by the functions <a>initTypeVars</a>,
--   <a>unifyAll</a>, and <a>getType</a>.
--   
--   TODO: - Define a partial order for the generality of types. The order
--   will be used to (1) collapse type annotations into the most specific
--   one; (2) check that type annotation is equal to or more specific than
--   the expression's inferred type. - Handle recursive function correctly.
module IR.HM

-- | Inference State.
data InferState
InferState :: Map VarId Scheme -> [(Type, Type)] -> Map Type Type -> Int -> Map DConId (TConId, [TVarId], [Type]) -> InferState
[varMap] :: InferState -> Map VarId Scheme
[equations] :: InferState -> [(Type, Type)]
[unionFindTree] :: InferState -> Map Type Type
[count] :: InferState -> Int
[dConType] :: InferState -> Map DConId (TConId, [TVarId], [Type])

-- | Inference Monad.
newtype InferFn a
InferFn :: StateT InferState Pass a -> InferFn a

-- | Run a InferFn computation.
runInferFn :: InferFn a -> Pass a

-- | <a>inferProgram</a> <tt>p</tt> infers the type of all the programDefs
--   of the given program <tt>p</tt>.
inferProgram :: Program Type -> Pass (Program Type)

-- | <a>recordFDefs</a> saves information about all the declared functions
--   for future use
recordFDefs :: [(VarId, Expr Type)] -> InferFn ()

-- | <a>recordADTs</a> saves information about ADTs in the Inference State
--   for future use
--   
--   saves type of DCon as a (DCon,TCon) key-value pair transforms Ann.Type
--   to Classes.Type saves types of DCon args (the ADT fields) as (DCon,
--   [type]) key-value pairs
recordADTs :: [(TConId, TypeDef Type)] -> InferFn [(TConId, TypeDef Type)]

-- | <tt>insertType</tt> inserts the overall type of an ADT's
--   <tt>DConid</tt> into the Inference State
recordDCon :: TConId -> [TVarId] -> (DConId, TypeVariant Type) -> InferFn ()

-- | Record the types of extern symbols. NOTE: this does not actually check
--   for arity and probably doesn't do polymorphism correctly either.
recordExterns :: [(VarId, Type)] -> InferFn [(VarId, Type)]

-- | <a>inferProgramDefs</a> <tt>ds</tt> infers the type of programDefs
--   <tt>ds</tt> recursively and binds each varibale to its type.
inferProgramDefs :: [(VarId, Expr Type)] -> InferFn [(VarId, Expr Type)]

-- | <a>initAllTypeVars</a> initialize all the funcitons' type at once
initAllTypeVars :: [(VarId, Expr Type)] -> InferFn [(VarId, Expr Type)]

-- | <a>getAllTypes</a> replace all the type variables in the initial
--   funciton types
getAllTypes :: [(VarId, Expr Type)] -> InferFn [(VarId, Expr Type)]

-- | Class of things that may contain free type variables.
class HasFreeTVars a
freeTVars :: HasFreeTVars a => a -> Set TVarId

-- | Instantiates the type from the scheme <tt>Forall vs t</tt>.
--   
--   Create fresh type variable for each quantified type variable in
--   <tt>vs</tt> and substitute them in <tt>t</tt> by applying
--   <tt>subst</tt> to <tt>t</tt>.
instantiate :: Scheme -> InferFn Type

-- | Generalizes the type <tt>t</tt> into a type scheme given the typing
--   context <tt>ctx</tt>.
--   
--   Collect all the free type variables in the type <tt>t</tt> and all the
--   free type variables in the typing context <tt>ctx</tt>, away any type
--   variables that appear free in the type environment, and whatever is
--   leftover can be generalized into a type scheme.
generalize :: Type -> InferFn Scheme

-- | <a>letters</a> represents list of identifiers to be used to construct
--   free type variables assigned during type inference. The leading '_'
--   distinguish them from user-annotated type variables.
letters :: [String]

-- | <tt>dummyAnnT</tt> represents empty type annotation list.
dummyAnnT :: Type

-- | Generates a new <tt>TVar</tt> using the next tick number and increment
--   the counter.
fresh :: InferFn Type

-- | <a>lookupVar</a> <tt>v</tt> looks up the type scheme of a variable in
--   the current <a>varMap</a> given its variable ID <tt>v</tt>.
lookupVar :: VarId -> InferFn (Maybe Scheme)

-- | Look up the type of a data constructor in the inference state.
lookupDCon :: DConId -> InferFn (Maybe Scheme)

-- | <a>insertVar</a> <tt>v t</tt> Insert a variable ID and its type scheme
--   into current <a>varMap</a>.
insertVar :: VarId -> Scheme -> InferFn ()

-- | <a>insertBinder</a> is a wrapper of <a>insertVar</a> for <a>Binder</a>
--   type.
insertBinder :: Binder -> Scheme -> InferFn ()

-- | <a>insertEquation</a> <tt>e</tt> inserts <tt>e</tt> into the current
--   <a>equations</a> list.
insertEquation :: (Type, Type) -> InferFn ()

-- | <a>insertUnion</a> <tt>t1 t2</tt> inserts <tt>t1 : t2</tt> into the
--   current <a>unionFindTree</a>.
insertUnion :: Type -> Type -> InferFn ()

-- | Helper function to support local modificaton of <a>varMap</a>.
withNewScope :: InferFn a -> InferFn a

-- | Helper function to support local modificaton of <a>unionFindTree</a>.
withNewTypeScope :: InferFn a -> InferFn a

-- | Helper function to collapse a list of type annotation to a single one
--   with 'Classes.type' type. If the list is empty, use <tt>Classes.TVar
--   (TVarId $ Identifier "_"))</tt> to denote a dummy annotation. TODO:
--   Currently just take the first type annotation of the list as the
--   result. Need to implement the <tt>collapse</tt> step to find and
--   return the most specific type annotation from the list. Need yo add
--   support for annotating type variables as well.
collapseAnnT :: Type -> Type

-- | Stage 1: Assign symbolic typenames
--   
--   <a>initTypeVars</a> <tt>e</tt> walks into the expression <tt>e</tt>
--   recursively, assign a fresh <tt>TVar</tt> to each unknown type, and
--   build type equations that will be solved later.
initTypeVars :: Expr Type -> InferFn (Expr Type)

-- | Infer the type of a binary integer operation.
inferPrimBinop :: PrimOp -> Expr Type -> Expr Type -> Type -> InferFn (Expr Type)

-- | <tt>typeCheck annT expectedT</tt> checks whether the type annotation
--   <tt>annT</tt> is compatible with the expected type <tt>expectedT</tt>.
--   Insert new type equations when the expected type is a type variable.
--   TODO: currently only consider equality as compatibility. Need to
--   support the case when type annotation is more specific than the
--   expected type.
typeCheck :: Type -> Type -> InferFn Type

-- | Stage 2: Solve type equations using unification.
--   
--   Solve the list of <a>equations</a> one by one and puts solutions as
--   new enties in the <a>unionFindTree</a>.
unifyAll :: InferFn ()

-- | <a>unify</a> <tt>t1 t2</tt> solves the type equation t1 ~ t2 and put
--   the solution into <a>unionFindTree</a>.
unify :: Type -> Type -> InferFn ()

-- | Stage 3: Find the type of the expression based on
--   <a>unionFindTree</a>.
--   
--   <a>getType</a> <tt>e</tt> walks into the expression <tt>e</tt> and
--   solves its type <tt>t</tt> recursively.
getType :: Expr Type -> InferFn (Expr Type)

-- | Recursively get type of operands to PrimOp, then apply given type.
getTypePrimOp :: PrimOp -> [Expr Type] -> Type -> InferFn (Expr Type)

-- | <a>solveType</a> <tt>t</tt> solves the type <tt>t</tt> by replacing
--   any embeded <tt>TVar</tt> <tt>tvar</tt> with its real type, which is
--   the root of <tt>tvar</tt> in the <a>unionFindTree</a>.
solveType :: Type -> InferFn Type

-- | <a>findRoot</a> <tt>t</tt> finds the root of <tt>t</tt> inside
--   <a>unionFindTree</a>.
findRoot :: Type -> InferFn Type
instance Control.Monad.State.Class.MonadState IR.HM.InferState IR.HM.InferFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.HM.InferFn
instance Control.Monad.Fail.MonadFail IR.HM.InferFn
instance GHC.Base.Monad IR.HM.InferFn
instance GHC.Base.Applicative IR.HM.InferFn
instance GHC.Base.Functor IR.HM.InferFn
instance IR.HM.HasFreeTVars Common.Identifiers.TVarId
instance IR.HM.HasFreeTVars IR.Types.Classes.Scheme
instance IR.HM.HasFreeTVars IR.Types.Classes.Type
instance IR.HM.HasFreeTVars t => IR.HM.HasFreeTVars (IR.Types.TypeSystem.Builtin t)
instance IR.HM.HasFreeTVars a => IR.HM.HasFreeTVars [a]


-- | Turns non-nullary data constructors into calls to constructor
--   functions.
module IR.ExternToCall

-- | <a>externToCall</a> modifies programDefs and traverses the IR to
--   accomplish two tasks:
--   
--   <ol>
--   <li>Add top-level constructor functions for each non-nullary
--   <tt>DCon</tt> to progamDefs</li>
--   <li>Turn non-nullary data constuctors into calls to top level
--   constructor funcs</li>
--   </ol>
externToCall :: Program Type -> Pass (Program Type)
instance Control.Monad.Reader.Class.MonadReader IR.ExternToCall.ExternEnv IR.ExternToCall.ExternFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.ExternToCall.ExternFn
instance Control.Monad.Fail.MonadFail IR.ExternToCall.ExternFn
instance GHC.Base.Monad IR.ExternToCall.ExternFn
instance GHC.Base.Applicative IR.ExternToCall.ExternFn
instance GHC.Base.Functor IR.ExternToCall.ExternFn


-- | Turns non-nullary data constructors into calls to constructor
--   functions.
--   
--   Worked example of ADT definition and corresponding constructor
--   functions:
--   
--   <pre>
--   type Shape 
--     Square Int 
--     Rect Int Int
--   </pre>
--   
--   Let's turn data constructor <tt>Square</tt> into constructor function
--   <tt>__Square</tt>:
--   
--   <pre>
--   __Square arg0 : Int -&gt; Shape =  Square arg0
--   </pre>
--   
--   The difference is that <tt>Square</tt> cannot be partially-applied,
--   whereas <tt>__Square</tt> can.
--   
--   Next, <tt>Rect</tt> turns into this:
--   
--   <pre>
--   __Rect arg0 arg1 : Int -&gt; Int -&gt; Shape =  Rect arg0 arg1
--   </pre>
--   
--   The difference is that <tt>Rect</tt> cannot be partially-applied,
--   whereas <tt>__Rect</tt> can.
--   
--   Representing constructor functions in the IR:
--   
--   Every top-level function has the form (I.VarId, I.Expr Poly.Type) =
--   (functionName, functionBody) The function body is a lambda expression
--   representing a call to the fully applied data constructor.
--   
--   Let's turn the top-level func for <tt>Square</tt> into IR:
--   
--   <pre>
--   (__Square, body) 
--   body = fun arg0 { App L R t } : Int -&gt; Shape
--    where L = Square : Int -&gt; Shape
--          R = arg0 : type Int
--          t = Shape, because the type of a fully applied data constructor
--              is its type constructor@
--   </pre>
--   
--   Next <tt>Rect</tt> turns into this:
--   
--   <pre>
--   (Rect, body)
--   body = fun arg0 { fun arg1 { App L R t } : Int -&gt; Shape } : Int -&gt; Int -&gt; Shape
--    where L = App L2 R2 t
--          R = arg1 : Int
--          t = Shape, because the type of a fully applied data constructor 
--              is its type constructor
--           where L2 = Rect : Int -&gt; Int -&gt; Shape
--                 R  = arg0 : Int
--                 t = Int -&gt; Shape, because at this point in the inner App, 
--                     Rect is partially applied with only 1 arg.
--   </pre>
module IR.DConToFunc

-- | <a>dConToFunc</a> modifies programDefs and traverses the IR to
--   accomplish two tasks:
--   
--   <ol>
--   <li>Add top-level constructor functions for each non-nullary
--   <tt>DCon</tt> to progamDefs</li>
--   <li>Turn non-nullary data constuctors into calls to top level
--   constructor funcs</li>
--   </ol>
dConToFunc :: Program Type -> Pass (Program Type)
instance Control.Monad.Reader.Class.MonadReader IR.DConToFunc.ArityEnv IR.DConToFunc.ArityFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.DConToFunc.ArityFn
instance Control.Monad.Fail.MonadFail IR.DConToFunc.ArityFn
instance GHC.Base.Monad IR.DConToFunc.ArityFn
instance GHC.Base.Applicative IR.DConToFunc.ArityFn
instance GHC.Base.Functor IR.DConToFunc.ArityFn


-- | Intermediate representation (IR) stage of the compiler pipeline.
--   
--   The IR stage is organized into 4 distinct substages: <a>lower</a>,
--   <a>ann2Class</a>, <a>class2Poly</a>, and <tt>poly2Flat</tt>,
--   delineated by each type system used in the compiler.
module IR

-- | Operation modes for the IR compiler stage.
data Mode

-- | Compile end-to-end (default).
Continue :: Mode

-- | Print the IR immediately after lowering.
DumpIR :: Mode

-- | Print the fully-typed IR after type inference.
DumpIRTyped :: Mode

-- | Print the IR after lambda lifting.
DumpIRLifted :: Mode

-- | Print the final IR representation before codegen.
DumpIRFinal :: Mode
data TIType

-- | Only run HM type inference
HMOnly :: TIType

-- | Only run type checker
TCOnly :: TIType

-- | Run both HM type Inference and type checker
Both :: TIType

-- | Compiler options for the IR compiler stage.
data Options
Options :: Mode -> TIType -> Options
[mode] :: Options -> Mode
[tiType] :: Options -> TIType

-- | CLI options for the IR compiler stage.
options :: [OptDescr (Options -> Options)]

-- | IR compiler sub-stage, lowering AST to optionally type-annotated IR.
lower :: Options -> Program -> Pass (Program Type)

-- | IR compiler sub-stage, ultimately producing a fully-typed IR.
--   
--   Runs HM inference, type checker, or both (default) based on the CLI
--   option.
--   
--   When both algorithms are run, the program fails type check iff both
--   algorithms throw an error.
ann2Class :: Options -> Program Type -> Pass (Program Type)

-- | IR compiler sub-stage, ultimately instantiating all type classes.
class2Poly :: Options -> Program Type -> Pass (Program Type)

-- | IR compiler sub-stage, performing source-to-source translations.
poly2Poly :: Options -> Program Type -> Pass (Program Type)

-- | IR compiler stage.
run :: Options -> Program -> Pass (Program Type)

-- | Helper function to set ti type to HM-only
setHM :: Options -> Options

-- | Helper function to set ti type to TC-only
setTC :: Options -> Options
instance GHC.Show.Show IR.Mode
instance GHC.Classes.Eq IR.Mode
instance GHC.Show.Show IR.TIType
instance GHC.Classes.Eq IR.TIType
instance GHC.Show.Show IR.Options
instance GHC.Classes.Eq IR.Options
instance Common.Default.Default IR.Options


-- | Extract and encapsulate the type information needed during codegen.
module Codegen.Typegen

-- | Type-related information, abstracted behind partial lookup functions.
data TypegenInfo
TypegenInfo :: (DConId -> Maybe DConInfo) -> (TConId -> Maybe TConInfo) -> TypegenInfo

-- | for each data constructor.
[dconInfo] :: TypegenInfo -> DConId -> Maybe DConInfo

-- | for each type constructor.
[tconInfo] :: TypegenInfo -> TConId -> Maybe TConInfo

-- | Information and codegen handlers associated with each data
--   constructor.
data DConInfo
DConInfo :: TConId -> Int -> Bool -> Exp -> Exp -> (Int -> Exp -> Exp) -> DConInfo

-- | the type that the data constructor inhabits
[dconType] :: DConInfo -> TConId

-- | number of fields
[dconSize] :: DConInfo -> Int

-- | whether the data constructor is heap-allocated
[dconOnHeap] :: DConInfo -> Bool

-- | the dcon tag to match on, i.e., in <tt>case tag</tt>
[dconCase] :: DConInfo -> Exp

-- | constructs a dcon instance
[dconConstruct] :: DConInfo -> Exp

-- | retrieve the ith field
[dconDestruct] :: DConInfo -> Int -> Exp -> Exp

-- | Information and codegen handlers associated with each type
--   constructor.
data TConInfo
TConInfo :: TypeEncoding -> (Exp -> Exp) -> TConInfo

-- | how the data type is encoded
[typeEncoding] :: TConInfo -> TypeEncoding

-- | how to retrieve the tag of an instance
[typeScrut] :: TConInfo -> Exp -> Exp

-- | How a data type may be encoded, i.e., heap-allocated, by value, or
--   both.
data TypeEncoding
TypePacked :: TypeEncoding
TypeHeap :: TypeEncoding
TypeMixed :: TypeEncoding

-- | Create codegen definitions and helpers for sslang type definitions.
genTypes :: [(TConId, TypeDef Type)] -> Pass ([Definition], TypegenInfo)

-- | Generate C enums for sslang type definitions, enumerating tags.
genTypeDef :: (TConId, TypeDef Type) -> Pass Definition

-- | Compute codgen helpers for each sslang type definition.
genTypeInfo :: [(TConId, TypeDef Type)] -> Pass TypegenInfo


-- | Translate SSM program to C compilation unit.
--   
--   What is expected of the IR:
--   
--   Well-formed: All primitive functions are applied to the right number
--   of arguments.
--   
--   Pure par expression: All par-expressions' operands are applications
--   that have no side effects.
--   
--   Defunctionalized: No lambdas; the only terms with an arrow type are
--   variables or applications.
--   
--   Name mangled: All variable identifiers are unique.
module Codegen.Codegen

-- | Possible, but temporarily punted for the sake of expediency.
todo :: HasCallStack => a

-- | Impossible without a discussion about implementation strategy.
nope :: HasCallStack => a

-- | Hack to allow us to splice string literals into C AST
newtype EscExp
EscExp :: String -> EscExp

-- | State maintained while compiling a top-level SSM function.
--   
--   The information here is populated while generating the step function,
--   so that should be computed first, before this information is used to
--   generate the act struct and enter definitions.
data GenFnState
GenFnState :: VarId -> [(Binder, Type)] -> Type -> Expr Type -> Map VarId Type -> Map VarId Exp -> Int -> Int -> Int -> TypegenInfo -> GenFnState

-- | Function name
[fnName] :: GenFnState -> VarId

-- | Function parameters
[fnParams] :: GenFnState -> [(Binder, Type)]

-- | Function return type
[fnRetTy] :: GenFnState -> Type

-- | Function body
[fnBody] :: GenFnState -> Expr Type

-- | Function local variables
[fnLocals] :: GenFnState -> Map VarId Type

-- | How to resolve variables
[fnVars] :: GenFnState -> Map VarId Exp

-- | Number of triggers needed
[fnMaxWaits] :: GenFnState -> Int

-- | Yield point counter
[fnCases] :: GenFnState -> Int

-- | Temporary variable name counter
[fnFresh] :: GenFnState -> Int

-- | (User-defined) type information
[fnTypeInfo] :: GenFnState -> TypegenInfo

-- | Translation monad for procedures, with derived typeclass instances.
--   
--   We declare <a>GenFn</a> as a newtype so that we can implement
--   <a>MonadFail</a> for it, allowing us to use monadic pattern matching.
newtype GenFn a
GenFn :: StateT GenFnState Pass a -> GenFn a

-- | Run a <a>GenFn</a> computation on a procedure.
runGenFn :: VarId -> [(Binder, Type)] -> Type -> Expr Type -> TypegenInfo -> [(VarId, Type)] -> GenFn a -> Pass a

-- | Lookup some information associated with a type constructor.
getsTCon :: (TConInfo -> a) -> TConId -> GenFn a

-- | Lookup some information associated with a data constructor.
getsDCon :: (DConInfo -> a) -> DConId -> GenFn a

-- | Read and increment the number of cases in a procedure, i.e.,
--   <tt>fnCases++</tt>.
nextCase :: GenFn Int

-- | Obtain fresh integer in the <a>GenFn</a> monad
getFresh :: GenFn Int

-- | Bind a variable to a C expression.
addBinding :: Binder -> Exp -> GenFn ()

-- | Register a new local variable, to be declared in activation record.
addLocal :: VarId -> Type -> GenFn VarId

-- | Bind a variable to a C expression only while computing the given
--   monad.
withBindings :: [(Binder, Exp)] -> GenFn a -> GenFn a

-- | Register a local variable and bind its C expression during a monad.
withNewLocal :: (VarId, Type) -> GenFn a -> GenFn a

-- | Register number of wait statements track of number of triggers needed.
maxWait :: Int -> GenFn ()

-- | Generate a fresh label.
freshLabel :: GenFn CIdent

-- | Generate anonymous local variable in activation record for storage.
genTmp :: Type -> GenFn Exp

-- | Translate a list of SSM parameters to C parameters.
genParams :: [(Binder, Type)] -> [(CIdent, Type)]

-- | Translate a list of SSM local declarations to C declarations.
genLocals :: [(VarId, Type)] -> [(CIdent, Type)]

-- | Generate declarations for <tt>numTrigs</tt> triggers.
genTrigs :: Int -> [(CIdent, Type)]

-- | The constant unit value, the singleton inhabitant of the type Unit.
unit :: Exp

-- | Fake undefined value used for expressions of type Void.
undef :: Exp

-- | Generate a C compilation from an SSM program.
--   
--   Each top-level function in a program is turned into three components:
--   
--   <ol>
--   <li>a struct (the activation record);</li>
--   <li>an initialization function (the enter function); and</li>
--   <li>a step function, which corresponds to the actual procedure
--   body.</li>
--   </ol>
--   
--   Items 2 and 3 include both declarations and definitions.
genProgram :: Program Type -> Pass [Definition]

-- | Include statements in the generated C file.
includes :: [Definition]

-- | Setup the entry point of the program.
genInitProgram :: VarId -> [Definition]
genExtern :: (VarId, Type) -> Pass Definition

-- | Generate struct definition for an SSM procedure.
--   
--   This is where local variables, triggers, and parameter values are
--   stored.
genStruct :: GenFn Definition

-- | Generate the enter function for an SSM procedure and its signature.
--   
--   Its struct is allocated and initialized (partially; local variables'
--   values are left uninitialized).
genEnter :: GenFn (Definition, Definition)

-- | Generate static closure for top-level function
genStaticClosure :: GenFn (Definition, Definition)

-- | Generate the step function for an SSM procedure.
--   
--   This function just defines the function definition and switch
--   statement that wraps the statements of the procedure. The heavy
--   lifting is performed by <a>genExpr</a>.
genStep :: GenFn (Definition, Definition)

-- | Helper to generate yield point in step function.
genYield :: GenFn [BlockItem]

-- | Translate an SSM expression into a C expression and statements.
--   
--   SSM IR is a side-effectful expression language, with two implications
--   when translating to C:
--   
--   <ol>
--   <li>every expression has a value (even if it is an uninhabited type),
--   so this must be reflected in C; and</li>
--   <li>some of the side effects in SSM cannot be implemented in C using
--   expressions alone.</li>
--   </ol>
--   
--   These two implications roughly translate to the <tt>C.Exp</tt> and
--   <tt>[C.BlockItem]</tt> in <tt>genExpr</tt>'s return type. When we
--   translate an SSM expression <tt>e</tt>:
--   
--   <pre>
--   (val, stms) &lt;- genExpr e
--   </pre>
--   
--   <tt>val</tt> represents the C expression that corresponds to the value
--   of <tt>e</tt> upon evaluation, while <tt>stms</tt> represents the list
--   of preceding statements that compute <tt>val</tt>.
--   
--   A further consideration upon point 2 is that SSM expressions may yield
--   control at any point. Thus, the C expression returned by
--   <tt>genExpr</tt> must accommodate the step function suspending and
--   resuming. For instance, consider the following SSM IR expression:
--   
--   <pre>
--   (let x = 3 in x) + (wait r; 6)
--   </pre>
--   
--   The <tt>x</tt> in the let-binding in the left operand cannot just be a
--   local variable in the step function, because it would be
--   "uninitialized" by the yield in the right operand:
--   
--   <pre>
--     // let x = 3 in x
--     // stms:
--     int x = 3;
--     // exp: x
--   
--     // (wait r; 6)
--     // stms:
--     ssm_sensitize(r);
--     actg-&gt;pc = N;
--     return;
--   case N:
--     ssm_desensitize(r);
--     // exp: 6
--   
--     // After the return, x is no longer initialized, so the following is
--     // undefined behavior:
--     x + 6
--   </pre>
--   
--   To ensure this is cannot happen, we conservatively declare <tt>x</tt>
--   as a local variable in the activation record, so that its value is
--   preserved between yields, even if this is not usually necessary. We
--   leave it to later compiler passes to optimize this.
genExpr :: Expr Type -> GenFn (Exp, [BlockItem])

-- | Generate code for SSM primitive; see <a>genExpr</a> for extended
--   discussion.
genPrim :: Primitive -> [Expr Type] -> Type -> GenFn (Exp, [BlockItem])

-- | Generate C value for SSM literal, marshalled.
genLiteral :: Literal -> Exp

-- | Generate C value for SSM literal, unmarshalled.
genLiteralRaw :: Literal -> Exp

-- | Generate C expression for SSM primitive operation.
genPrimOp :: PrimOp -> [Expr Type] -> Type -> GenFn (Exp, [BlockItem])

-- | Helper for sequencing across binary operations.
genBinop :: Expr Type -> Expr Type -> GenFn ((Exp, Exp), [BlockItem])

-- | Compute priority and depth arguments for a par fork of given width.
genParArgs :: Int -> (Exp, Exp) -> [(Exp, Exp)]

-- | How much the depth should be decreased when par forking given width.
depthSub :: Int -> Exp
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Codegen.Codegen.GenFn
instance Control.Monad.State.Class.MonadState Codegen.Codegen.GenFnState Codegen.Codegen.GenFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Codegen.Codegen.GenFn
instance Control.Monad.Fail.MonadFail Codegen.Codegen.GenFn
instance GHC.Base.Monad Codegen.Codegen.GenFn
instance GHC.Base.Applicative Codegen.Codegen.GenFn
instance GHC.Base.Functor Codegen.Codegen.GenFn
instance Language.C.Quote.Base.ToExp Codegen.Codegen.EscExp


-- | Code generation (codegen) stage of the compiler pipeline.
--   
--   This module exposes some options for configuring what C code is
--   generated and how it is represented.
module Codegen

-- | Operation modes for the codegen compiler stage.
data Mode
Continue :: Mode

-- | Compiler options for the codegen compiler stage.
data Options
Options :: Mode -> Int -> Options
[mode] :: Options -> Mode
[textWidth] :: Options -> Int

-- | CLI options for the codegen compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Codegen compiler stage.
run :: Options -> Program Type -> Pass String
instance GHC.Show.Show Codegen.Mode
instance GHC.Classes.Eq Codegen.Mode
instance GHC.Show.Show Codegen.Options
instance GHC.Classes.Eq Codegen.Options
instance Common.Default.Default Codegen.Options
