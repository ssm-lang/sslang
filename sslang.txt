-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/sedwards-lab/sslang#README</a>
@package sslang
@version 0.1.0.0


-- | Module for the <a>Default</a> type class.
module Common.Default

-- | Types with default values.
class Default a
def :: Default a => a


-- | Helpers for pretty-printing sslang, including common ASCII tokens.
module Common.Pretty

-- | <tt>typeAnn t d</tt> annotates document <tt>d</tt> with type
--   annotation <tt>t</tt>.
--   
--   Only used by spaghetti so constrained by Dumpy instead of Pretty for
--   now.
typeAnn :: Dumpy t => t -> Doc ann -> Doc ann

-- | <pre>
--   =&gt;
--   </pre>
drarrow :: Doc ann

-- | <pre>
--   &lt;-
--   </pre>
larrow :: Doc ann

-- | <pre>
--   -&gt;
--   </pre>
rarrow :: Doc ann

-- | <pre>
--   ||
--   </pre>
dbar :: Doc ann

-- | <pre>
--   |
--   </pre>
bar :: Doc ann

-- | <pre>
--   &amp;
--   </pre>
amp :: Doc ann

-- | Constructs a separator-delimited block <a>Doc</a> out of a list of
--   <a>Doc</a>s.
block :: Doc ann -> [Doc ann] -> Doc ann

-- | Number of spaces to indent
indentNo :: Int

-- | Format with a document of infinite width, preventing wraparound.
spaghetti :: Dumpy t => t -> String

-- | Dumpy Typeclass: print an ugly but parseable representation of the AST
--   
--   <ul>
--   <li>Translates from IR to Doc representation in one-to-one
--   fashion</li>
--   <li>No simplifications</li>
--   <li>No whitespace formatting</li>
--   <li>Type annotates everything</li>
--   </ul>
class Dumpy a
dumpy :: Dumpy a => a -> Doc ann


-- | The types of identifiers used across the compiler.
--   
--   The types <a>VarId</a>, <a>TVarId</a>, <a>DConId</a>, and
--   <a>TConId</a> are used in the IR for data variables, type variables,
--   data constructors, and type constructors, which each inhabit a
--   separate namespace. The underlying <a>Identifier</a> type is used in
--   the AST, before these different kinds of identifiers are
--   differentiated by the lowering phase.
--   
--   These are defined as newtypes (rather than as type aliases) that
--   ultimately abstract over the underlying <a>String</a> Identifier. We
--   do this for a few reasons:
--   
--   <ul>
--   <li>The particular newtype carries semantic meaning in the IR, e.g.,
--   <a>VarId</a> is an identifier for data variables and nothing else.
--   This prevents semantically distinct items from being used in place of
--   one another (without explicit coercion). For example, this will
--   prevent accidentally using a type variable identifier as a data
--   constructor.</li>
--   <li>In the future, this may be extended to carry other (non-semantic)
--   metadata, such as source code location.</li>
--   <li>It allows us to freely attach typeclass instances to this type
--   without FlexibleInstances (since <a>String</a> is a type synonym for
--   <tt>[Char]</tt>).</li>
--   </ul>
--   
--   Users should never need to specifically use the data constructor for
--   each newtype, e.g., <tt>VarId (Identifier "foo")</tt>. Instead, each
--   identifier belongs to the <a>IsString</a> typeclass, that can be
--   written as <tt>fromString "foo"</tt>, so that the appropriate type can
--   be inferred from the context where the identifier is used.
--   Furthermore, the <a>fromString</a> call can be automatically inserted
--   by the OverloadedStrings GHC extension, meaning we can just write
--   <tt>"foo"</tt>.
--   
--   All identifier types are instances of the <a>Identifiable</a>
--   typeclass, which allows us to write generic functions that operate
--   over any kind of identifier. One can explicitly convert from an
--   identifier to another using the handy <a>fromId</a> helper; which
--   <i>specific</i> type of identifier may be inferred from the outer
--   context, or explicitly annotated (e.g., <tt>fromId i :: VarId</tt> to
--   construct a <a>VarId</a> out of identifier <tt>i</tt>).
module Common.Identifiers

-- | A type that may be used as a Sslang identifier.
class (IsString i, Ord i, Show i) => Identifiable i
ident :: Identifiable i => i -> String

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | Explicitly convert between two types of identifiers.
fromId :: (Identifiable a, Identifiable b) => a -> b

-- | Convert a showable instance to some kind of identifier.
showId :: (Show a, Identifiable b) => a -> b

-- | Identifier for type constructors, e.g., <tt>Option</tt>.
newtype TConId
TConId :: Identifier -> TConId

-- | ToIdentifier for type variable, e.g., <tt>a</tt>.
newtype TVarId
TVarId :: Identifier -> TVarId

-- | Identifier for data constructors, e.g., <tt>None</tt>.
newtype DConId
DConId :: Identifier -> DConId

-- | Identifier for data variables, e.g., <tt>x</tt>.
newtype VarId
VarId :: Identifier -> VarId

-- | de Bruijn index for type variables, e.g., <tt>'0</tt>
newtype TVarIdx
TVarIdx :: Int -> TVarIdx

-- | Identifier for C symbols, e.g., <tt>printf</tt>.
newtype CSym
CSym :: Identifier -> CSym

-- | Terms <tt>t</tt> that have free variables <tt>i</tt>
class Identifiable i => HasFreeVars t i | t -> i
freeVars :: HasFreeVars t i => t -> Set i

-- | A generic Sslang identifier.
--   
--   Used as the type for identifiers in the AST.
--   
--   Also used as the base type for other identifiers (e.g., <a>TConId</a>,
--   <a>VarId</a>), which derive their typeclass instances from this.
newtype Identifier
Identifier :: String -> Identifier

-- | Whether an identifier refers to a type or data constructor.
isCons :: Identifiable a => a -> Bool

-- | Whether an identifier refers to a type or data variable.
--   
--   Note that internal variables (i.e., <tt>isIVar</tt>) are also
--   considered variables.
isVar :: Identifiable a => a -> Bool

-- | Mangle all identifiers in some data structure.
--   
--   This function is useful for preserving the general syntactic structure
--   of a datum without inspecting the <i>specific</i> identifiers used
--   within. This is useful for comparing ASTs modulo alpha renaming.
--   
--   The <tt>Proxy i</tt> parameter is used to specify exactly which kind
--   of identifier to mangle. For instance, to mangle all <a>VarId</a>
--   nodes:
--   
--   <pre>
--   mangleVarId :: Data a =&gt; a -&gt; a
--   mangleVarId = mangle (Proxy :: VarId)
--   </pre>
mangle :: (Identifiable i, Data i, Data a) => Proxy i -> a -> a

-- | Mangle all type and data variable identifiers.
mangleVars :: Data a => a -> a

-- | Whether an identifier is an compiler-generated variable name.
isGenerated :: Identifiable a => a -> Bool

-- | Generate an internal variable name (parenthesized) from some hint.
genId :: Identifiable a => a -> a

-- | Filter out generated identifiers.
ungenId :: Identifiable a => a -> Maybe a

-- | the tuple identifier
tuple :: Identifier

-- | we'll use this temp tuple name for now due to the naming issue
tempTuple :: Identifier

-- | Cons identifier for Lists
cons :: Identifier

-- | Nil identifier for Lists
nil :: Identifier
instance Data.Data.Data Common.Identifiers.Identifier
instance GHC.Classes.Ord Common.Identifiers.Identifier
instance GHC.Classes.Eq Common.Identifiers.Identifier
instance Prettyprinter.Internal.Pretty Common.Identifiers.TConId
instance GHC.Base.Monoid Common.Identifiers.TConId
instance GHC.Base.Semigroup Common.Identifiers.TConId
instance Common.Identifiers.Identifiable Common.Identifiers.TConId
instance Data.String.IsString Common.Identifiers.TConId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.TConId
instance Data.Data.Data Common.Identifiers.TConId
instance GHC.Classes.Ord Common.Identifiers.TConId
instance GHC.Classes.Eq Common.Identifiers.TConId
instance Prettyprinter.Internal.Pretty Common.Identifiers.TVarId
instance GHC.Base.Monoid Common.Identifiers.TVarId
instance GHC.Base.Semigroup Common.Identifiers.TVarId
instance Common.Identifiers.Identifiable Common.Identifiers.TVarId
instance Data.String.IsString Common.Identifiers.TVarId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.TVarId
instance Data.Data.Data Common.Identifiers.TVarId
instance GHC.Classes.Ord Common.Identifiers.TVarId
instance GHC.Classes.Eq Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty Common.Identifiers.DConId
instance GHC.Base.Monoid Common.Identifiers.DConId
instance GHC.Base.Semigroup Common.Identifiers.DConId
instance Common.Identifiers.Identifiable Common.Identifiers.DConId
instance Data.String.IsString Common.Identifiers.DConId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.DConId
instance Data.Data.Data Common.Identifiers.DConId
instance GHC.Classes.Ord Common.Identifiers.DConId
instance GHC.Show.Show Common.Identifiers.DConId
instance GHC.Classes.Eq Common.Identifiers.DConId
instance Prettyprinter.Internal.Pretty Common.Identifiers.VarId
instance GHC.Base.Monoid Common.Identifiers.VarId
instance GHC.Base.Semigroup Common.Identifiers.VarId
instance Common.Identifiers.Identifiable Common.Identifiers.VarId
instance Data.String.IsString Common.Identifiers.VarId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.VarId
instance Data.Data.Data Common.Identifiers.VarId
instance GHC.Classes.Ord Common.Identifiers.VarId
instance GHC.Show.Show Common.Identifiers.VarId
instance GHC.Classes.Eq Common.Identifiers.VarId
instance Prettyprinter.Internal.Pretty Common.Identifiers.CSym
instance GHC.Base.Monoid Common.Identifiers.CSym
instance GHC.Base.Semigroup Common.Identifiers.CSym
instance Common.Identifiers.Identifiable Common.Identifiers.CSym
instance Data.String.IsString Common.Identifiers.CSym
instance Language.C.Quote.Base.ToIdent Common.Identifiers.CSym
instance Data.Data.Data Common.Identifiers.CSym
instance GHC.Classes.Ord Common.Identifiers.CSym
instance GHC.Show.Show Common.Identifiers.CSym
instance GHC.Classes.Eq Common.Identifiers.CSym
instance Data.Data.Data Common.Identifiers.TVarIdx
instance GHC.Classes.Ord Common.Identifiers.TVarIdx
instance GHC.Classes.Eq Common.Identifiers.TVarIdx
instance GHC.Show.Show Common.Identifiers.TVarIdx
instance Prettyprinter.Internal.Pretty Common.Identifiers.TVarIdx
instance GHC.Show.Show Common.Identifiers.TVarId
instance GHC.Show.Show Common.Identifiers.TConId
instance Data.String.IsString Common.Identifiers.Identifier
instance Common.Identifiers.Identifiable Common.Identifiers.Identifier
instance GHC.Show.Show Common.Identifiers.Identifier
instance Language.C.Quote.Base.ToIdent Common.Identifiers.Identifier
instance GHC.Base.Semigroup Common.Identifiers.Identifier
instance GHC.Base.Monoid Common.Identifiers.Identifier
instance Prettyprinter.Internal.Pretty Common.Identifiers.Identifier


-- | Bindings to the ssm-runtime library.
module Codegen.LibSSM

-- | Identifiers in C.
newtype CIdent
CIdent :: Identifier -> CIdent

-- | Construct a type name from a C identifier.
ctype :: CIdent -> Type

-- | Construct an expression from a C identifier.
cexpr :: CIdent -> Exp

-- | Construct an expression of the size of a C type.
csizeof :: Type -> Exp

-- | Construct an integer literal in C.
cint :: Int -> Exp
ccall :: Exp -> [Exp] -> Exp
amp :: Exp -> Exp
star :: Exp -> Exp

-- | Natively supported sizes in C.
data CSize
Size8 :: CSize
Size16 :: CSize
Size32 :: CSize
Size64 :: CSize

-- | Convert a <a>CSize</a> into an integer.
size_to_int :: CSize -> Int

-- | Convert a <a>CSize</a> into some string identifier of the size.
size_to_string :: IsString s => CSize -> s

-- | <tt>enum ssm_error</tt>, an enumeration of possible runtime errors.
data SSMError

-- | Reserved for unforeseen, non-user-facing errors.
INTERNAL_ERROR :: SSMError

-- | Tried to insert into full ready queue.
EXHAUSTED_ACT_QUEUE :: SSMError

-- | Tried to insert into full event queue.
EXHAUSTED_EVENT_QUEUE :: SSMError

-- | Could not allocate more memory.
EXHAUSTED_MEMORY :: SSMError

-- | Tried to exceed available recursion depth.
EXHAUSTED_PRIORITY :: SSMError

-- | Not yet ready to perform the requested action.
NOT_READY :: SSMError

-- | Specified invalid time.
INVALID_TIME :: SSMError

-- | Invalid memory layout.
INVALID_MEMORY :: SSMError

-- | <tt>SSM_THROW</tt>, throw a runtime error.
throw :: SSMError -> Exp

-- | <tt>ssm_word_t</tt>, the largest supported machine word size.
word_t :: Type

-- | <tt>ssm_value_t</tt>, runtime representation for sslang values.
value_t :: Type

-- | Name of the <tt>packed_val</tt> field in a <a>value_t</a>.
packed_val :: CIdent

-- | Name of the <tt>heap_ptr</tt> field in a <a>value_t</a>.
heap_ptr :: CIdent

-- | <tt>ssm_marshal</tt>, construct a <a>value_t</a> out of a 31-bit
--   integral value.
marshal :: Exp -> Exp

-- | <tt>ssm_unmarshal</tt>, extract 31-bit integral value out of a
--   <a>value_t</a>.
unmarshal :: Exp -> Exp

-- | <tt>ssm_on_heap</tt>, whether a <a>value_t</a> points to something on
--   the heap.
on_heap :: Exp -> Exp

-- | <tt>ssm_dup</tt>, increment the reference count of a value.
dup :: Exp -> Exp

-- | <tt>ssm_dups</tt>, increment the reference count on a vector of
--   values.
dups :: Exp -> Exp -> Exp

-- | <tt>ssm_drop</tt>, drop the reference count of a value and free if
--   necessary.
drop :: Exp -> Exp

-- | <tt>ssm_time_t</tt>, 64-bit time type.
time_t :: Type

-- | <tt>struct ssm_time</tt>, the heap-representation of a <a>time_t</a>.
time_obj_t :: Type

-- | <tt>SSM_NEVER</tt>, a <a>time_t</a> that is never reached.
never :: Exp

-- | <tt>ssm_now</tt>, the current time.
now :: Exp

-- | <tt>ssm_new_time</tt>, allocate a <a>time_obj_t</a> on the heap.
new_time :: Exp -> Exp

-- | <tt>ssm_time_read</tt>, read the time in a <a>time_obj_t</a>.
read_time :: Exp -> Exp

-- | <tt>ssm_priority_t</tt>, thread priority.
priority_t :: Type

-- | <tt>ssm_depth_t</tt>, thread depth.
depth_t :: Type

-- | <tt>SSM_ROOT_PRIORITY</tt>, the depth of the root process.
root_priority :: Exp

-- | <tt>SSM_ROOT_DEPTH</tt>, the depth of the root process.
root_depth :: Exp

-- | <tt>ssm_act_t</tt>, the generic activation record type.
act_t :: Type

-- | Name of the program counter field in an <a>act_t</a>.
act_pc :: CIdent

-- | Name of the caller field in an <a>act_t</a>.
act_caller :: CIdent

-- | Name of the depth field in an <a>act_t</a>.
act_depth :: CIdent

-- | Name of the priority field in an <a>act_t</a>.
act_priority :: CIdent

-- | <tt>ssm_trigger_t</tt>, nodes in the linked list of triggers.
trigger_t :: Type

-- | <tt>ssm_enter</tt>, allocate and initialize activation record.
enter :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_leave</tt>, deallocate an activation record before leaving.
leave :: Exp -> Exp -> Exp

-- | <tt>ssm_has_children</tt>, returns non-zero if <tt>act</tt> has at
--   least one child.
has_children :: Exp -> Exp

-- | <tt>ssm_activate</tt>, schedule an activation record on the ready
--   queue.
activate :: Exp -> Exp

-- | <tt>ssm_top_parent</tt>, Name of top level parent activation record
top_parent :: Exp

-- | <tt>ssm_sv_t</tt>, polymorphic scheduled variables.
sv_t :: Type

-- | <tt>ssm_new_sv</tt>, allocate a new <a>sv_t</a> on the heap.
new_sv :: Exp -> Exp

-- | <tt>ssm_to_sv</tt>, retrieve the <a>sv_t</a> pointer pointed to by a
--   <a>value_t</a>.
to_sv :: Exp -> Exp

-- | <tt>ssm_deref</tt>, read the value of an <a>sv_t</a> pointed to by a
--   <a>value_t</a>.
deref :: Exp -> Exp

-- | <tt>ssm_assign</tt>, assign to a scheduled variable.
assign :: Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_later</tt>, schedule a delayed assignment to a scheduled
--   variable.
later :: Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_sensitize</tt>, sensitize a trigger to a variable.
sensitize :: Exp -> Exp -> Exp

-- | <tt>ssm_sensitize</tt>, sensitize a trigger to a variable.
desensitize :: Exp -> Exp

-- | <tt>ssm_new_adt</tt>, allocate a new ADT object on the heap.
new_adt :: Int -> DConId -> Exp

-- | <tt>ssm_adt_field</tt>, access the <tt>i</tt>th field of an ADT
--   object. Assignable.
adt_field :: Exp -> Int -> Exp

-- | <tt>ssm_tag</tt>, extract the tag of an ADT value.
adt_tag :: Exp -> Exp

-- | <tt>ssm_closure1_t</tt>, the (template) type of a closure with a
--   single argument.
closure1_t :: Type

-- | Inintializer for a "static" closure that contains no arguments.
--   
--   FIXME: An ugly hack that shouldn't exist because John didn't have the
--   foresight to provide an interface to define static closures.
static_closure :: Exp -> Int -> Initializer

-- | Promote a static object to an <tt>ssm_value_t</tt> (warning: hacky!).
static_value :: CIdent -> Exp

-- | <tt>ssm_new_closure</tt>, allocate a new closure object on the heap.
new_closure :: CIdent -> Int -> Exp

-- | <tt>ssm_closure_push</tt>, add a new argument to a closure.
closure_push :: Exp -> Exp -> Exp

-- | <tt>ssm_closure_pop</tt>, remove an argument from a closure.
closure_pop :: Exp -> Exp

-- | <tt>ssm_closure_apply</tt>, apply a closure to an argument.
closure_apply :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_closure_apply</tt>, apply a closure to an argument, consuming
--   the closure.
closure_apply_final :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_closure_free</tt>, free a closure (without performing
--   reference counting).
closure_free :: Exp -> Exp

-- | Name of the pseudonymous macro from the Linux kernel.
container_of :: CIdent

-- | Name of program initialization hook, called to set up program with
--   runtime.
program_init :: CIdent

-- | Name of program destruction hook, called before gracefully exiting
--   program.
program_exit :: CIdent

-- | Name of stdout handler enter function, used to bind stdout for POSIX
--   platforms. NOTE: this is a hack
stdout_handler_enter :: CIdent

-- | Name of stdin handler spawner, used to bind stdin for POSIX platforms.
--   NOTE: this is a hack
stdin_handler_spawn :: CIdent

-- | Name of stdin handler killer, used to destroy handler thread on POSIX.
--   NOTE: this is a hack
stdin_handler_kill :: CIdent

-- | Obtain the name of a process activation record struct.
act_typename :: VarId -> CIdent

-- | Identifier for act member in act struct.
act_member :: CIdent

-- | Obtain the type of a process activation record.
act_ :: VarId -> Type

-- | Obtain the process-specific activation record from a generic one.
to_act :: Exp -> VarId -> Exp

-- | Obtain the name for the enter function of a routine.
enter_ :: VarId -> CIdent

-- | Obtain the name for the static closure of a routine.
closure_ :: VarId -> CIdent

-- | Obtain the name of the step function of a routine.
step_ :: VarId -> CIdent

-- | Obtain the name of each trigger for a routine.
trig_ :: Int -> CIdent

-- | Obtain the name of a temporary variable.
tmp_ :: Int -> CIdent

-- | Obtain the name of a label.
label_ :: Int -> CIdent

-- | Obtain the name of an argument variable.
arg_ :: Int -> CIdent

-- | Obtain the name of an argument variable.
argv :: CIdent

-- | Name of return argument.
ret_val :: CIdent

-- | Identifier for generic (inner) struct act.
actg :: CIdent

-- | Identifier for specialized (outer) struct act.
acts :: CIdent

-- | Access activation record member.
acts_ :: CIdent -> Exp

-- | Name of the caller argument of an enter call.
enter_caller :: CIdent

-- | Name of the priority argument of an enter call.
enter_priority :: CIdent

-- | Name of the depth argument of an enter call.
enter_depth :: CIdent

-- | Label to jump to terminate execution.
leave_label :: CIdent

-- | Cast to a signed integer of a particular size.
cast_to_signed :: CSize -> Exp -> Exp

-- | Cast to an unsigned integer of a particular size.
cast_to_unsigned :: CSize -> Exp -> Exp

-- | Cast to an integer of a particular size and signedness.
cast_to_int :: Bool -> CSize -> Exp -> Exp

-- | Shift left by the specified amount.
shl :: Exp -> Exp -> Exp

-- | Shift right by the specified amount.
shr :: Exp -> Exp -> Exp
instance GHC.Base.Monoid Codegen.LibSSM.CIdent
instance GHC.Base.Semigroup Codegen.LibSSM.CIdent
instance Language.C.Quote.Base.ToIdent Codegen.LibSSM.CIdent
instance Common.Identifiers.Identifiable Codegen.LibSSM.CIdent
instance Data.String.IsString Codegen.LibSSM.CIdent
instance GHC.Show.Show Codegen.LibSSM.CIdent
instance GHC.Classes.Ord Codegen.LibSSM.CIdent
instance GHC.Classes.Eq Codegen.LibSSM.CIdent
instance GHC.Classes.Ord Codegen.LibSSM.CSize
instance GHC.Classes.Eq Codegen.LibSSM.CSize
instance GHC.Show.Show Codegen.LibSSM.SSMError
instance Language.C.Quote.Base.ToIdent Codegen.LibSSM.SSMError


-- | Data types and helpers used to compose the compiler pipeline.
module Common.Compiler

-- | Type for error messages.
data ErrorMsg

-- | Types of compiler errors that can be thrown during compilation.
data Error

-- | Halt compiler to dump output (not an error)
Dump :: String -> Error

-- | Internal error; should be unreachable
UnexpectedError :: ErrorMsg -> Error

-- | "It's a research artifact"
UnimplementedError :: ErrorMsg -> Error

-- | Round peg in square hole
TypeError :: ErrorMsg -> Error

-- | Identifier is out of scope
ScopeError :: ErrorMsg -> Error

-- | Invalid naming convention at binding
NameError :: ErrorMsg -> Error

-- | Malformed pattern
PatternError :: ErrorMsg -> Error

-- | Error encountered by scanner
LexError :: ErrorMsg -> Error

-- | Error encountered by parser
ParseError :: ErrorMsg -> Error

-- | Types of compiler warnings that can be logged during compilation.
data Warning

-- | Warning about type
TypeWarning :: ErrorMsg -> Warning

-- | Warning related to identifier names
NameWarning :: ErrorMsg -> Warning

-- | Warning related to patterns
PatternWarning :: ErrorMsg -> Warning

-- | The compiler pipeline monad; supports throwing errors, logging, etc.
newtype Pass a
Pass :: PassMonad a -> Pass a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Invoke a compiler <a>Pass</a>.
runPass :: Pass a -> Either Error (a, [Warning])

-- | Dump pretty-printable output from within a compiler pass.
dump :: Pretty a => a -> Pass x

-- | Report unexpected compiler error and halt pipeline.
unexpected :: MonadError Error m => String -> m a

-- | Log a compiler warning.
warn :: MonadWriter [Warning] m => Warning -> m ()

-- | Report unexpected compiler error and halt pipeline.
todo :: MonadError Error m => String -> m a

-- | Execute compiler pass in I/O monad, exiting upon exception.
passIO :: Pass a -> IO (a, [Warning])

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | Throw a type error with some String error message.
typeError :: MonadError Error m => String -> m a
instance GHC.Base.Monoid Common.Compiler.ErrorMsg
instance GHC.Base.Semigroup Common.Compiler.ErrorMsg
instance GHC.Show.Show Common.Compiler.ErrorMsg
instance GHC.Classes.Eq Common.Compiler.Error
instance GHC.Show.Show Common.Compiler.Error
instance GHC.Classes.Eq Common.Compiler.Warning
instance GHC.Show.Show Common.Compiler.Warning
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Common.Compiler.Pass
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Common.Compiler.Pass
instance GHC.Base.Monad Common.Compiler.Pass
instance GHC.Base.Applicative Common.Compiler.Pass
instance GHC.Base.Functor Common.Compiler.Pass
instance Control.Monad.Fail.MonadFail Common.Compiler.Pass
instance Data.String.IsString Common.Compiler.ErrorMsg
instance GHC.Classes.Eq Common.Compiler.ErrorMsg


-- | Sslang abstract syntax tree.
module Front.Ast

-- | A complete program: a list of top-level definitions.
newtype Program
Program :: [TopDef] -> Program

-- | A top-level definition.
data TopDef

-- | Bind a (data) value to a variable
TopDef :: Definition -> TopDef

-- | Define an algebraic data type
TopType :: TypeDef -> TopDef

-- | Inlined block of C definitions
TopCDefs :: String -> TopDef

-- | Declare external symbol for FFI
TopExtern :: ExternDecl -> TopDef

-- | Associate a type with a symbol
data ExternDecl
ExternDecl :: Identifier -> Typ -> ExternDecl

-- | An algebraic data type definition.
data TypeDef
TypeDef :: Identifier -> [Identifier] -> [TypeVariant] -> TypeDef

-- | The name of the type, e.g., <tt>Option</tt>
[typeName] :: TypeDef -> Identifier

-- | List of type parameters, e.g., <tt>a</tt>
[typeParams] :: TypeDef -> [Identifier]

-- | List of variants, e.g., <tt>Some</tt>, <tt>None</tt>
[typeVariants] :: TypeDef -> [TypeVariant]

-- | A type variant, i.e., a data constructor.
data TypeVariant
VariantUnnamed :: Identifier -> [Typ] -> TypeVariant

-- | A value definition.
data Definition
DefFn :: Identifier -> [Pat] -> TypFn -> Expr -> Definition
DefPat :: Pat -> Expr -> Definition

-- | A pattern appearing on the LHS of a definition or match arm
data Pat

-- | Match anything, i.e., <tt>_</tt>
PatWildcard :: Pat

-- | Variable or data constructor, e.g., <tt>v</tt> or <tt>Some</tt>
PatId :: Identifier -> Pat

-- | Literal match, e.g., <tt>1</tt>
PatLit :: Literal -> Pat

-- | Pattern alias, e.g., <tt>a @ <a>pat</a></tt>
PatAs :: Identifier -> Pat -> Pat

-- | Match on a tuple, e.g., <tt>(<a>pat</a>, <a>pat</a>)</tt>
PatTup :: [Pat] -> Pat

-- | Match on multiple patterns, e.g., <tt>Some a</tt>
PatApp :: [Pat] -> Pat

-- | Match with type annotation, e.g., <tt><a>pat</a>: Type</tt>
PatAnn :: Typ -> Pat -> Pat

-- | Function type annotation
data TypFn
TypReturn :: TypAnn -> TypFn
TypProper :: TypAnn -> TypFn
TypNone :: TypFn

-- | TODO: type classes
type TypAnn = Typ

-- | A type definition
data Typ
TCon :: Identifier -> Typ
TApp :: Typ -> Typ -> Typ
TTuple :: [Typ] -> Typ
TArrow :: Typ -> Typ -> Typ

-- | An expression
data Expr
Id :: Identifier -> Expr
Lit :: Literal -> Expr
Apply :: Expr -> Expr -> Expr
Lambda :: [Pat] -> Expr -> Expr
OpRegion :: Expr -> OpRegion -> Expr
NoExpr :: Expr
Let :: [Definition] -> Expr -> Expr
While :: Expr -> Expr -> Expr
Loop :: Expr -> Expr
Par :: [Expr] -> Expr
IfElse :: Expr -> Expr -> Expr -> Expr
After :: Expr -> Expr -> Expr -> Expr
Assign :: Expr -> Expr -> Expr
Constraint :: Expr -> TypAnn -> Expr
Wait :: [Expr] -> Expr
Seq :: Expr -> Expr -> Expr
Break :: Expr
Match :: Expr -> [(Pat, Expr)] -> Expr
CQuote :: String -> Expr
CCall :: Identifier -> [Expr] -> Expr
Tuple :: [Expr] -> Expr
ListExpr :: [Expr] -> Expr

-- | An operator region: a flat list of alternating expressions and
--   operators that is initially parsed flat but will be restructured into
--   a tree by the operator precedence parser.
data OpRegion
NextOp :: Identifier -> Expr -> OpRegion -> OpRegion
EOR :: OpRegion

-- | A literal
data Literal
LitInt :: Integer -> Literal
LitString :: String -> Literal
LitRat :: Rational -> Literal
LitChar :: Char -> Literal
LitEvent :: Literal

-- | Fixity declaration for binary operators.
data Fixity
Infixl :: Int -> Identifier -> Fixity
Infixr :: Int -> Identifier -> Fixity

-- | Apply a function to zero or more arguments.
--   
--   Suppose we have as source code <tt> type Color = RGB Int Int Int ...
--   let x = RGB 203 200 100 </tt> and rgb = Id <a>RGB</a> r = Lit
--   (A.LitInt 203) g = Lit (A.LitInt 200) b = Lit (A.LitInt 100), then
--   foldApp rgb [r, g, b] returns <tt> Apply (Apply (Apply (Id RGB) (Lit
--   (LitInt 100))) (Lit (LitInt 200))) (Lit (LitInt 203)) </tt>
foldApp :: Expr -> [Expr] -> Expr

-- | Collect a type application into the type constructor and its
--   arguments.
collectTApp :: Typ -> (Typ, [Typ])

-- | Collect a curried application into the function and its list of
--   arguments.
collectApp :: Expr -> (Expr, [Expr])

-- | Collect a pattern application into the destructor and arguments.
collectPApp :: Pat -> (Pat, [Pat])

-- | Unwrap a (potential) top-level data definition.
getTopDataDef :: TopDef -> Maybe Definition

-- | Unwrap a (potential) top-level type definition.
getTopTypeDef :: TopDef -> Maybe TypeDef

-- | Unwrap a (potential) top-level C inline block.
getTopCDefs :: TopDef -> Maybe String

-- | Unwrap a (potential) top-level external definition.
getTopExtern :: TopDef -> Maybe ExternDecl

-- | Unzip a list of top-level declarations into their counterparts.
getTops :: [TopDef] -> ([TypeDef], [String], [ExternDecl], [Definition])
instance Data.Data.Data Front.Ast.Typ
instance GHC.Show.Show Front.Ast.Typ
instance GHC.Classes.Eq Front.Ast.Typ
instance Data.Data.Data Front.Ast.TypFn
instance GHC.Show.Show Front.Ast.TypFn
instance GHC.Classes.Eq Front.Ast.TypFn
instance Data.Data.Data Front.Ast.TypeVariant
instance GHC.Show.Show Front.Ast.TypeVariant
instance GHC.Classes.Eq Front.Ast.TypeVariant
instance Data.Data.Data Front.Ast.TypeDef
instance GHC.Show.Show Front.Ast.TypeDef
instance GHC.Classes.Eq Front.Ast.TypeDef
instance Data.Data.Data Front.Ast.ExternDecl
instance GHC.Show.Show Front.Ast.ExternDecl
instance GHC.Classes.Eq Front.Ast.ExternDecl
instance Data.Data.Data Front.Ast.Literal
instance GHC.Show.Show Front.Ast.Literal
instance GHC.Classes.Eq Front.Ast.Literal
instance Data.Data.Data Front.Ast.Pat
instance GHC.Show.Show Front.Ast.Pat
instance GHC.Classes.Eq Front.Ast.Pat
instance Data.Data.Data Front.Ast.OpRegion
instance GHC.Show.Show Front.Ast.OpRegion
instance GHC.Classes.Eq Front.Ast.OpRegion
instance Data.Data.Data Front.Ast.Expr
instance GHC.Show.Show Front.Ast.Expr
instance GHC.Classes.Eq Front.Ast.Expr
instance Data.Data.Data Front.Ast.Definition
instance GHC.Show.Show Front.Ast.Definition
instance GHC.Classes.Eq Front.Ast.Definition
instance Data.Data.Data Front.Ast.TopDef
instance GHC.Show.Show Front.Ast.TopDef
instance GHC.Classes.Eq Front.Ast.TopDef
instance Data.Data.Data Front.Ast.Program
instance GHC.Show.Show Front.Ast.Program
instance GHC.Classes.Eq Front.Ast.Program
instance Prettyprinter.Internal.Pretty Front.Ast.Program
instance Common.Pretty.Dumpy Front.Ast.Program
instance Prettyprinter.Internal.Pretty Front.Ast.TopDef
instance Prettyprinter.Internal.Pretty Front.Ast.Definition
instance Prettyprinter.Internal.Pretty Front.Ast.Expr
instance Prettyprinter.Internal.Pretty Front.Ast.Pat
instance Prettyprinter.Internal.Pretty Front.Ast.Literal
instance Prettyprinter.Internal.Pretty Front.Ast.ExternDecl
instance Prettyprinter.Internal.Pretty Front.Ast.TypeDef
instance Prettyprinter.Internal.Pretty Front.Ast.TypeVariant
instance Prettyprinter.Internal.Pretty Front.Ast.TypFn
instance Prettyprinter.Internal.Pretty Front.Ast.Typ


-- | Desugar <tt>ListExpr</tt> nodes into <tt>App</tt> nodes
module Front.DesugarLists

-- | Desugar ListExpr nodes inside of an AST <a>Program</a>.
desugarLists :: Program -> Pass Program

module Front.DesugarPatTup
desugarPatTup :: Program -> Pass Program


-- | Desugar String Literal nodes into ListExpr nodes
module Front.DesugarStrings

-- | Desugar <a>LitString</a> nodes inside of an AST <a>Program</a>.
desugarStrings :: Program -> Pass Program


-- | Identifiers, associated metadata, and reserved identifiers.
module Front.Identifiers

-- | Where an identifier comes from.
data IdKind

-- | User- and library-defined identifiers, e.g., <tt>foo</tt>.
User :: IdKind

-- | Builtin identifiers, e.g., <tt>new</tt> and <tt>deref</tt>.
Builtin :: IdKind

-- | Unused, but user should not be able to define.
Reserved :: IdKind

-- | Metadata associated with a data identifier.
newtype DataInfo
DataInfo :: IdKind -> DataInfo
[dataKind] :: DataInfo -> IdKind

-- | Metadata associated with a type identifier.
newtype TypInfo
TypInfo :: IdKind -> TypInfo
[typKind] :: TypInfo -> IdKind

-- | Map of builtin types.
builtinTypes :: Map Identifier TypInfo

-- | Map of builtin data.
builtinData :: Map Identifier DataInfo
instance GHC.Classes.Eq Front.Identifiers.IdKind
instance GHC.Show.Show Front.Identifiers.IdKind
instance Common.Default.Default Front.Identifiers.TypInfo
instance Common.Default.Default Front.Identifiers.DataInfo


-- | Parse OpRegion nodes inside of an AST <tt>Program</tt>.
module Front.ParseOperators

-- | Parse OpRegion nodes inside of an AST <tt>Program</tt>.
parseOperators :: Program -> Pass Program

-- | Fixity declaration for binary operators.
data Fixity
Infixl :: Int -> Identifier -> Fixity
Infixr :: Int -> Identifier -> Fixity


-- | Check scoping rules and naming conventions for identifiers.
--   
--   Here, we ensure that all identifiers that appear in the AST only
--   appear after they are previously declared or defined.
--   
--   Identifiers can be segregated into two categories: data identifiers,
--   which produce expressions, and type identifiers, which produce types
--   (more accurately, type expressions). These inhabit separate namespaces
--   and are distinguished by the different contexts in which they are
--   used.
--   
--   Of each category, there are two kinds of identifiers: constructors and
--   variables. Constructors must begin with an upper case letter or a
--   colon (<tt>:</tt>); all other identifiers are variables (see
--   <a>isCons</a> and <a>isVar</a>). For instance, data constructors name
--   the variants of an algebraic data type, while data variables name
--   values bound by a let-binding, a pattern-match, or a lambda.
--   Meanwhile, type constructors are points in the type system defined by
--   the user, while type variables are universally quantified in each type
--   expression.
--   
--   Consider the following example:
--   
--   @@ type Bool = True False
--   
--   type Either t u = Left t Right u
--   
--   liftEither b x y: Bool -&gt; a -&gt; b -&gt; Either a b = match b True
--   = Left x False = Right y @@
--   
--   Data variables are <tt>switch</tt>, <tt>b</tt>, <tt>x</tt>, and
--   <tt>y</tt>; data constructors are <tt>True</tt>, <tt>False</tt>,
--   <tt>Left</tt>, and <tt>Right</tt>. Type variables are <tt>t</tt>,
--   <tt>u</tt>, <tt>a</tt>, and <tt>b</tt>; type constructors are
--   <tt>Bool</tt> and <tt>Either</tt>.
--   
--   The grammar as it appears in the parser does not actually distinguish
--   between any of these kinds of identifiers, so it is the responsibility
--   of this module to check that, a data constructor does not appear where
--   a data variable is expected, e.g., <tt>let F x = e</tt>, or vice
--   versa, e.g., <tt>let f (x Y) = e</tt>.
module Front.Scope

-- | Check the scoping of a <a>Program</a>.
scopeProgram :: Program -> Pass ()
instance Control.Monad.Reader.Class.MonadReader Front.Scope.ScopeCtx Front.Scope.ScopeFn
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Front.Scope.ScopeFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Scope.ScopeFn
instance Control.Monad.Fail.MonadFail Front.Scope.ScopeFn
instance GHC.Base.Monad Front.Scope.ScopeFn
instance GHC.Base.Applicative Front.Scope.ScopeFn
instance GHC.Base.Functor Front.Scope.ScopeFn


-- | Sslang source code tokens.
module Front.Token

-- | Tokens extracted from source text.
newtype Token
Token :: (Span, TokenType) -> Token

-- | Extract the <a>TokenType</a> from a <a>Token</a>.
tokenType :: Token -> TokenType

-- | The location of a token in the source text.
data Span
Span :: Int -> Int -> Int -> Int -> Span
[tokPos] :: Span -> Int
[tokLen] :: Span -> Int
[tokLine] :: Span -> Int
[tokCol] :: Span -> Int

-- | The types of tokens that can appear in a sslang source file.
data TokenType
TEOF :: TokenType
TType :: TokenType
TIf :: TokenType
TElse :: TokenType
TWhile :: TokenType
TDo :: TokenType
TPar :: TokenType
TLoop :: TokenType
TLet :: TokenType
TMatch :: TokenType
TAfter :: TokenType
TWait :: TokenType
TFun :: TokenType
TExtern :: TokenType
TEq :: TokenType
TLarrow :: TokenType
TRarrow :: TokenType
TDRarrow :: TokenType
TDBar :: TokenType
TColon :: TokenType
TSemicolon :: TokenType
TBar :: TokenType
TComma :: TokenType
TUnderscore :: TokenType
TAt :: TokenType
TAmpersand :: TokenType
TLparen :: TokenType
TRparen :: TokenType
TLbrace :: TokenType
TRbrace :: TokenType
TLbracket :: TokenType
TRbracket :: TokenType
TInteger :: Integer -> TokenType
TString :: String -> TokenType
TId :: Identifier -> TokenType
TOp :: Identifier -> TokenType
TCSym :: Identifier -> TokenType
TCQuote :: String -> TokenType
TCBlock :: String -> TokenType

-- | Pretty print a list of tokens.
prettyTokens :: [Token] -> String
instance GHC.Show.Show Front.Token.Span
instance GHC.Classes.Eq Front.Token.Span
instance GHC.Show.Show Front.Token.TokenType
instance GHC.Classes.Eq Front.Token.TokenType
instance GHC.Classes.Eq Front.Token.Token
instance GHC.Show.Show Front.Token.Token
instance Prettyprinter.Internal.Pretty Front.Token.Token
instance Prettyprinter.Internal.Pretty Front.Token.TokenType
instance Prettyprinter.Internal.Pretty Front.Token.Span


-- | Scanner for sslang.
--   
--   In addition to tokenizing the input text stream, this scanner is
--   responsible for the following:
--   
--   <ul>
--   <li>Insert implicit open braces after any block-starting token, if
--   necessary;</li>
--   <li>Insert implicit separators for aligned lines within the same
--   block; and</li>
--   <li>Insert implicit close braces if an implicit block closed, either
--   by a decrease in indentation, or by the closure of a surrounding
--   explicit block.</li>
--   </ul>
--   
--   As such, the scanner's state is enriched with a stack of contexts
--   which it uses to perform basic delimiter matching. It also relies on
--   epsilon transitions to emit implicit tokens.
module Front.Scanner

-- | Extract a token stream from an input string.
scanTokens :: String -> Pass [Token]

-- | Extract a stream of token types (without span) from an input string.
scanTokenTypes :: String -> Pass [TokenType]

-- | Used to integrate with Happy parser.
lexerForHappy :: (Token -> Alex a) -> Alex a

-- | Tokens extracted from source text.
newtype Token
Token :: (Span, TokenType) -> Token

-- | The types of tokens that can appear in a sslang source file.
data TokenType
TEOF :: TokenType
TType :: TokenType
TIf :: TokenType
TElse :: TokenType
TWhile :: TokenType
TDo :: TokenType
TPar :: TokenType
TLoop :: TokenType
TLet :: TokenType
TMatch :: TokenType
TAfter :: TokenType
TWait :: TokenType
TFun :: TokenType
TExtern :: TokenType
TEq :: TokenType
TLarrow :: TokenType
TRarrow :: TokenType
TDRarrow :: TokenType
TDBar :: TokenType
TColon :: TokenType
TSemicolon :: TokenType
TBar :: TokenType
TComma :: TokenType
TUnderscore :: TokenType
TAt :: TokenType
TAmpersand :: TokenType
TLparen :: TokenType
TRparen :: TokenType
TLbrace :: TokenType
TRbrace :: TokenType
TLbracket :: TokenType
TRbracket :: TokenType
TInteger :: Integer -> TokenType
TString :: String -> TokenType
TId :: Identifier -> TokenType
TOp :: Identifier -> TokenType
TCSym :: Identifier -> TokenType
TCQuote :: String -> TokenType
TCBlock :: String -> TokenType

-- | The location of a token in the source text.
data Span
Span :: Int -> Int -> Int -> Int -> Span
[tokPos] :: Span -> Int
[tokLen] :: Span -> Int
[tokLine] :: Span -> Int
[tokCol] :: Span -> Int

-- | User-facing syntax error.
syntaxErr :: String -> Alex a

-- | Internal compiler error for unreachable code.
internalErr :: String -> Alex a

-- | Convert Alex's String-encoded errors to Sslang <a>Error</a>.
liftErr :: String -> Error
instance GHC.Show.Show Front.Scanner.AlexPosn
instance GHC.Classes.Eq Front.Scanner.AlexPosn
instance GHC.Show.Show Front.Scanner.ScannerContext
instance GHC.Base.Functor Front.Scanner.Alex
instance GHC.Base.Applicative Front.Scanner.Alex
instance GHC.Base.Monad Front.Scanner.Alex


-- | Parser for sslang token stream.
--   
--   To check for shift<i>reduce and reduce</i>reduce conflicts, generate
--   parser manually:
--   
--   <pre>
--   happy -i Parser.y -o /dev/null
--   </pre>
--   
--   Then check <tt>Parser.info</tt>.
module Front.Parser

-- | Parse a <a>String</a> and yield a <a>Program</a>.
parseProgram :: String -> Pass Program


-- | Front end of the compiler pipeline.
--   
--   Throughout this stage, high-level syntax is progressively parsed and
--   desugared into simpler AST constructs.
module Front

-- | Operation modes for the front end compiler stage.
data Mode

-- | Compile end-to-end (default).
Continue :: Mode

-- | Print the token stream from the scanner.
DumpTokens :: Mode

-- | Print the initial parsed AST, before operators are parsed.
DumpAst :: Mode

-- | Print the AST after operators are parsed.
DumpAstParsed :: Mode

-- | Print the AST after all desugaring, just before lowering.
DumpAstFinal :: Mode

-- | Compiler options for the front end compiler stage.
newtype Options
Options :: Mode -> Options
[optMode] :: Options -> Mode

-- | CLI options for the front end compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Parse a fully-formed AST from some String input.
parseAst :: Options -> String -> Pass Program

-- | Semantic checking on an AST.
checkAst :: Options -> Program -> Pass ()

-- | Front end compiler stage.
run :: Options -> String -> Pass Program
instance GHC.Show.Show Front.Mode
instance GHC.Classes.Eq Front.Mode
instance GHC.Show.Show Front.Options
instance GHC.Classes.Eq Front.Options
instance Common.Default.Default Front.Options

module IR.Constraint.Error
data Type
Infinite :: Type
Error :: Type
FlexVar :: TVarId -> Type
RigidVar :: TVarId -> Type
Type :: TConId -> [Type] -> Type
data Error
BadExpr :: Type -> Type -> Error
BadPattern :: Type -> Type -> Error
InfiniteType :: Identifier -> Type -> Error
toErrorString :: Error -> String
instance GHC.Show.Show IR.Constraint.Error.Type

module IR.Constraint.UnionFind
data Point a
fresh :: MonadIO m => a -> m (Point a)
union :: (MonadIO m, MonadFail m) => Point a -> Point a -> a -> m ()
equivalent :: MonadIO m => Point a -> Point a -> m Bool
redundant :: MonadIO m => Point a -> m Bool
get :: MonadIO m => Point a -> m a
set :: MonadIO m => Point a -> a -> m ()
modify :: MonadIO m => Point a -> (a -> a) -> m ()
instance GHC.Classes.Eq (IR.Constraint.UnionFind.Point a)


-- | Definitions of and related to the sslang IR's type system.
module IR.Types.Type

-- | Encoding of sslang types.
--   
--   Structurally speaking, these are very simple. Types are either type
--   variables or type constructors applied to some other types.
--   
--   Builtin types (and type constructors) include <a>Arrow</a>,
--   <a>Unit</a>, <a>Ref</a>, <a>List</a>, and various sizes of tuples; for
--   convenience, those are defined elsewhere using the GHC PatternSynonyms
--   extension.
data Type

-- | Type constructor, applied to zero or more types
TCon :: TConId -> [Type] -> Type

-- | Type variable (may be implicitly quantified)
TVar :: TVarId -> Type

-- | Constraints on a type scheme.
--   
--   For now, we only support trivial constraints.
data Constraint

-- | The trivial constraint, i.e., always satisfied.
CTrue :: Constraint

-- | Schemes quantify over <a>Type</a> variables and impose some
--   <a>Constraint</a>.
--   
--   <a>SchemeOf</a> is implemented as functor over some kind of type so we
--   can easily substitute in <a>Type</a> vs <tt>UType</tt> when performing
--   type inference/unification.
data SchemeOf t
Forall :: Set TVarId -> Constraint -> t -> SchemeOf t

-- | Unwrap a scheme and obtain the underlying type.
unScheme :: SchemeOf t -> t

-- | Construct a scheme with quantified type variables and a trivial
--   constraint.
forall :: (Functor l, Foldable l) => l TVarId -> t -> SchemeOf t

-- | Construct a scheme from all free type variables and a trivial
--   constraint.
schemeOf :: Type -> Scheme

-- | Schemes over <a>Type</a>.
newtype Scheme
Scheme :: SchemeOf Type -> Scheme

-- | An annotation records the annotated portion of a pattern.
data Annotation

-- | A basic <a>Type</a> annotation
AnnType :: Type -> Annotation

-- | Annotations collected from patterns
AnnDCon :: DConId -> [Annotation] -> Annotation

-- | Annotations collected from fun args
AnnArrows :: [Annotation] -> Annotation -> Annotation

-- | Expressions are annotated with a (potentially empty) list of
--   <a>Annotation</a>.
newtype Annotations
Annotations :: [Annotation] -> Annotations

-- | Unwrap the <a>Annotations</a> data constructor.
unAnnotations :: Annotations -> [Annotation]

-- | Unroll an annotation into a type. FIXME: get rid of this.
fromAnnotations :: Annotations -> Type

-- | Some data type that contains a sslang <a>Type</a>.
class HasType a
getType :: HasType a => a -> Type

-- | A fresh, free type variable; may appear in type annotations.
pattern Hole :: Type

-- | The type constructor for function arrows.
pattern Arrow :: Type -> Type -> Type

-- | Unfold an <a>Arrow</a> <a>Type</a> into a list of argument types and a
--   return type.
unfoldArrow :: Type -> ([Type], Type)

-- | Fold a list of argument types and a return type into an <a>Arrow</a>
--   <a>Type</a>.
foldArrow :: ([Type], Type) -> Type

-- | The builtin singleton <a>Type</a>, whose only data constructor is just
--   <tt>()</tt>.
pattern Unit :: Type

-- | The builtin reference <a>Type</a>, created using <tt>new</tt>.
pattern Ref :: Type -> Type

-- | The builtin list <a>Type</a>, created using list syntax, e.g., <tt>[a,
--   b]</tt>.
pattern List :: Type -> Type

-- | The builtin 64-bit timestamp <a>Type</a>.
pattern Time :: Type

-- | Builtin <a>Type</a> for signed 64-bit integers.
pattern I64 :: Type

-- | Builtin <a>Type</a> for unsigned 64-bit integers.
pattern U64 :: Type

-- | Builtin <a>Type</a> for signed 32-bit integers.
pattern I32 :: Type

-- | Builtin <a>Type</a> for unsigned 32-bit integers.
pattern U32 :: Type

-- | Builtin <a>Type</a> for signed 16-bit integers.
pattern I16 :: Type

-- | Builtin <a>Type</a> for unsigned 16-bit integers.
pattern U16 :: Type

-- | Builtin <a>Type</a> for signed 8-bit integers.
pattern I8 :: Type

-- | Builtin <a>Type</a> for unsigned 8-bit integers.
pattern U8 :: Type

-- | Test whether a <a>Type</a> is one of the builtin signed integers.
isInt :: Type -> Bool

-- | Test whether a <a>Type</a> is one of the builtin unsigned integers.
isUInt :: Type -> Bool

-- | Test whether a <a>Type</a> is one of the builtin numeric types.
isNum :: Type -> Bool

-- | Construct a builtin tuple type out of a list of at least 2 types.
tuple :: [Type] -> Type

-- | Test whether a <a>Type</a> is a tuple of some arity.
isTuple :: Type -> Bool

-- | Construct the type constructor of a builtin tuple of given arity
--   (&gt;= 2).
tupleId :: (Integral i, Identifiable v) => i -> v
tempTupleId :: (Integral i, Identifiable v) => i -> v

-- | More convenient representation of tuple types, for pattern-matching.
data TupleView

-- | 2-tuples
Tup2 :: (Type, Type) -> TupleView

-- | 3-tuples
Tup3 :: (Type, Type, Type) -> TupleView

-- | 4-tuples
Tup4 :: (Type, Type, Type, Type) -> TupleView

-- | n-ary tuples
TupN :: [Type] -> TupleView

-- | not a tuple
NotATuple :: TupleView

-- | Convert a <a>Type</a> to a <a>TupleView</a>; convenient for
--   ViewPatterns.
--   
--   For example, to match on just 2-tuples;
--   
--   <pre>
--   foo :: Type -&gt; String
--   foo (tupleOf -&gt; Tup2 (a, b)) = "2-tuple of " ++ show a ++ " and " ++ show b
--   foo t                        = "Some other kind of type: " ++ show t
--   </pre>
tupleOf :: Type -> TupleView

-- | Kinds are just the arity of type constructors.
type Kind = Int

-- | Map to help us look up the kinds of builtin types.
builtinKinds :: Map TConId Kind
instance Data.Data.Data IR.Types.Type.Type
instance GHC.Show.Show IR.Types.Type.Type
instance GHC.Classes.Eq IR.Types.Type.Type
instance Data.Data.Data IR.Types.Type.Constraint
instance GHC.Show.Show IR.Types.Type.Constraint
instance GHC.Classes.Eq IR.Types.Type.Constraint
instance Data.Data.Data t => Data.Data.Data (IR.Types.Type.SchemeOf t)
instance Data.Traversable.Traversable IR.Types.Type.SchemeOf
instance Data.Foldable.Foldable IR.Types.Type.SchemeOf
instance GHC.Base.Functor IR.Types.Type.SchemeOf
instance GHC.Show.Show t => GHC.Show.Show (IR.Types.Type.SchemeOf t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Types.Type.SchemeOf t)
instance Data.Data.Data IR.Types.Type.Scheme
instance GHC.Show.Show IR.Types.Type.Scheme
instance GHC.Classes.Eq IR.Types.Type.Scheme
instance Data.Data.Data IR.Types.Type.Annotation
instance GHC.Show.Show IR.Types.Type.Annotation
instance GHC.Classes.Eq IR.Types.Type.Annotation
instance GHC.Base.Monoid IR.Types.Type.Annotations
instance GHC.Base.Semigroup IR.Types.Type.Annotations
instance Data.Data.Data IR.Types.Type.Annotations
instance GHC.Show.Show IR.Types.Type.Annotations
instance GHC.Classes.Eq IR.Types.Type.Annotations
instance IR.Types.Type.HasType IR.Types.Type.Type
instance IR.Types.Type.HasType IR.Types.Type.Scheme
instance Prettyprinter.Internal.Pretty IR.Types.Type.Annotations
instance Common.Pretty.Dumpy IR.Types.Type.Annotations
instance Prettyprinter.Internal.Pretty IR.Types.Type.Annotation
instance Common.Pretty.Dumpy IR.Types.Type.Annotation
instance Common.Identifiers.HasFreeVars IR.Types.Type.Scheme Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty IR.Types.Type.Scheme
instance Common.Pretty.Dumpy IR.Types.Type.Scheme
instance Common.Identifiers.HasFreeVars IR.Types.Type.Type Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty IR.Types.Type.Type
instance Common.Pretty.Dumpy IR.Types.Type.Type


-- | Wrapper module around other types-related modules and definitions.
module IR.Types


-- | Sslang's intermediate representation and its associated helpers.
module IR.IR

-- | Top-level compilation unit.
--   
--   <tt>t</tt> is the type system in use, e.g., <a>IR.Types.Flat</a>
data Program t
Program :: VarId -> String -> [(VarId, Type)] -> [(Binder t, Expr t)] -> [(TConId, TypeDef)] -> Program t
[programEntry] :: Program t -> VarId
[cDefs] :: Program t -> String
[externDecls] :: Program t -> [(VarId, Type)]
[programDefs] :: Program t -> [(Binder t, Expr t)]
[typeDefs] :: Program t -> [(TConId, TypeDef)]

-- | The type definition associated with a type constructor. A definition
--   for `data MyList a = Cons a (MyList a) | Nil` looks like: <tt> TypeDef
--   { targs = [a] , [ (<a>Cons</a>, VariantUnnamed [TVar a, TCon
--   (<a>MyList</a> [TVar a])]) , (<a>Nil</a>, VariantUnnamed []) ] } </tt>
--   (Data constructors for identifiers are omitted for brevity.) Note that
--   for a flat type system, where all type constructors are nullary, targs
--   will just be set to [].
data TypeDef
TypeDef :: [(DConId, TypeVariant)] -> [TVarId] -> TypeDef
[variants] :: TypeDef -> [(DConId, TypeVariant)]
[targs] :: TypeDef -> [TVarId]

-- | Arguments to a data constructor, whose fields may or may not be named
data TypeVariant

-- | A record with named fields
VariantNamed :: [(VarId, Type)] -> TypeVariant

-- | An algebraic type with unnamed fields
VariantUnnamed :: [Type] -> TypeVariant

-- | A name to be bound; <a>Nothing</a> represents a wildcard, e.g.,
--   <tt>let _ = ...</tt>.
data Binder t
Binder :: Maybe VarId -> t -> Binder t
[_binderId] :: Binder t -> Maybe VarId
[_binderType] :: Binder t -> t

-- | Literal values supported by the language.
--   
--   Note that these don't carry any connotation of type: <tt>1</tt> just
--   means <tt>1</tt>,
data Literal
LitIntegral :: Integer -> Literal
LitEvent :: Literal

-- | Primitive operations.
--   
--   These should be the kinds of functions one may expect to be available
--   as operators in C, or as instructions in an assembly language.
--   
--   For simplicity and consistency, they should be:
--   
--   <ul>
--   <li>Pure (i.e., side-effectful iff operands are side-effectful, i.e.,
--   no <tt>=</tt>)</li>
--   <li>Strict in all operands (i.e., no <tt>&amp;&amp;</tt> or
--   <tt>||</tt>)</li>
--   </ul>
--   
--   We can instead implement short-circuit control flow using match
--   statements.
data PrimOp

-- | negation, i.e., -x
PrimNeg :: PrimOp

-- | logical not, i.e., !x
PrimNot :: PrimOp

-- | bitwise not, i.e., ~x
PrimBitNot :: PrimOp

-- | addition, i.e., x + y
PrimAdd :: PrimOp

-- | subtraction, i.e., x - y
PrimSub :: PrimOp

-- | multiplication, i.e., x * y
PrimMul :: PrimOp

-- | division, i.e., x / y
PrimDiv :: PrimOp

-- | modulus, i.e., x % y
PrimMod :: PrimOp

-- | bitwise-and, i.e., x &amp; y
PrimBitAnd :: PrimOp

-- | bitwise-or, i.e., x | y
PrimBitOr :: PrimOp

-- | equality, i.e., x == y
PrimEq :: PrimOp

-- | equality, i.e., x != y
PrimNeq :: PrimOp

-- | greater than, i.e., x &gt; y
PrimGt :: PrimOp

-- | greater than or equal to, i.e., x &gt;= y
PrimGe :: PrimOp

-- | less than, i.e., x &lt; y
PrimLt :: PrimOp

-- | less than or equal to, i.e., x &lt;= y
PrimLe :: PrimOp

-- | Primitive functions for side-effects and imperative control flow.
data Primitive

-- | <tt>New e</tt> allocates a schedule variable initialized to
--   <tt>e</tt>, and returns a reference to it.
New :: Primitive

-- | <tt>Dup r</tt> dups the reference <tt>r</tt> and returns <tt>r</tt>.
Dup :: Primitive

-- | <tt>Drop e r</tt> evaluates to <tt>e</tt>, but also drops <tt>r</tt>.
Drop :: Primitive

-- | <tt>Deref r</tt> dereferences reference <tt>r</tt> to obtain its
--   value.
Deref :: Primitive

-- | <tt>Assign r e</tt> instantly assigns value <tt>e</tt> to reference
--   <tt>r</tt>.
Assign :: Primitive

-- | <tt>After t r e</tt> assigns <tt>e</tt> to reference <tt>r</tt> after
--   time <tt>t</tt>.
After :: Primitive

-- | <tt>Par es+</tt> evaluates expressions <tt>es</tt> concurrently.
Par :: Primitive

-- | <tt>Wait rs+</tt> waits for an assignment to any reference in
--   <tt>rs</tt>.
Wait :: Primitive

-- | <tt>Loop b</tt> loops body <tt>b</tt> forever.
Loop :: Primitive

-- | <tt>Break</tt> breaks out of the innermost loop.
Break :: Primitive

-- | <tt>Now</tt> obtains the value of the current instant
Now :: Primitive

-- | Inlined C expression code.
PrimOp :: PrimOp -> Primitive

-- | Primitive operator.
CQuote :: String -> Primitive

-- | Direct call to arbitrary C function (NOTE: HACKY).
CCall :: CSym -> Primitive

-- | Call to well-typed extern symbol.
FfiCall :: VarId -> Primitive

-- | Expressions, based on the let-polymorphic lambda calculus.
--   
--   <tt>t</tt> represents the type of this expression, e.g., <a>Flat</a>.
--   At various stages, this may represent a richer or simpler type system.
--   The type is embedded in each data constructor so as to type-annotate
--   the entire expression tree.
--   
--   Designed for side effects with call-by-value evaluation order. Basic
--   sequencing can be recovered through let-bindings:
--   
--   <pre>
--   let _ = stmt1 in
--   let _ = stmt2 in
--   ...
--   </pre>
--   
--   Effects of <tt>stmt1</tt> take place before that of <tt>stmt2</tt>.
data Expr t

-- | <tt>Var n t</tt> is a variable named <tt>n</tt> of type <tt>t</tt>.
Var :: VarId -> t -> Expr t

-- | <tt>Data d t</tt> is a data constructor named <tt>d</tt> of type
--   <tt>t</tt>.
Data :: DConId -> t -> Expr t

-- | <tt>Lit l t</tt> is a literal value <tt>l</tt> of type <tt>t</tt>.
Lit :: Literal -> t -> Expr t

-- | <tt>App f a t</tt> applies function <tt>f</tt> to argument <tt>a</tt>,
--   producing a value of type <tt>t</tt>.
App :: Expr t -> Expr t -> t -> Expr t

-- | <tt>Let [(n, v)] b t</tt> binds value <tt>v</tt> to variable
--   <tt>v</tt> in its body <tt>b</tt>.
--   
--   The bindings list may only be of length greater than 1 for a set of
--   mutually co-recursive functions.
Let :: [(Binder t, Expr t)] -> Expr t -> t -> Expr t

-- | <tt>Lambda v b t</tt> constructs an anonymous function of type
--   <tt>t</tt> that binds a value to parameter <tt>v</tt> in its body
--   <tt>b</tt>.
Lambda :: Binder t -> Expr t -> t -> Expr t

-- | <tt>Match s alts t</tt> pattern-matches on scrutinee <tt>s</tt>
--   against alternatives <tt>alts</tt>, each producing a value of type
--   <tt>t</tt>.
Match :: Expr t -> [(Alt t, Expr t)] -> t -> Expr t

-- | <tt>Prim p es t</tt> applies primitive <tt>p</tt> arguments
--   <tt>es</tt>, producing a value of type <tt>t</tt>.
Prim :: Primitive -> [Expr t] -> t -> Expr t

-- | <tt>Exception et t</tt> produces a exception for the program.
Exception :: ExceptType -> t -> Expr t

-- | An alternative in a pattern-match.
data Alt t

-- | <tt>AltData d vs</tt> matches data constructor <tt>d</tt>, and
--   recursive patterns <tt>alts</tt>.
AltData :: DConId -> [Alt t] -> t -> Alt t

-- | <tt>AltLit l</tt> matches against literal <tt>l</tt>, producing
--   expression <tt>e</tt>.
AltLit :: Literal -> t -> Alt t

-- | <tt>AltBinder v</tt> matches anything, and bound to name <tt>v</tt>.
AltBinder :: Binder t -> Alt t

-- | Identifier for data variables, e.g., <tt>x</tt>.
newtype VarId
VarId :: Identifier -> VarId

-- | Identifier for type constructors, e.g., <tt>Option</tt>.
newtype TConId
TConId :: Identifier -> TConId

-- | Identifier for data constructors, e.g., <tt>None</tt>.
newtype DConId
DConId :: Identifier -> DConId
newtype ExceptType
ExceptDefault :: Literal -> ExceptType

-- | Encoding of sslang types.
--   
--   Structurally speaking, these are very simple. Types are either type
--   variables or type constructors applied to some other types.
--   
--   Builtin types (and type constructors) include <a>Arrow</a>,
--   <a>Unit</a>, <a>Ref</a>, <a>List</a>, and various sizes of tuples; for
--   convenience, those are defined elsewhere using the GHC PatternSynonyms
--   extension.
data Type

-- | An annotation records the annotated portion of a pattern.
data Annotation

-- | Expressions are annotated with a (potentially empty) list of
--   <a>Annotation</a>.
data Annotations

-- | The number of fields in a <a>TypeVariant</a>.
variantFields :: TypeVariant -> Int

-- | Create a lambda chain given a list of argument-type pairs and a body.
foldLambda :: [Binder Type] -> Expr Type -> Expr Type

-- | Collect a curried list of function arguments from a nesting of
--   lambdas.
unfoldLambda :: Expr t -> ([Binder t], Expr t)

-- | Extract the data carried by the carrier.
extract :: Carrier c => c a -> a

-- | Replace the data carried by the carrier.
inject :: Carrier c => a -> c a -> c a
injectMore :: (Semigroup a, Carrier c) => a -> c a -> c a

-- | Apply a function to zero or more arguments.
--   
--   <a>foldApp</a> is the inverse of <a>unfoldApp</a>.
foldApp :: Expr t -> [(Expr t, t)] -> Expr t

-- | Collect a curried application into the function and argument list.
--   
--   The type accompanying each argument represents type produced by the
--   application, and is extracted from the <a>App</a> node that this
--   function unwraps.
--   
--   For example, the term <tt>f a b</tt> (where <tt>a: A</tt> and <tt>b:
--   B</tt>) would be represented by the following AST: @<tt> (App (App
--   (Var f (A -&gt; B -&gt; C)) (Var a A) (B -&gt; C)) (Var b B) C) </tt>@
--   
--   which, when unzipped, gives:
--   
--   @<tt> (Var f (A -&gt; B -&gt; C)) [(Var a A, B -&gt; C), (Var b B, C)]
--   </tt>@
--   
--   <a>unfoldApp</a> is the inverse of <a>foldApp</a>.
unfoldApp :: Expr t -> (Expr t, [(Expr t, t)])

-- | Whether an expression is a value.
isValue :: Expr t -> Bool

-- | Retrieve list of binders from an <a>Alt</a>.
altBinders :: Alt t -> [Binder t]

-- | A concrete, named binder.
pattern BindVar :: VarId -> t -> Binder t

-- | An anonymous (wildcard) binder.
pattern BindAnon :: t -> Binder t
binderToVar :: Binder a -> Maybe VarId

-- | Many data types carry other kinds of data, e.g., <a>Expr</a> carries a
--   type.
class Carrier c
instance Data.Data.Data IR.IR.TypeVariant
instance GHC.Classes.Eq IR.IR.TypeVariant
instance GHC.Show.Show IR.IR.TypeVariant
instance Data.Data.Data IR.IR.TypeDef
instance GHC.Classes.Eq IR.IR.TypeDef
instance GHC.Show.Show IR.IR.TypeDef
instance Data.Traversable.Traversable IR.IR.Binder
instance Data.Foldable.Foldable IR.IR.Binder
instance GHC.Base.Functor IR.IR.Binder
instance Data.Data.Data t => Data.Data.Data (IR.IR.Binder t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Binder t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Binder t)
instance Data.Data.Data IR.IR.Literal
instance GHC.Show.Show IR.IR.Literal
instance GHC.Classes.Eq IR.IR.Literal
instance Data.Data.Data IR.IR.PrimOp
instance GHC.Show.Show IR.IR.PrimOp
instance GHC.Classes.Eq IR.IR.PrimOp
instance Data.Data.Data IR.IR.Primitive
instance GHC.Show.Show IR.IR.Primitive
instance GHC.Classes.Eq IR.IR.Primitive
instance Data.Traversable.Traversable IR.IR.Alt
instance Data.Foldable.Foldable IR.IR.Alt
instance GHC.Base.Functor IR.IR.Alt
instance Data.Data.Data t => Data.Data.Data (IR.IR.Alt t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Alt t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Alt t)
instance Data.Data.Data IR.IR.ExceptType
instance GHC.Show.Show IR.IR.ExceptType
instance GHC.Classes.Eq IR.IR.ExceptType
instance Data.Traversable.Traversable IR.IR.Expr
instance Data.Foldable.Foldable IR.IR.Expr
instance GHC.Base.Functor IR.IR.Expr
instance Data.Data.Data t => Data.Data.Data (IR.IR.Expr t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Expr t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Expr t)
instance Data.Traversable.Traversable IR.IR.Program
instance Data.Foldable.Foldable IR.IR.Program
instance GHC.Base.Functor IR.IR.Program
instance Data.Data.Data t => Data.Data.Data (IR.IR.Program t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Program t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Program t)
instance IR.IR.Carrier IR.IR.Expr
instance IR.IR.Carrier IR.IR.Alt
instance IR.IR.Carrier IR.IR.Binder
instance Common.Identifiers.HasFreeVars (IR.IR.Expr t) Common.Identifiers.VarId


-- | Substitute AST nodes with magical primitives.
module IR.SubstMagic

-- | Substitute AST nodes with magical primitives.
--   
--   Implemented as a syb-style generic tree traversal.
--   
--   Example usage:
--   
--   @@ -- Given: myExpr :: Expr Poly.Type
--   
--   <ul>
--   <li>- Do: substMagic (Proxy :: Proxy Poly.Type) myExpr</li>
--   <li>- Given: myProm :: Program Annotated.Type</li>
--   <li>- Do: substMagic (Proxy :: Proxy Annotated.Type) myProg @@</li>
--   </ul>
substMagic :: (Data t, Data a) => Proxy t -> a -> a


-- | Simple Inlining Optimization Pass
--   
--   Performs preinline and postinline unconditionally. TODO: Callsite
--   Inline
module IR.Simplify

-- | Entry-point to Simplifer.
--   
--   Maps over top level definitions to create a new simplified Program
simplifyProgram :: Program Type -> Pass (Program Type)
instance GHC.Show.Show IR.Simplify.SubstRng
instance GHC.Show.Show IR.Simplify.OccInfo
instance GHC.Show.Show IR.Simplify.SimplEnv
instance Control.Monad.State.Class.MonadState IR.Simplify.SimplEnv IR.Simplify.SimplFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.Simplify.SimplFn
instance Control.Monad.Fail.MonadFail IR.Simplify.SimplFn
instance GHC.Base.Monad IR.Simplify.SimplFn
instance GHC.Base.Applicative IR.Simplify.SimplFn
instance GHC.Base.Functor IR.Simplify.SimplFn


-- | Unroll let-def blocks to break apart non-mutually recursive
--   definitions.
module IR.SegmentLets
segmentLets :: Program T -> Pass (Program T)
segmentDefs :: [Def t] -> [[Def t]]
segmentDefs' :: [Def' t a b] -> [[Def' t a b]]

module IR.Pretty
instance Prettyprinter.Internal.Pretty (IR.IR.Program IR.Types.Type.Type)
instance Prettyprinter.Internal.Pretty (IR.IR.Expr IR.Types.Type.Type)
instance Prettyprinter.Internal.Pretty IR.IR.ExceptType
instance Prettyprinter.Internal.Pretty (IR.IR.Alt IR.Types.Type.Type)
instance Prettyprinter.Internal.Pretty IR.IR.Literal
instance Prettyprinter.Internal.Pretty IR.IR.PrimOp

module IR.Pattern.Vector
data PatVec t
PatVec :: Int -> [Alt t] -> PatVec t
[ncol] :: PatVec t -> Int
[toList] :: PatVec t -> [Alt t]
fromList :: [Alt t] -> PatVec t
singleton :: Alt t -> PatVec t
extend :: PatVec t -> PatVec t -> PatVec t
hd :: PatVec t -> Alt t
tl :: PatVec t -> PatVec t
specialize :: PatVec t -> PatVec t
specializeWild :: Int -> PatVec t -> PatVec t
instance GHC.Show.Show t => GHC.Show.Show (IR.Pattern.Vector.PatVec t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Pattern.Vector.PatVec t)

module IR.Pattern.Matrix
data PatMat t
PatMat :: Int -> Int -> [PatVec t] -> PatMat t
[nrow] :: PatMat t -> Int
[ncol] :: PatMat t -> Int
[toList] :: PatMat t -> [PatVec t]
singleCol :: [Alt t] -> PatMat t
singleRow :: [Alt t] -> PatMat t
fromPatVec :: PatVec t -> PatMat t
fromPatVecs :: [PatVec t] -> PatMat t
emptyWithCols :: Int -> PatMat t
hd :: PatMat t -> PatVec t
extend :: PatMat t -> PatMat t -> PatMat t
specializeLit :: Literal -> PatMat t -> PatMat t
specializeCons :: Int -> Identifier -> PatMat t -> PatMat t
defaultize :: PatMat t -> PatMat t
instance GHC.Show.Show t => GHC.Show.Show (IR.Pattern.Matrix.PatMat t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Pattern.Matrix.PatMat t)

module IR.Pattern.Common
data CInfo
CInfo :: Identifier -> Identifier -> Int -> CInfo
[cName] :: CInfo -> Identifier
[cType] :: CInfo -> Identifier
[cArity] :: CInfo -> Int
data TInfo
TInfo :: Identifier -> Set Identifier -> TInfo
[tName] :: TInfo -> Identifier
[tCSet] :: TInfo -> Set Identifier
buildTypeMap :: [(TConId, TypeDef)] -> Map Identifier TInfo
buildConsMap :: [(TConId, TypeDef)] -> Map Identifier CInfo
instance GHC.Show.Show IR.Pattern.Common.CInfo
instance GHC.Classes.Eq IR.Pattern.Common.CInfo
instance GHC.Show.Show IR.Pattern.Common.TInfo
instance GHC.Classes.Eq IR.Pattern.Common.TInfo

module IR.Pattern.Anomaly
data AnomalyCtx
AnomalyCtx :: Map Identifier TInfo -> Map Identifier CInfo -> AnomalyCtx
[typeMap] :: AnomalyCtx -> Map Identifier TInfo
[consMap] :: AnomalyCtx -> Map Identifier CInfo
newtype AnomalyFn a
AnomalyFn :: ReaderT AnomalyCtx Pass a -> AnomalyFn a
buildCtx :: [(TConId, TypeDef)] -> AnomalyCtx

-- | Run a AnomalyFn computation.
runAnomalyFn :: AnomalyFn a -> AnomalyCtx -> Pass a
checkProgram :: Show t => Program t -> Pass ()
checkDefs :: Show t => [(VarId, Expr t)] -> AnomalyFn ()
checkExprs :: Show t => [Expr t] -> AnomalyFn ()
checkExpr :: Show t => Expr t -> AnomalyFn ()
checkPats :: Show t => [Alt t] -> AnomalyFn ()
checkUseless :: Show t => [Alt t] -> AnomalyFn ()
checkExhaustive :: Show t => [Alt t] -> AnomalyFn ()
useful :: PatMat t -> PatVec t -> AnomalyFn Bool
usefulInductive :: PatMat t -> PatVec t -> AnomalyFn Bool
samplePat :: PatMat t -> Maybe (Alt t)
askCInfo :: Identifier -> AnomalyFn CInfo
askTInfo :: Identifier -> AnomalyFn TInfo
hasCompleteCons :: Set Identifier -> PatMat t -> Bool

-- | Report <a>Identifier</a> for error reporting.
showId :: Identifier -> ErrorMsg
showSet :: Set Identifier -> ErrorMsg
throwMalformedError :: AnomalyFn a
instance Control.Monad.Reader.Class.MonadReader IR.Pattern.Anomaly.AnomalyCtx IR.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] IR.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Fail.MonadFail IR.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Monad IR.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Applicative IR.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Functor IR.Pattern.Anomaly.AnomalyFn

module IR.Pattern
checkAnomaly :: Show t => Program t -> Pass ()


-- | Remove unnecessary Par expressions from the IR
--   
--   This pass detects unnecessary par expressions and then replaces them
--   with equivalent sequential expressions.
module IR.OptimizePar

-- | Entry-point to Par Optimization.
--   
--   Maps over top level definitions, removing unnecessary pars.
optimizePar :: Program Type -> Pass (Program Type)
instance Control.Monad.State.Class.MonadState IR.OptimizePar.OptParCtx IR.OptimizePar.OptParFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.OptimizePar.OptParFn
instance Control.Monad.Fail.MonadFail IR.OptimizePar.OptParFn
instance GHC.Base.Monad IR.OptimizePar.OptParFn
instance GHC.Base.Applicative IR.OptimizePar.OptParFn
instance GHC.Base.Functor IR.OptimizePar.OptParFn


-- | Lower the representation of a sslang Ast into sslang IR.
--   
--   This pass expects prior desugaring passes to ensure that:
--   
--   <ul>
--   <li>Op regions are unflatted into proper applications.</li>
--   <li>Patterns in definitions consist of only (annotated) identifiers or
--   wildcards.</li>
--   </ul>
module IR.LowerAst

-- | Lower an AST <tt>Program</tt> into IR.
lowerProgram :: Program -> Pass (Program Annotations)


-- | Lift lambda definitions into the global scope.
--   
--   This pass is responsible for moving nested lambda definitions into the
--   global scope and performing necessary callsite adjustments.
module IR.LambdaLift

-- | Entry-point to lambda lifting.
--   
--   Maps over top level definitions and lifts out lambda definitions to
--   create a new Program with the relative order of user definitions
--   preserved.
liftProgramLambdas :: Program Type -> Pass (Program Type)
instance Control.Monad.State.Class.MonadState IR.LambdaLift.LiftCtx IR.LambdaLift.LiftFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.LambdaLift.LiftFn
instance Control.Monad.Fail.MonadFail IR.LambdaLift.LiftFn
instance GHC.Base.Monad IR.LambdaLift.LiftFn
instance GHC.Base.Applicative IR.LambdaLift.LiftFn
instance GHC.Base.Functor IR.LambdaLift.LiftFn


-- | This inserts <tt>dup</tt> and <tt>drop</tt> primitives according to a
--   caller <tt>dup</tt>, callee <tt>drop</tt> policy. The value returned
--   by a function should be passed back referenced (ownership transfers
--   from the callee back to the caller).
--   
--   The <tt>dup : a -&gt; a</tt> primitive behaves like the identity
--   function, evaluating and returning its first argument and increasing
--   the reference count on the result. It is meant to be wrapped around
--   function arguments.
--   
--   The <tt>drop : a -&gt; b -&gt; a</tt> primitive evaluates and returns
--   its first argument. It decrements the reference count to its second
--   argument after it has evaluated its first argument. It is meant to be
--   wrapped around function bodies that need to use and then de-reference
--   their arguments.
--   
--   Thus, something like
--   
--   <pre>
--   add a b = a + b
--   </pre>
--   
--   becomes
--   
--   <pre>
--   add a b =
--     drop
--       (drop
--          ((dup a) + (dup b))
--          b)
--       a
--   </pre>
--   
--   Arguments <tt>a</tt> and <tt>b</tt> to the <tt>+</tt> primitive are
--   duplicated and the result of <tt>+</tt> is duplicated internally, so
--   <tt>add</tt> does not need to duplicate its result. Both arguments
--   <tt>a</tt> and <tt>b</tt> are dropped.
--   
--   Try running <tt>sslc --dump-ir-final</tt> on an example to see the
--   inserted <tt>dup</tt> and <tt>drop</tt> constructs.
--   
--   Our approach was inspired by Perceus
--   <a>https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/</a>
module IR.InsertRefCounting

-- | Insert dup and drop primitives throughout a program
--   
--   Applies <a>insertTop</a> to the program's definitions
insertRefCounting :: Program Type -> Pass (Program Type)

-- | Monad for creating fresh variables: add an Int to the pass
type Fresh = StateT Int Pass

-- | Create a fresh variable name with the given suffix
--   
--   Creates a new variable ID of the form "anon1," "anon2," etc. followed
--   by the supplied suffix
getFresh :: String -> Fresh VarId

-- | Make a dup primitive that returns the type of its argument
makeDup :: Expr Type -> Expr Type

-- | Make a drop primitive with unit type
makeDrop :: Expr Type -> Expr Type -> Expr Type

-- | Insert referencing counting for top-level expressions
--   
--   Applies <a>insertExpr</a> to a top-level delcaration
insertTop :: (Binder Type, Expr Type) -> Fresh (Binder Type, Expr Type)

-- | Insert reference counting into an expression
--   
--   This is the main workhorse of this module.
--   
--   <ul>
--   <li><b>Literals</b> are unchanged, e.g.,</li>
--   </ul>
--   
--   <pre>
--   42
--   </pre>
--   
--   remains
--   
--   <pre>
--   42
--   </pre>
--   
--   <ul>
--   <li><b>Data constructors</b> are unchanged, e.g.,</li>
--   </ul>
--   
--   <pre>
--   True
--   </pre>
--   
--   remains
--   
--   <pre>
--   True
--   </pre>
--   
--   because they are functions whose results are returned with an existing
--   reference
--   
--   <ul>
--   <li>A <b>variable reference</b> becomes a call to dup because it
--   introduces another reference to the named object, e.g.,</li>
--   </ul>
--   
--   <pre>
--   v
--   </pre>
--   
--   becomes
--   
--   <pre>
--   dup v
--   </pre>
--   
--   <ul>
--   <li><b>Application</b> recurses (inserts dups and drops) on both the
--   function being applied and its argument e.g.,</li>
--   </ul>
--   
--   <pre>
--   add x y
--   </pre>
--   
--   becomes
--   
--   <pre>
--   (dup add) (dup x) (dup y)
--   </pre>
--   
--   <ul>
--   <li><b>Primitive</b> function application inserts dups and drops on
--   its arguments, e.g.,</li>
--   </ul>
--   
--   <pre>
--   (+) x y
--   </pre>
--   
--   becomes
--   
--   <pre>
--   (+) (dup x) (dup y)
--   </pre>
--   
--   <ul>
--   <li><b>Let</b> introduces new names whose values are dropped after the
--   body is evaluated; <tt>let _ =</tt> are given names so they can be
--   dropped.</li>
--   </ul>
--   
--   <pre>
--   let a = Foo 42
--       _ = a
--   17
--   </pre>
--   
--   becomes
--   
--   <pre>
--   let a = Foo 42
--   drop
--     (let anon1_underscore = dup a
--      drop
--        17
--        anon1_underscore)
--     a
--   </pre>
--   
--   <ul>
--   <li>Nested <b>Lambda</b> expressions are handled by collecting them
--   into a single expression with multiple arguments, adding dups and
--   drops to the body, and adding drops around the body for each argument
--   (which the caller should have duped)</li>
--   </ul>
--   
--   <pre>
--   add a b = a + b
--   </pre>
--   
--   desugars to
--   
--   <pre>
--   add = fun a (fun b (a + b))
--   </pre>
--   
--   and becomes
--   
--   <pre>
--   add = fun a (
--           fun b (
--              drop (
--                 drop (
--                   (dup a) + (dup b)
--                 ) b
--              ) a
--   </pre>
--   
--   <ul>
--   <li><b>Matches</b> that operate on a variable are modified by
--   inserting dups and drops into the arms (but not the scrutinee)</li>
--   </ul>
--   
--   <pre>
--   match v
--     Foo x = x + 1
--     Bar = 42
--   </pre>
--   
--   desugars to
--   
--   <pre>
--   match v
--     Foo pat_anon0 = let x = pat_anon0
--                       x + 1
--     Bar = 42
--   </pre>
--   
--   then becomes
--   
--   <pre>
--   match v
--     Foo pat_anon0 = drop
--                       dup pat_anon0
--                       let x = dup pat_anon0
--                       drop (
--                          dup x + 1
--                       ) x
--                     ) pat_anon0
--     Bar = 42
--   </pre>
--   
--   <ul>
--   <li><b>Matches</b> that scrutinize an expression lift the scrutinee
--   into a <tt>let</tt> then insert dups and drops on the whole thing</li>
--   </ul>
--   
--   <pre>
--   match add x y
--     10 = 5
--     _ = 3
--   </pre>
--   
--   becomes
--   
--   <pre>
--   let anon0_scrutinee = (dup add) (dup x) (dup y)
--   drop (
--     match anon0_scrutinee
--       10 = 5
--       _ = 3
--   ) anon0_scruitinee
--   </pre>
insertExpr :: Expr Type -> Fresh (Expr Type)

-- | Insert dups and drops into pattern match arms
--   
--   The body of default and literal patterns is simply recursed upon.
--   
--   Every named variable in a pattern is duped and dropped, e.g.,
--   
--   <pre>
--   match v
--     Foo x = expr
--   </pre>
--   
--   becomes
--   
--   <pre>
--   match v
--     Foo _anon1 = drop
--                    (let x = dup _anon1
--                     expr
--                  ) x
--   </pre>
insertAlt :: (Alt Type, Expr Type) -> Fresh (Alt Type, Expr Type)


-- | Turns non-nullary data constructors into calls to constructor
--   functions.
module IR.ExternToCall

-- | <a>externToCall</a> modifies programDefs and traverses the IR to
--   accomplish two tasks:
--   
--   <ol>
--   <li>Add top-level constructor functions for each non-nullary
--   <tt>DCon</tt> to progamDefs</li>
--   <li>Turn non-nullary data constuctors into calls to top level
--   constructor funcs</li>
--   </ol>
externToCall :: Program Type -> Pass (Program Type)
instance Control.Monad.Reader.Class.MonadReader IR.ExternToCall.ExternEnv IR.ExternToCall.ExternFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.ExternToCall.ExternFn
instance Control.Monad.Fail.MonadFail IR.ExternToCall.ExternFn
instance GHC.Base.Monad IR.ExternToCall.ExternFn
instance GHC.Base.Applicative IR.ExternToCall.ExternFn
instance GHC.Base.Functor IR.ExternToCall.ExternFn

module IR.DesugarPattern
desugarPattern :: Program Type -> Pass (Program Type)
instance GHC.Show.Show IR.DesugarPattern.CInfo
instance GHC.Classes.Eq IR.DesugarPattern.CInfo
instance GHC.Show.Show IR.DesugarPattern.TInfo
instance GHC.Classes.Eq IR.DesugarPattern.TInfo
instance Control.Monad.State.Class.MonadState IR.DesugarPattern.DesugarCtx IR.DesugarPattern.DesugarFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.DesugarPattern.DesugarFn
instance Control.Monad.Fail.MonadFail IR.DesugarPattern.DesugarFn
instance GHC.Base.Monad IR.DesugarPattern.DesugarFn
instance GHC.Base.Applicative IR.DesugarPattern.DesugarFn
instance GHC.Base.Functor IR.DesugarPattern.DesugarFn


-- | Turns non-nullary data constructors into calls to constructor
--   functions.
--   
--   Worked example of ADT definition and corresponding constructor
--   functions:
--   
--   <pre>
--   type Shape
--     Square Int
--     Rect Int Int
--   </pre>
--   
--   Let's turn data constructor <tt>Square</tt> into constructor function
--   <tt>__Square</tt>:
--   
--   <pre>
--   __Square arg0 : Int -&gt; Shape =  Square arg0
--   </pre>
--   
--   The difference is that <tt>Square</tt> cannot be partially-applied,
--   whereas <tt>__Square</tt> can.
--   
--   Next, <tt>Rect</tt> turns into this:
--   
--   <pre>
--   __Rect arg0 arg1 : Int -&gt; Int -&gt; Shape =  Rect arg0 arg1
--   </pre>
--   
--   The difference is that <tt>Rect</tt> cannot be partially-applied,
--   whereas <tt>__Rect</tt> can.
--   
--   Representing constructor functions in the IR:
--   
--   Every top-level function has the form (I.VarId, I.Expr Poly.Type) =
--   (functionName, functionBody) The function body is a lambda expression
--   representing a call to the fully applied data constructor.
--   
--   Let's turn the top-level func for <tt>Square</tt> into IR:
--   
--   <pre>
--   (__Square, body)
--   body = fun arg0 { App L R t } : Int -&gt; Shape
--    where L = Square : Int -&gt; Shape
--          R = arg0 : type Int
--          t = Shape, because the type of a fully applied data constructor
--              is its type constructor@
--   </pre>
--   
--   Next <tt>Rect</tt> turns into this:
--   
--   <pre>
--   (Rect, body)
--   body = fun arg0 { fun arg1 { App L R t } : Int -&gt; Shape } : Int -&gt; Int -&gt; Shape
--    where L = App L2 R2 t
--          R = arg1 : Int
--          t = Shape, because the type of a fully applied data constructor
--              is its type constructor
--           where L2 = Rect : Int -&gt; Int -&gt; Shape
--                 R  = arg0 : Int
--                 t = Int -&gt; Shape, because at this point in the inner App,
--                     Rect is partially applied with only 1 arg.
--   </pre>
module IR.DConToFunc

-- | <a>dConToFunc</a> modifies programDefs and traverses the IR to
--   accomplish two tasks:
--   
--   <ol>
--   <li>Add top-level constructor functions for each non-nullary
--   <tt>DCon</tt> to progamDefs</li>
--   <li>Turn non-nullary data constuctors into calls to top level
--   constructor funcs</li>
--   </ol>
dConToFunc :: Program Type -> Pass (Program Type)
instance Control.Monad.Reader.Class.MonadReader IR.DConToFunc.ArityEnv IR.DConToFunc.ArityFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.DConToFunc.ArityFn
instance Control.Monad.Fail.MonadFail IR.DConToFunc.ArityFn
instance GHC.Base.Monad IR.DConToFunc.ArityFn
instance GHC.Base.Applicative IR.DConToFunc.ArityFn
instance GHC.Base.Functor IR.DConToFunc.ArityFn

module IR.ClassInstantiation
instProgram :: Program Type -> Pass (Program Type)


-- | Extract and encapsulate the type information needed during codegen.
module Codegen.Typegen

-- | Information and codegen handlers associated with each data
--   constructor.
data DConInfo
DConInfo :: TConId -> Int -> Bool -> Exp -> Exp -> (Int -> Exp -> Exp) -> DConInfo

-- | the type that the data constructor inhabits
[dconType] :: DConInfo -> TConId

-- | number of fields
[dconSize] :: DConInfo -> Int

-- | whether the data constructor is heap-allocated
[dconOnHeap] :: DConInfo -> Bool

-- | the dcon tag to match on, i.e., in <tt>case tag</tt>
[dconCase] :: DConInfo -> Exp

-- | constructs a dcon instance
[dconConstruct] :: DConInfo -> Exp

-- | retrieve the ith field
[dconDestruct] :: DConInfo -> Int -> Exp -> Exp

-- | Information and codegen handlers associated with each type
--   constructor.
data TConInfo
TConInfo :: TypeEncoding -> (Exp -> Exp) -> TConInfo

-- | how the data type is encoded
[typeEncoding] :: TConInfo -> TypeEncoding

-- | how to retrieve the tag of an instance
[typeScrut] :: TConInfo -> Exp -> Exp

-- | Type-related information, abstracted behind partial lookup functions.
data TypegenInfo
TypegenInfo :: (DConId -> Maybe DConInfo) -> (TConId -> Maybe TConInfo) -> TypegenInfo

-- | for each data constructor.
[dconInfo] :: TypegenInfo -> DConId -> Maybe DConInfo

-- | for each type constructor.
[tconInfo] :: TypegenInfo -> TConId -> Maybe TConInfo

-- | Create codegen definitions and helpers for sslang type definitions.
genTypes :: [(TConId, TypeDef)] -> Pass ([Definition], TypegenInfo)


-- | Translate SSM program to C compilation unit.
--   
--   What is expected of the IR:
--   
--   Well-formed: All primitive functions are applied to the right number
--   of arguments.
--   
--   Pure par expression: All par-expressions' operands are applications
--   that have no side effects.
--   
--   Defunctionalized: No lambdas; the only terms with an arrow type are
--   variables or applications.
--   
--   Name mangled: All variable identifiers are unique.
module Codegen.Codegen

-- | Possible, but temporarily punted for the sake of expediency.
todo :: HasCallStack => a

-- | Impossible without a discussion about implementation strategy.
nope :: HasCallStack => a

-- | Hack to allow us to splice string literals into C AST
newtype EscExp
EscExp :: String -> EscExp

-- | State maintained while compiling a top-level SSM function.
--   
--   The information here is populated while generating the step function,
--   so that should be computed first, before this information is used to
--   generate the act struct and enter definitions.
data GenFnState
GenFnState :: VarId -> [Binder Type] -> Type -> Expr Type -> Map VarId Type -> Map VarId Exp -> Int -> Int -> Int -> TypegenInfo -> GenFnState

-- | Function name
[fnName] :: GenFnState -> VarId

-- | Function parameters
[fnParams] :: GenFnState -> [Binder Type]

-- | Function return type
[fnRetTy] :: GenFnState -> Type

-- | Function body
[fnBody] :: GenFnState -> Expr Type

-- | Function local variables
[fnLocals] :: GenFnState -> Map VarId Type

-- | How to resolve variables
[fnVars] :: GenFnState -> Map VarId Exp

-- | Number of triggers needed
[fnMaxWaits] :: GenFnState -> Int

-- | Yield point counter
[fnCases] :: GenFnState -> Int

-- | Temporary variable name counter
[fnFresh] :: GenFnState -> Int

-- | (User-defined) type information
[fnTypeInfo] :: GenFnState -> TypegenInfo

-- | Translation monad for procedures, with derived typeclass instances.
--   
--   We declare <a>GenFn</a> as a newtype so that we can implement
--   <a>MonadFail</a> for it, allowing us to use monadic pattern matching.
newtype GenFn a
GenFn :: StateT GenFnState Pass a -> GenFn a

-- | Run a <a>GenFn</a> computation on a procedure.
runGenFn :: VarId -> [Binder Type] -> Expr Type -> TypegenInfo -> [(VarId, Type)] -> GenFn a -> Pass a

-- | Lookup some information associated with a type constructor.
getsTCon :: (TConInfo -> a) -> TConId -> GenFn a

-- | Lookup some information associated with a data constructor.
getsDCon :: (DConInfo -> a) -> DConId -> GenFn a

-- | Read and increment the number of cases in a procedure, i.e.,
--   <tt>fnCases++</tt>.
nextCase :: GenFn Int

-- | Obtain fresh integer in the <a>GenFn</a> monad
getFresh :: GenFn Int

-- | Bind a variable to a C expression.
addBinding :: Binder Type -> Exp -> GenFn ()

-- | Register a new local variable, to be declared in activation record.
addLocal :: VarId -> Type -> GenFn VarId

-- | Bind a variable to a C expression only while computing the given
--   monad.
withBindings :: [(Binder Type, Exp)] -> GenFn a -> GenFn a

-- | Register a local variable and bind its C expression during a monad.
withNewLocal :: (VarId, Type) -> GenFn a -> GenFn a

-- | Register number of wait statements track of number of triggers needed.
maxWait :: Int -> GenFn ()

-- | Generate a fresh label.
freshLabel :: GenFn CIdent

-- | Generate anonymous local variable in activation record for storage.
genTmp :: Type -> GenFn Exp

-- | Translate a list of SSM parameters to C parameters.
genParams :: [Binder Type] -> [(CIdent, Type)]

-- | Translate a list of SSM local declarations to C declarations.
genLocals :: [(VarId, Type)] -> [(CIdent, Type)]

-- | Generate declarations for <tt>numTrigs</tt> triggers.
genTrigs :: Int -> [(CIdent, Type)]

-- | The constant unit value, the singleton inhabitant of the type Unit.
unit :: Exp

-- | Fake undefined value used for expressions of type Void.
undef :: Exp

-- | Generate a C compilation from an SSM program.
--   
--   Each top-level function in a program is turned into three components:
--   
--   <ol>
--   <li>a struct (the activation record);</li>
--   <li>an initialization function (the enter function); and</li>
--   <li>a step function, which corresponds to the actual procedure
--   body.</li>
--   </ol>
--   
--   Items 2 and 3 include both declarations and definitions.
genProgram :: Program Type -> Pass [Definition]

-- | Include statements in the generated C file.
includes :: [Definition]

-- | Setup the entry point of the program.
genInitProgram :: VarId -> [Definition]
genExtern :: (VarId, Type) -> Pass Definition

-- | Generate struct definition for an SSM procedure.
--   
--   This is where local variables, triggers, and parameter values are
--   stored.
genStruct :: GenFn Definition

-- | Generate the enter function for an SSM procedure and its signature.
--   
--   Its struct is allocated and initialized (partially; local variables'
--   values are left uninitialized).
genEnter :: GenFn (Definition, Definition)

-- | Generate static closure for top-level function
genStaticClosure :: GenFn (Definition, Definition)

-- | Generate the step function for an SSM procedure.
--   
--   This function just defines the function definition and switch
--   statement that wraps the statements of the procedure. The heavy
--   lifting is performed by <a>genExpr</a>.
genStep :: GenFn (Definition, Definition)

-- | Helper to generate yield point in step function.
genYield :: GenFn [BlockItem]

-- | Translate an SSM expression into a C expression and statements.
--   
--   SSM IR is a side-effectful expression language, with two implications
--   when translating to C:
--   
--   <ol>
--   <li>every expression has a value (even if it is an uninhabited type),
--   so this must be reflected in C; and</li>
--   <li>some of the side effects in SSM cannot be implemented in C using
--   expressions alone.</li>
--   </ol>
--   
--   These two implications roughly translate to the <tt>C.Exp</tt> and
--   <tt>[C.BlockItem]</tt> in <tt>genExpr</tt>'s return type. When we
--   translate an SSM expression <tt>e</tt>:
--   
--   <pre>
--   (val, stms) &lt;- genExpr e
--   </pre>
--   
--   <tt>val</tt> represents the C expression that corresponds to the value
--   of <tt>e</tt> upon evaluation, while <tt>stms</tt> represents the list
--   of preceding statements that compute <tt>val</tt>.
--   
--   A further consideration upon point 2 is that SSM expressions may yield
--   control at any point. Thus, the C expression returned by
--   <tt>genExpr</tt> must accommodate the step function suspending and
--   resuming. For instance, consider the following SSM IR expression:
--   
--   <pre>
--   (let x = 3 in x) + (wait r; 6)
--   </pre>
--   
--   The <tt>x</tt> in the let-binding in the left operand cannot just be a
--   local variable in the step function, because it would be
--   "uninitialized" by the yield in the right operand:
--   
--   <pre>
--     // let x = 3 in x
--     // stms:
--     int x = 3;
--     // exp: x
--   
--     // (wait r; 6)
--     // stms:
--     ssm_sensitize(r);
--     actg-&gt;pc = N;
--     return;
--   case N:
--     ssm_desensitize(r);
--     // exp: 6
--   
--     // After the return, x is no longer initialized, so the following is
--     // undefined behavior:
--     x + 6
--   </pre>
--   
--   To ensure this is cannot happen, we conservatively declare <tt>x</tt>
--   as a local variable in the activation record, so that its value is
--   preserved between yields, even if this is not usually necessary. We
--   leave it to later compiler passes to optimize this.
genExpr :: Expr Type -> GenFn (Exp, [BlockItem])

-- | Generate code for SSM primitive; see <a>genExpr</a> for extended
--   discussion.
genPrim :: Primitive -> [Expr Type] -> Type -> GenFn (Exp, [BlockItem])

-- | Generate C value for SSM literal, marshalled.
genLiteral :: Literal -> Exp

-- | Generate C value for SSM literal, unmarshalled.
genLiteralRaw :: Literal -> Exp

-- | Generate C expression for SSM primitive operation.
genPrimOp :: PrimOp -> [Expr Type] -> Type -> GenFn (Exp, [BlockItem])

-- | Helper for sequencing across binary operations.
genBinop :: Expr Type -> Expr Type -> GenFn ((Exp, Exp), [BlockItem])

-- | Compute priority and depth arguments for a par fork of given width.
genParArgs :: Int -> (Exp, Exp) -> [(Exp, Exp)]

-- | How much the depth should be decreased when par forking given width.
depthSub :: Int -> Exp
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Codegen.Codegen.GenFn
instance Control.Monad.State.Class.MonadState Codegen.Codegen.GenFnState Codegen.Codegen.GenFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Codegen.Codegen.GenFn
instance Control.Monad.Fail.MonadFail Codegen.Codegen.GenFn
instance GHC.Base.Monad Codegen.Codegen.GenFn
instance GHC.Base.Applicative Codegen.Codegen.GenFn
instance GHC.Base.Functor Codegen.Codegen.GenFn
instance Language.C.Quote.Base.ToExp Codegen.Codegen.EscExp


-- | Code generation (codegen) stage of the compiler pipeline.
--   
--   This module exposes some options for configuring what C code is
--   generated and how it is represented.
module Codegen

-- | Operation modes for the codegen compiler stage.
data Mode
Continue :: Mode

-- | Compiler options for the codegen compiler stage.
data Options
Options :: Mode -> Int -> Options
[mode] :: Options -> Mode
[textWidth] :: Options -> Int

-- | CLI options for the codegen compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Codegen compiler stage.
run :: Options -> Program Type -> Pass String
instance GHC.Show.Show Codegen.Mode
instance GHC.Classes.Eq Codegen.Mode
instance GHC.Show.Show Codegen.Options
instance GHC.Classes.Eq Codegen.Options
instance Common.Default.Default Codegen.Options

module IR.Constraint.Canonical

-- | Encoding of sslang types.
--   
--   Structurally speaking, these are very simple. Types are either type
--   variables or type constructors applied to some other types.
--   
--   Builtin types (and type constructors) include <a>Arrow</a>,
--   <a>Unit</a>, <a>Ref</a>, <a>List</a>, and various sizes of tuples; for
--   convenience, those are defined elsewhere using the GHC PatternSynonyms
--   extension.
data Type

-- | Type constructor, applied to zero or more types
TCon :: TConId -> [Type] -> Type

-- | Type variable (may be implicitly quantified)
TVar :: TVarId -> Type

-- | SCHEMES
data Scheme
Forall :: FreeVars -> Type -> Scheme
type FreeVars = Map TVarId ()

-- | An annotation records the annotated portion of a pattern.
data Annotation

-- | A basic <a>Type</a> annotation
AnnType :: Type -> Annotation

-- | Annotations collected from patterns
AnnDCon :: DConId -> [Annotation] -> Annotation

-- | Annotations collected from fun args
AnnArrows :: [Annotation] -> Annotation -> Annotation

-- | Expressions are annotated with a (potentially empty) list of
--   <a>Annotation</a>.
newtype Annotations
Annotations :: [Annotation] -> Annotations

-- | KINDS
type Kind = Int

-- | Construct a scheme from all free type variables and a trivial
--   constraint.
schemeOf :: Type -> Scheme
freeVars :: Type -> FreeVars

-- | Fold a list of argument types and a return type into an <a>Arrow</a>
--   <a>Type</a>.
foldArrow :: ([Type], Type) -> Type

-- | Unfold an <a>Arrow</a> <a>Type</a> into a list of argument types and a
--   return type.
unfoldArrow :: Type -> ([Type], Type)

-- | HELPERS
(-->) :: Type -> Type -> Type
infixr 0 -->

-- | The builtin singleton <a>Type</a>, whose only data constructor is just
--   <tt>()</tt>.
pattern Unit :: Type

-- | The builtin reference <a>Type</a>, created using <tt>new</tt>.
pattern Ref :: Type -> Type

-- | The builtin list <a>Type</a>, created using list syntax, e.g., <tt>[a,
--   b]</tt>.
pattern List :: Type -> Type

-- | The builtin 64-bit timestamp <a>Type</a>.
pattern Time :: Type

-- | Builtin <a>Type</a> for signed 64-bit integers.
pattern I64 :: Type

-- | Builtin <a>Type</a> for unsigned 64-bit integers.
pattern U64 :: Type

-- | Builtin <a>Type</a> for signed 32-bit integers.
pattern I32 :: Type

-- | Builtin <a>Type</a> for unsigned 32-bit integers.
pattern U32 :: Type

-- | Builtin <a>Type</a> for signed 16-bit integers.
pattern I16 :: Type

-- | Builtin <a>Type</a> for unsigned 16-bit integers.
pattern U16 :: Type

-- | Builtin <a>Type</a> for signed 8-bit integers.
pattern I8 :: Type

-- | Builtin <a>Type</a> for unsigned 8-bit integers.
pattern U8 :: Type

-- | Construct a builtin tuple type out of a list of at least 2 types.
tuple :: [Type] -> Type

-- | Unwrap the <a>Annotations</a> data constructor.
unAnnotations :: Annotations -> [Annotation]

-- | ANNOTATION
annToType :: Annotation -> Type

-- | Map to help us look up the kinds of builtin types.
builtinKinds :: Map TConId Kind

module IR.Constraint.Monad
type TC a = StateT TCState (ExceptT Error IO) a
type DConInfo = (DConId, TConId, [TVarId], [Type])
type DConMap = Map DConId DConInfo
data TCState
TCState :: Int -> DConMap -> Map TConId Kind -> Map VarId Type -> TCState
[_freshCtr] :: TCState -> Int
[_dconMap] :: TCState -> DConMap
[_kindMap] :: TCState -> Map TConId Kind
[_externMap] :: TCState -> Map VarId Type
runTC :: TCState -> TC a -> Either Error a
mkTCState :: Program Annotations -> TCState
mkDConMap :: Program Annotations -> DConMap

-- | Generate a fresh identifier based on some prefix.
freshName :: String -> TC TVarId

-- | Generate a fresh program variable name, e.g., for anonymous binders.
freshVar :: TC VarId

-- | Generate a fresh type identifier to be associated with annotations.
freshAnnVar :: TC VarId
getDConInfo :: DConId -> TC (Maybe DConInfo)
getKind :: TConId -> TC (Maybe Kind)
getExtern :: VarId -> TC (Maybe Type)
throwError :: String -> TC a

module IR.Constraint.Type

-- | CONSTRAINTS
data Constraint
CTrue :: Constraint
CSaveTheEnvironment :: Constraint
CEqual :: Type -> Type -> Constraint
CPattern :: Type -> Type -> Constraint
CLocal :: Identifier -> Type -> Constraint
CForeign :: Scheme -> Type -> Constraint
CAnd :: [Constraint] -> Constraint
CLet :: [Variable] -> [Variable] -> Map Identifier Type -> Constraint -> Constraint -> Constraint
[_rigidVars] :: Constraint -> [Variable]
[_flexVars] :: Constraint -> [Variable]
[_header] :: Constraint -> Map Identifier Type
[_headerCon] :: Constraint -> Constraint
[_bodyCon] :: Constraint -> Constraint
exists :: [Variable] -> Constraint -> Constraint

-- | TYPE PRIMITIVES
type Variable = Point Descriptor
type Attachment = (Annotations, Variable)
data FlatType
TCon1 :: TConId -> [Variable] -> FlatType
data Type
TConN :: TConId -> [Type] -> Type
TVarN :: Variable -> Type

-- | DESCRIPTORS
data Descriptor
Descriptor :: Content -> Int -> Mark -> Maybe Variable -> Descriptor
[_content] :: Descriptor -> Content
[_rank] :: Descriptor -> Int
[_mark] :: Descriptor -> Mark
[_copy] :: Descriptor -> Maybe Variable
data Content
FlexVar :: TVarId -> Content
RigidVar :: TVarId -> Content
Structure :: FlatType -> Content
Error :: Content
mkDescriptor :: Content -> Descriptor

-- | RANKS
noRank :: Int
outermostRank :: Int

-- | MARKS
newtype Mark
Mark :: Int -> Mark
noMark :: Mark
occursMark :: Mark
getVarNamesMark :: Mark
nextMark :: Mark -> Mark

-- | BUILT-IN TYPES
--   
--   Fold a list of argument types and a return type into an <tt>Arrow</tt>
--   <a>Type</a>.
foldArrow :: ([Type], Type) -> Type
(==>) :: Type -> Type -> Type
infixr 0 ==>
unit :: Type
ref :: Type -> Type
list :: Type -> Type
time :: Type
i64 :: Type
u64 :: Type
i32 :: Type
u32 :: Type
i16 :: Type
u16 :: Type
i8 :: Type
u8 :: Type

-- | MAKE FLEX VARIABLES
mkFlexVar :: TC Variable
mkIRFlexVar :: TC Variable
mkRigidVar :: TC Variable

-- | TO CANONICAL TYPE
toCanType :: Variable -> TC Type
termToCanType :: FlatType -> TC Type

-- | TO ERROR TYPE
toErrorType :: Variable -> TC Type
contentToErrorType :: Variable -> Content -> TC Type
termToErrorType :: FlatType -> TC Type
binderToVarId :: Binder t -> TC VarId
uncarryAttachment :: Carrier c => c Attachment -> ([Annotation], Variable)
instance GHC.Classes.Ord IR.Constraint.Type.Mark
instance GHC.Classes.Eq IR.Constraint.Type.Mark
instance GHC.Classes.Eq IR.Constraint.Type.Type

module IR.Constraint.Unify

-- | UNIFY
data Answer
Ok :: Answer
Err :: Type -> Type -> Answer
unify :: Variable -> Variable -> TC Answer
onSuccess :: () -> TC Answer
errorDescriptor :: Descriptor

-- | CPS style UNIFIER
newtype Unify a
Unify :: (forall r. (a -> TC r) -> (() -> TC r) -> TC r) -> Unify a
mismatch :: Unify a

-- | UNIFICATION HELPERS
data Context
Context :: Variable -> Descriptor -> Variable -> Descriptor -> Context
[_first] :: Context -> Variable
[_firstDesc] :: Context -> Descriptor
[_second] :: Context -> Variable
[_secondDesc] :: Context -> Descriptor

-- | MERGE
merge :: Context -> Content -> Unify ()

-- | ACTUALLY UNIFY
guardedUnify :: Variable -> Variable -> Unify ()
subUnify :: Variable -> Variable -> Unify ()
actuallyUnify :: Context -> Unify ()
unifyFlex :: Context -> Content -> Content -> Unify ()
unifyRigid :: Context -> Content -> Content -> Unify ()
unifyStructure :: Context -> FlatType -> Content -> Content -> Unify ()
unifyArgs :: Context -> [Variable] -> [Variable] -> (() -> TC r) -> (() -> TC r) -> TC r

module IR.Constraint.PrettyPrint
printConstraint :: Constraint -> TC (Doc ann)
data Doc ann

module IR.Constraint.Occurs
occurs :: Variable -> TC Bool

module IR.Constraint.Solve

-- | RUN SOLVER
run :: Constraint -> TC ()
emptyState :: State

-- | SOLVER
type Env = Map Identifier Variable
type Pools = IOVector [Variable]
data State
State :: Env -> Mark -> [Error] -> State
[_env] :: State -> Env
[_mark] :: State -> Mark
[_errors] :: State -> [Error]
solve :: Env -> Int -> Pools -> State -> Constraint -> TC State
isGeneric :: Variable -> TC ()

-- | ERROR HELPERS
addError :: State -> Error -> State

-- | OCCURS CHECK
occurs :: State -> (Identifier, Variable) -> TC State

-- | GENERALIZE
--   
--   Every variable has rank less than or equal to the maxRank of the pool.
--   This sorts variables into the young and old pools accordingly.
generalize :: Mark -> Mark -> Int -> Pools -> TC ()
poolToRankTable :: Mark -> Int -> [Variable] -> TC (Vector [Variable])

-- | ADJUST RANK
adjustRank :: Mark -> Mark -> Int -> Variable -> TC Int
adjustRankContent :: Mark -> Mark -> Int -> Content -> TC Int

-- | REGISTER VARIABLES
introduce :: Int -> Pools -> [Variable] -> TC ()

-- | TYPE TO VARIABLE
typeToVariable :: Int -> Pools -> Type -> TC Variable
typeToVar :: Int -> Pools -> Map TVarId Variable -> Type -> TC Variable
register :: Int -> Pools -> Content -> TC Variable
schemeToVariable :: Int -> Pools -> Map TVarId () -> Type -> TC Variable
schemeToVar :: Int -> Pools -> Map TVarId Variable -> Type -> TC Variable

-- | COPY
makeCopy :: Int -> Pools -> Variable -> TC Variable
makeCopyHelp :: Int -> Pools -> Variable -> TC Variable
restore :: Variable -> TC ()
restoreContent :: Content -> TC ()
traverseFlatType :: (Variable -> TC Variable) -> FlatType -> TC FlatType

module IR.Constraint.Instantiate

-- | FROM SCHEME
fromScheme :: FreeVars -> Type -> TC Type

module IR.Constraint.Elaborate
run :: Program Variable -> TC (Program Type)

module IR.Constraint.Constrain.Annotation

-- | CONSTRAIN ANNOTATION
type RigidMap = Map TVarId Variable
data State
State :: RigidMap -> [Variable] -> State
[_rigidMap] :: State -> RigidMap
[_flex] :: State -> [Variable]
withAnnotations :: [Annotation] -> Type -> (Type -> TC Constraint) -> TC Constraint
add :: Annotation -> TC (State, Type)
addTypeWithHoles :: Type -> State -> TC (State, Type)
emptyState :: State

module IR.Constraint.Constrain.Pattern

-- | CONSTRAIN ALT
type Header = Map Identifier Type
data State
State :: Header -> [Variable] -> [Constraint] -> State
[_headers] :: State -> Header
[_vars] :: State -> [Variable]
[_revCons] :: State -> [Constraint]
add :: Alt Attachment -> Type -> State -> TC State
emptyState :: State
addBinder :: Binder Attachment -> Type -> State -> TC State
addToHeaders :: Identifier -> Type -> State -> State
addData :: TConId -> [TVarId] -> DConId -> [Type] -> [Alt Attachment] -> Type -> State -> TC State
addDataArg :: Map TVarId Type -> Type -> Alt Attachment -> State -> TC State
addLit :: Literal -> Type -> State -> State

module IR.Constraint.Constrain.Expression

-- | HELPER ALIASES
type Def = (VarId, [Annotation], Variable, Expr Attachment)
type BinderDef = (Binder Attachment, Expr Attachment)

-- | DEFS
constrainBinderDefs :: [BinderDef] -> Constraint -> TC Constraint
constrainDefs :: [Def] -> Constraint -> TC Constraint
constrainRecDefs :: [Def] -> Constraint -> TC Constraint

-- | CONSTRAIN EXPRESSIONS
constrainExprAttached :: Expr Attachment -> Type -> TC Constraint
constrainExprAnnotated :: Expr Attachment -> [Annotation] -> Type -> TC Constraint
constrainExpr :: Expr Attachment -> Type -> TC Constraint
constrainLit :: Literal -> Type -> TC Constraint
constrainApp :: Expr Attachment -> Expr Attachment -> Type -> TC Constraint
constrainLambda :: Binder Attachment -> Expr Attachment -> Type -> TC Constraint
constrainMatch :: Expr Attachment -> [(Alt Attachment, Expr Attachment)] -> Type -> TC Constraint
constrainBranch :: Alt Attachment -> Expr Attachment -> Type -> Type -> TC Constraint
constrainPrim :: Primitive -> [Expr Attachment] -> Type -> TC Constraint
lookupPrim :: Int -> Primitive -> TC Scheme

module IR.Constraint.Constrain.Program
constrain :: Program (Annotations, Variable) -> TC Constraint

-- | EXTERN DECLS
constrainExternDecls :: [(VarId, Type)] -> Constraint -> TC Constraint
constrainExternDecl :: (VarId, Type) -> Constraint -> TC Constraint

-- | TYPE DEFS
constrainTypeDefs :: [(TConId, TypeDef)] -> Constraint -> TC Constraint
constrainTypeDef :: TConId -> TypeDef -> Constraint -> TC Constraint
constrainVariant :: TConId -> [TVarId] -> DConId -> TypeVariant -> Constraint -> TC Constraint

-- | HELPER: CONSTRAIN NAME TO TYPE
constrainDeclaration :: Identifier -> Scheme -> Constraint -> TC Constraint

module IR.Constraint.Constrain
run :: Program Annotations -> TC (Constraint, Program Variable)
sprinkleVariables :: Program Annotations -> TC (Program (Annotations, Variable))
discardAnnotations :: Program (Annotations, Variable) -> Program Variable

module IR.Constraint.Typechecking
typecheckProgram :: Program Annotations -> Bool -> Pass (Program Type, Maybe (Doc ann))


-- | Intermediate representation (IR) stages of the compiler pipeline.
module IR

-- | Operation modes for the IR compiler stage.
--   
--   By default, <a>Continue</a> completes the pipeline end-to-end.
data Mode
Continue :: Mode
DumpIR :: Mode
DumpIRAnnotated :: Mode
DumpIRConstraints :: Mode
DumpIRTyped :: Mode
DumpIRTypedUgly :: Mode
DumpIRInlined :: Mode
DumpIRTypedShow :: Mode
DumpIRLifted :: Mode
DumpIRFinal :: Mode

-- | Compiler options for the IR compiler stage.
newtype Options
Options :: Mode -> Options
[mode] :: Options -> Mode

-- | CLI options for the IR compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Lower from AST to IR (with annotations).
lower :: Options -> Program -> Pass (Program Annotations)

-- | Type inference + check against type annotations.
--   
--   After this stage, no compiler errors should be thrown.
typecheck :: Options -> Program Annotations -> Pass (Program Type)
anomalycheck :: Program Type -> Pass (Program Type)

-- | IR transformations to prepare for codegen.
transform :: Options -> Program Type -> Pass (Program Type)

-- | IR compiler stage.
run :: Options -> Program -> Pass (Program Type)
instance GHC.Show.Show IR.Mode
instance GHC.Classes.Eq IR.Mode
instance GHC.Show.Show IR.Options
instance GHC.Classes.Eq IR.Options
instance Common.Default.Default IR.Options
