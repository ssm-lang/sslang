-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/sedwards-lab/sslang#README</a>
@package sslang
@version 0.1.0.0


-- | Module for the <a>Default</a> type class.
module Common.Default

-- | Types with default values.
class Default a
def :: Default a => a


-- | Helpers for pretty-printing sslang, including common ASCII tokens.
module Common.Pretty

-- | <tt>typeAnn t d</tt> annotates document <tt>d</tt> with type
--   annotation <tt>t</tt>.
--   
--   Only used by spaghetti so constrained by Dumpy instead of Pretty for
--   now.
typeAnn :: Dumpy t => t -> Doc ann -> Doc ann

-- | <pre>
--   =&gt;
--   </pre>
drarrow :: Doc ann

-- | <pre>
--   &lt;-
--   </pre>
larrow :: Doc ann

-- | <pre>
--   -&gt;
--   </pre>
rarrow :: Doc ann

-- | <pre>
--   ||
--   </pre>
dbar :: Doc ann

-- | <pre>
--   |
--   </pre>
bar :: Doc ann

-- | <pre>
--   &amp;
--   </pre>
amp :: Doc ann

-- | Constructs a separator-delimited block <a>Doc</a> out of a list of
--   <a>Doc</a>s.
block :: Doc ann -> [Doc ann] -> Doc ann

-- | Number of spaces to indent
indentNo :: Int

-- | Format with a document of infinite width, preventing wraparound.
spaghetti :: Dumpy t => t -> String

-- | Lengthy Typeclass: print an ugly but parseable representation of the
--   AST
--   
--   <ul>
--   <li>Translates from IR to Doc representation in one-to-one
--   fashion</li>
--   <li>No simplifications</li>
--   <li>No whitespace formatting</li>
--   <li>Type annotates everything</li>
--   </ul>
class Dumpy a
dumpy :: Dumpy a => a -> Doc ann


-- | The types of identifiers used across the compiler.
--   
--   The types <a>VarId</a>, <a>TVarId</a>, <a>DConId</a>, and
--   <a>TConId</a> are used in the IR for data variables, type variables,
--   data constructors, and type constructors, which each inhabit a
--   separate namespace. The underlying <a>Identifier</a> type is used in
--   the AST, before these different kinds of identifiers are
--   differentiated by the lowering phase.
--   
--   These are defined as newtypes (rather than as type aliases) that
--   ultimately abstract over the underlying <a>String</a> Identifier. We
--   do this for a few reasons:
--   
--   <ul>
--   <li>The particular newtype carries semantic meaning in the IR, e.g.,
--   <a>VarId</a> is an identifier for data variables and nothing else.
--   This prevents semantically distinct items from being used in place of
--   one another (without explicit coercion). For example, this will
--   prevent accidentally using a type variable identifier as a data
--   constructor.</li>
--   <li>In the future, this may be extended to carry other (non-semantic)
--   metadata, such as source code location.</li>
--   <li>It allows us to freely attach typeclass instances to this type
--   without FlexibleInstances (since <a>String</a> is a type synonym for
--   <tt>[Char]</tt>).</li>
--   </ul>
--   
--   Users should never need to specifically use the data constructor for
--   each newtype, e.g., <tt>VarId (Identifier "foo")</tt>. Instead, each
--   identifier belongs to the <a>IsString</a> typeclass, that can be
--   written as <tt>fromString "foo"</tt>, so that the appropriate type can
--   be inferred from the context where the identifier is used.
--   Furthermore, the <a>fromString</a> call can be automatically inserted
--   by the OverloadedStrings GHC extension, meaning we can just write
--   <tt>"foo"</tt>.
--   
--   All identifier types are instances of the <a>Identifiable</a>
--   typeclass, which allows us to write generic functions that operate
--   over any kind of identifier. One can explicitly convert from an
--   identifier to another using the handy <a>fromId</a> helper; which
--   <i>specific</i> type of identifier may be inferred from the outer
--   context, or explicitly annotated (e.g., <tt>fromId i :: VarId</tt> to
--   construct a <a>VarId</a> out of identifier <tt>i</tt>).
module Common.Identifiers

-- | A type that may be used as a Sslang identifier.
class (IsString i, Ord i, Show i) => Identifiable i
ident :: Identifiable i => i -> String

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | Explicitly convert between two types of identifiers.
fromId :: (Identifiable a, Identifiable b) => a -> b

-- | Convert a showable instance to some kind of identifier.
showId :: (Show a, Identifiable b) => a -> b

-- | Identifier for type constructors, e.g., <tt>Option</tt>.
newtype TConId
TConId :: Identifier -> TConId

-- | ToIdentifier for type variable, e.g., <tt>a</tt>.
newtype TVarId
TVarId :: Identifier -> TVarId

-- | Identifier for data constructors, e.g., <tt>None</tt>.
newtype DConId
DConId :: Identifier -> DConId

-- | Identifier for data variables, e.g., <tt>x</tt>.
newtype VarId
VarId :: Identifier -> VarId

-- | de Bruijn index for type variables, e.g., <tt>'0</tt>
newtype TVarIdx
TVarIdx :: Int -> TVarIdx

-- | Identifier for C symbols, e.g., <tt>printf</tt>.
newtype CSym
CSym :: Identifier -> CSym

-- | Terms <tt>t</tt> that have free variables <tt>i</tt>
class Identifiable i => HasFreeVars t i | t -> i
freeVars :: HasFreeVars t i => t -> Set i

-- | A name to be bound; <a>Nothing</a> represents a wildcard, e.g.,
--   <tt>let _ = ...</tt>.
type Binder = Maybe VarId

-- | A generic Sslang identifier.
--   
--   Used as the type for identifiers in the AST.
--   
--   Also used as the base type for other identifiers (e.g., <a>TConId</a>,
--   <a>VarId</a>), which derive their typeclass instances from this.
newtype Identifier
Identifier :: String -> Identifier

-- | Whether an identifier refers to a type or data constructor.
isCons :: Identifiable a => a -> Bool

-- | Whether an identifier refers to a type or data variable.
--   
--   Note that internal variables (i.e., <tt>isIVar</tt>) are also
--   considered variables.
isVar :: Identifiable a => a -> Bool

-- | Mangle all identifiers in some data structure.
--   
--   This function is useful for preserving the general syntactic structure
--   of a datum without inspecting the <i>specific</i> identifiers used
--   within. This is useful for comparing ASTs modulo alpha renaming.
--   
--   The <tt>Proxy i</tt> parameter is used to specify exactly which kind
--   of identifier to mangle. For instance, to mangle all <a>VarId</a>
--   nodes:
--   
--   <pre>
--   mangleVarId :: Data a =&gt; a -&gt; a
--   mangleVarId = mangle (Proxy :: VarId)
--   </pre>
mangle :: (Identifiable i, Data i, Data a) => Proxy i -> a -> a

-- | Mangle all type and data variable identifiers.
mangleVars :: Data a => a -> a

-- | Whether an identifier is an compiler-generated variable name.
isGenerated :: Identifiable a => a -> Bool

-- | Generate an internal variable name (parenthesized) from some hint.
genId :: Identifiable a => a -> a

-- | Filter out generated identifiers.
ungenId :: Identifiable a => a -> Maybe a
instance Data.Data.Data Common.Identifiers.Identifier
instance GHC.Classes.Ord Common.Identifiers.Identifier
instance GHC.Classes.Eq Common.Identifiers.Identifier
instance Prettyprinter.Internal.Pretty Common.Identifiers.TConId
instance GHC.Base.Monoid Common.Identifiers.TConId
instance GHC.Base.Semigroup Common.Identifiers.TConId
instance Common.Identifiers.Identifiable Common.Identifiers.TConId
instance Data.String.IsString Common.Identifiers.TConId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.TConId
instance Data.Data.Data Common.Identifiers.TConId
instance GHC.Classes.Ord Common.Identifiers.TConId
instance GHC.Classes.Eq Common.Identifiers.TConId
instance Prettyprinter.Internal.Pretty Common.Identifiers.TVarId
instance GHC.Base.Monoid Common.Identifiers.TVarId
instance GHC.Base.Semigroup Common.Identifiers.TVarId
instance Common.Identifiers.Identifiable Common.Identifiers.TVarId
instance Data.String.IsString Common.Identifiers.TVarId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.TVarId
instance Data.Data.Data Common.Identifiers.TVarId
instance GHC.Classes.Ord Common.Identifiers.TVarId
instance GHC.Classes.Eq Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty Common.Identifiers.DConId
instance GHC.Base.Monoid Common.Identifiers.DConId
instance GHC.Base.Semigroup Common.Identifiers.DConId
instance Common.Identifiers.Identifiable Common.Identifiers.DConId
instance Data.String.IsString Common.Identifiers.DConId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.DConId
instance Data.Data.Data Common.Identifiers.DConId
instance GHC.Classes.Ord Common.Identifiers.DConId
instance GHC.Show.Show Common.Identifiers.DConId
instance GHC.Classes.Eq Common.Identifiers.DConId
instance Prettyprinter.Internal.Pretty Common.Identifiers.VarId
instance GHC.Base.Monoid Common.Identifiers.VarId
instance GHC.Base.Semigroup Common.Identifiers.VarId
instance Common.Identifiers.Identifiable Common.Identifiers.VarId
instance Data.String.IsString Common.Identifiers.VarId
instance Language.C.Quote.Base.ToIdent Common.Identifiers.VarId
instance Data.Data.Data Common.Identifiers.VarId
instance GHC.Classes.Ord Common.Identifiers.VarId
instance GHC.Show.Show Common.Identifiers.VarId
instance GHC.Classes.Eq Common.Identifiers.VarId
instance Prettyprinter.Internal.Pretty Common.Identifiers.CSym
instance GHC.Base.Monoid Common.Identifiers.CSym
instance GHC.Base.Semigroup Common.Identifiers.CSym
instance Common.Identifiers.Identifiable Common.Identifiers.CSym
instance Data.String.IsString Common.Identifiers.CSym
instance Language.C.Quote.Base.ToIdent Common.Identifiers.CSym
instance Data.Data.Data Common.Identifiers.CSym
instance GHC.Classes.Ord Common.Identifiers.CSym
instance GHC.Show.Show Common.Identifiers.CSym
instance GHC.Classes.Eq Common.Identifiers.CSym
instance Data.Data.Data Common.Identifiers.TVarIdx
instance GHC.Classes.Ord Common.Identifiers.TVarIdx
instance GHC.Classes.Eq Common.Identifiers.TVarIdx
instance GHC.Show.Show Common.Identifiers.TVarIdx
instance Prettyprinter.Internal.Pretty Common.Identifiers.TVarIdx
instance GHC.Show.Show Common.Identifiers.TVarId
instance GHC.Show.Show Common.Identifiers.TConId
instance Data.String.IsString Common.Identifiers.Identifier
instance Common.Identifiers.Identifiable Common.Identifiers.Identifier
instance GHC.Show.Show Common.Identifiers.Identifier
instance Language.C.Quote.Base.ToIdent Common.Identifiers.Identifier
instance GHC.Base.Semigroup Common.Identifiers.Identifier
instance GHC.Base.Monoid Common.Identifiers.Identifier
instance Prettyprinter.Internal.Pretty Common.Identifiers.Identifier


-- | Bindings to the ssm-runtime library.
module Codegen.LibSSM

-- | Identifiers in C.
newtype CIdent
CIdent :: Identifier -> CIdent

-- | Construct a type name from a C identifier.
ctype :: CIdent -> Type

-- | Construct an expression from a C identifier.
cexpr :: CIdent -> Exp

-- | Construct an expression of the size of a C type.
csizeof :: Type -> Exp

-- | Construct an integer literal in C.
cint :: Int -> Exp
ccall :: Exp -> [Exp] -> Exp
amp :: Exp -> Exp
star :: Exp -> Exp

-- | Natively supported sizes in C.
data CSize
Size8 :: CSize
Size16 :: CSize
Size32 :: CSize
Size64 :: CSize

-- | Convert a <a>CSize</a> into an integer.
size_to_int :: CSize -> Int

-- | Convert a <a>CSize</a> into some string identifier of the size.
size_to_string :: IsString s => CSize -> s

-- | <tt>enum ssm_error</tt>, an enumeration of possible runtime errors.
data SSMError

-- | Reserved for unforeseen, non-user-facing errors.
INTERNAL_ERROR :: SSMError

-- | Tried to insert into full ready queue.
EXHAUSTED_ACT_QUEUE :: SSMError

-- | Tried to insert into full event queue.
EXHAUSTED_EVENT_QUEUE :: SSMError

-- | Could not allocate more memory.
EXHAUSTED_MEMORY :: SSMError

-- | Tried to exceed available recursion depth.
EXHAUSTED_PRIORITY :: SSMError

-- | Not yet ready to perform the requested action.
NOT_READY :: SSMError

-- | Specified invalid time.
INVALID_TIME :: SSMError

-- | Invalid memory layout.
INVALID_MEMORY :: SSMError

-- | <tt>SSM_THROW</tt>, throw a runtime error.
throw :: SSMError -> Exp

-- | <tt>ssm_word_t</tt>, the largest supported machine word size.
word_t :: Type

-- | <tt>ssm_value_t</tt>, runtime representation for sslang values.
value_t :: Type

-- | Name of the <tt>packed_val</tt> field in a <a>value_t</a>.
packed_val :: CIdent

-- | Name of the <tt>heap_ptr</tt> field in a <a>value_t</a>.
heap_ptr :: CIdent

-- | <tt>ssm_marshal</tt>, construct a <a>value_t</a> out of a 31-bit
--   integral value.
marshal :: Exp -> Exp

-- | <tt>ssm_unmarshal</tt>, extract 31-bit integral value out of a
--   <a>value_t</a>.
unmarshal :: Exp -> Exp

-- | <tt>ssm_on_heap</tt>, whether a <a>value_t</a> points to something on
--   the heap.
on_heap :: Exp -> Exp

-- | <tt>ssm_dup</tt>, increment the reference count of a value.
dup :: Exp -> Exp

-- | <tt>ssm_dups</tt>, increment the reference count on a vector of
--   values.
dups :: Exp -> Exp -> Exp

-- | <tt>ssm_drop</tt>, drop the reference count of a value and free if
--   necessary.
drop :: Exp -> Exp

-- | <tt>ssm_time_t</tt>, 64-bit time type.
time_t :: Type

-- | <tt>struct ssm_time</tt>, the heap-representation of a <a>time_t</a>.
time_obj_t :: Type

-- | <tt>SSM_NEVER</tt>, a <a>time_t</a> that is never reached.
never :: Exp

-- | <tt>ssm_now</tt>, the current time.
now :: Exp

-- | <tt>ssm_new_time</tt>, allocate a <a>time_obj_t</a> on the heap.
new_time :: Exp -> Exp

-- | <tt>ssm_time_read</tt>, read the time in a <a>time_obj_t</a>.
read_time :: Exp -> Exp

-- | <tt>ssm_priority_t</tt>, thread priority.
priority_t :: Type

-- | <tt>ssm_depth_t</tt>, thread depth.
depth_t :: Type

-- | <tt>SSM_ROOT_PRIORITY</tt>, the depth of the root process.
root_priority :: Exp

-- | <tt>SSM_ROOT_DEPTH</tt>, the depth of the root process.
root_depth :: Exp

-- | <tt>ssm_act_t</tt>, the generic activation record type.
act_t :: Type

-- | Name of the program counter field in an <a>act_t</a>.
act_pc :: CIdent

-- | Name of the caller field in an <a>act_t</a>.
act_caller :: CIdent

-- | Name of the depth field in an <a>act_t</a>.
act_depth :: CIdent

-- | Name of the priority field in an <a>act_t</a>.
act_priority :: CIdent

-- | <tt>ssm_trigger_t</tt>, nodes in the linked list of triggers.
trigger_t :: Type

-- | <tt>ssm_enter</tt>, allocate and initialize activation record.
enter :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_leave</tt>, deallocate an activation record before leaving.
leave :: Exp -> Exp -> Exp

-- | <tt>ssm_has_children</tt>, returns non-zero if <tt>act</tt> has at
--   least one child.
has_children :: Exp -> Exp

-- | <tt>ssm_activate</tt>, schedule an activation record on the ready
--   queue.
activate :: Exp -> Exp

-- | <tt>ssm_top_parent</tt>, Name of top level parent activation record
top_parent :: Exp

-- | <tt>ssm_sv_t</tt>, polymorphic scheduled variables.
sv_t :: Type

-- | <tt>ssm_new_sv</tt>, allocate a new <a>sv_t</a> on the heap.
new_sv :: Exp -> Exp

-- | <tt>ssm_to_sv</tt>, retrieve the <a>sv_t</a> pointer pointed to by a
--   <a>value_t</a>.
to_sv :: Exp -> Exp

-- | <tt>ssm_deref</tt>, read the value of an <a>sv_t</a> pointed to by a
--   <a>value_t</a>.
deref :: Exp -> Exp

-- | <tt>ssm_assign</tt>, assign to a scheduled variable.
assign :: Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_later</tt>, schedule a delayed assignment to a scheduled
--   variable.
later :: Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_sensitize</tt>, sensitize a trigger to a variable.
sensitize :: Exp -> Exp -> Exp

-- | <tt>ssm_sensitize</tt>, sensitize a trigger to a variable.
desensitize :: Exp -> Exp

-- | <tt>ssm_new_adt</tt>, allocate a new ADT object on the heap.
new_adt :: Int -> DConId -> Exp

-- | <tt>ssm_adt_field</tt>, access the <tt>i</tt>th field of an ADT
--   object. Assignable.
adt_field :: Exp -> Int -> Exp

-- | <tt>ssm_tag</tt>, extract the tag of an ADT value.
adt_tag :: Exp -> Exp

-- | <tt>ssm_closure1_t</tt>, the (template) type of a closure with a
--   single argument.
closure1_t :: Type

-- | Inintializer for a "static" closure that contains no arguments.
--   
--   FIXME: An ugly hack that shouldn't exist because John didn't have the
--   foresight to provide an interface to define static closures.
static_closure :: Exp -> Int -> Initializer

-- | Promote a static object to an <tt>ssm_value_t</tt> (warning: hacky!).
static_value :: CIdent -> Exp

-- | <tt>ssm_new_closure</tt>, allocate a new closure object on the heap.
new_closure :: CIdent -> Int -> Exp

-- | <tt>ssm_closure_push</tt>, add a new argument to a closure.
closure_push :: Exp -> Exp -> Exp

-- | <tt>ssm_closure_pop</tt>, remove an argument from a closure.
closure_pop :: Exp -> Exp

-- | <tt>ssm_closure_apply</tt>, apply a closure to an argument.
closure_apply :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_closure_apply</tt>, apply a closure to an argument, consuming
--   the closure.
closure_apply_final :: Exp -> Exp -> Exp -> Exp -> Exp -> Exp -> Exp

-- | <tt>ssm_closure_free</tt>, free a closure (without performing
--   reference counting).
closure_free :: Exp -> Exp

-- | Name of the pseudonymous macro from the Linux kernel.
container_of :: CIdent

-- | Name of program initialization hook, called to set up program with
--   runtime.
program_init :: CIdent

-- | Name of program destruction hook, called before gracefully exiting
--   program.
program_exit :: CIdent

-- | Name of stdout handler enter function, used to bind stdout for POSIX
--   platforms. NOTE: this is a hack
stdout_handler_enter :: CIdent

-- | Name of stdin handler spawner, used to bind stdin for POSIX platforms.
--   NOTE: this is a hack
stdin_handler_spawn :: CIdent

-- | Name of stdin handler killer, used to destroy handler thread on POSIX.
--   NOTE: this is a hack
stdin_handler_kill :: CIdent

-- | Obtain the name of a process activation record struct.
act_typename :: VarId -> CIdent

-- | Identifier for act member in act struct.
act_member :: CIdent

-- | Obtain the type of a process activation record.
act_ :: VarId -> Type

-- | Obtain the process-specific activation record from a generic one.
to_act :: Exp -> VarId -> Exp

-- | Obtain the name for the enter function of a routine.
enter_ :: VarId -> CIdent

-- | Obtain the name for the static closure of a routine.
closure_ :: VarId -> CIdent

-- | Obtain the name of the step function of a routine.
step_ :: VarId -> CIdent

-- | Obtain the name of each trigger for a routine.
trig_ :: Int -> CIdent

-- | Obtain the name of a temporary variable.
tmp_ :: Int -> CIdent

-- | Obtain the name of a label.
label_ :: Int -> CIdent

-- | Obtain the name of an argument variable.
arg_ :: Int -> CIdent

-- | Obtain the name of an argument variable.
argv :: CIdent

-- | Name of return argument.
ret_val :: CIdent

-- | Identifier for generic (inner) struct act.
actg :: CIdent

-- | Identifier for specialized (outer) struct act.
acts :: CIdent

-- | Access activation record member.
acts_ :: CIdent -> Exp

-- | Name of the caller argument of an enter call.
enter_caller :: CIdent

-- | Name of the priority argument of an enter call.
enter_priority :: CIdent

-- | Name of the depth argument of an enter call.
enter_depth :: CIdent

-- | Label to jump to terminate execution.
leave_label :: CIdent

-- | Cast to a signed integer of a particular size.
cast_to_signed :: CSize -> Exp -> Exp

-- | Cast to an unsigned integer of a particular size.
cast_to_unsigned :: CSize -> Exp -> Exp

-- | Cast to an integer of a particular size and signedness.
cast_to_int :: Bool -> CSize -> Exp -> Exp

-- | Shift left by the specified amount.
shl :: Exp -> Exp -> Exp

-- | Shift right by the specified amount.
shr :: Exp -> Exp -> Exp
instance GHC.Base.Monoid Codegen.LibSSM.CIdent
instance GHC.Base.Semigroup Codegen.LibSSM.CIdent
instance Language.C.Quote.Base.ToIdent Codegen.LibSSM.CIdent
instance Common.Identifiers.Identifiable Codegen.LibSSM.CIdent
instance Data.String.IsString Codegen.LibSSM.CIdent
instance GHC.Show.Show Codegen.LibSSM.CIdent
instance GHC.Classes.Ord Codegen.LibSSM.CIdent
instance GHC.Classes.Eq Codegen.LibSSM.CIdent
instance GHC.Classes.Ord Codegen.LibSSM.CSize
instance GHC.Classes.Eq Codegen.LibSSM.CSize
instance GHC.Show.Show Codegen.LibSSM.SSMError
instance Language.C.Quote.Base.ToIdent Codegen.LibSSM.SSMError


-- | Data types and helpers used to compose the compiler pipeline.
module Common.Compiler

-- | Type for error messages.
data ErrorMsg

-- | Types of compiler errors that can be thrown during compilation.
data Error

-- | Halt compiler to dump output (not an error)
Dump :: String -> Error

-- | Internal error; should be unreachable
UnexpectedError :: ErrorMsg -> Error

-- | "It's a research artifact"
UnimplementedError :: ErrorMsg -> Error

-- | Round peg in square hole
TypeError :: ErrorMsg -> Error

-- | Identifier is out of scope
ScopeError :: ErrorMsg -> Error

-- | Invalid naming convention at binding
NameError :: ErrorMsg -> Error

-- | Malformed pattern
PatternError :: ErrorMsg -> Error

-- | Error encountered by scanner
LexError :: ErrorMsg -> Error

-- | Error encountered by parser
ParseError :: ErrorMsg -> Error

-- | Types of compiler warnings that can be logged during compilation.
data Warning

-- | Warning about type
TypeWarning :: ErrorMsg -> Warning

-- | Warning related to identifier names
NameWarning :: ErrorMsg -> Warning

-- | Warning related to patterns
PatternWarning :: ErrorMsg -> Warning

-- | The compiler pipeline monad; supports throwing errors, logging, etc.
newtype Pass a
Pass :: PassMonad a -> Pass a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Invoke a compiler <a>Pass</a>.
runPass :: Pass a -> Either Error (a, [Warning])

-- | Dump pretty-printable output from within a compiler pass.
dump :: Pretty a => a -> Pass x

-- | Report unexpected compiler error and halt pipeline.
unexpected :: MonadError Error m => String -> m a

-- | Log a compiler warning.
warn :: MonadWriter [Warning] m => Warning -> m ()

-- | Report unexpected compiler error and halt pipeline.
todo :: MonadError Error m => String -> m a

-- | Execute compiler pass in I/O monad, exiting upon exception.
passIO :: Pass a -> IO (a, [Warning])

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | Throw a type error with some String error message.
typeError :: MonadError Error m => String -> m a
instance GHC.Base.Monoid Common.Compiler.ErrorMsg
instance GHC.Base.Semigroup Common.Compiler.ErrorMsg
instance GHC.Show.Show Common.Compiler.ErrorMsg
instance GHC.Classes.Eq Common.Compiler.Error
instance GHC.Show.Show Common.Compiler.Error
instance GHC.Classes.Eq Common.Compiler.Warning
instance GHC.Show.Show Common.Compiler.Warning
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Common.Compiler.Pass
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Common.Compiler.Pass
instance GHC.Base.Monad Common.Compiler.Pass
instance GHC.Base.Applicative Common.Compiler.Pass
instance GHC.Base.Functor Common.Compiler.Pass
instance Control.Monad.Fail.MonadFail Common.Compiler.Pass
instance Data.String.IsString Common.Compiler.ErrorMsg
instance GHC.Classes.Eq Common.Compiler.ErrorMsg


-- | Sslang abstract syntax tree.
module Front.Ast

-- | A complete program: a list of top-level definitions.
newtype Program
Program :: [TopDef] -> Program

-- | A top-level definition.
data TopDef

-- | Bind a (data) value to a variable
TopDef :: Definition -> TopDef

-- | Define an algebraic data type
TopType :: TypeDef -> TopDef

-- | Inlined block of C definitions
TopCDefs :: String -> TopDef

-- | Declare external symbol for FFI
TopExtern :: ExternDecl -> TopDef

-- | Associate a type with a symbol
data ExternDecl
ExternDecl :: Identifier -> Typ -> ExternDecl

-- | An algebraic data type definition.
data TypeDef
TypeDef :: Identifier -> [Identifier] -> [TypeVariant] -> TypeDef

-- | The name of the type, e.g., <tt>Option</tt>
[typeName] :: TypeDef -> Identifier

-- | List of type parameters, e.g., <tt>a</tt>
[typeParams] :: TypeDef -> [Identifier]

-- | List of variants, e.g., <tt>Some</tt>, <tt>None</tt>
[typeVariants] :: TypeDef -> [TypeVariant]

-- | A type variant, i.e., a data constructor.
data TypeVariant
VariantUnnamed :: Identifier -> [Typ] -> TypeVariant

-- | A value definition.
data Definition
DefFn :: Identifier -> [Pat] -> TypFn -> Expr -> Definition
DefPat :: Pat -> Expr -> Definition

-- | A pattern appearing on the LHS of a definition or match arm
data Pat

-- | Match anything, i.e., <tt>_</tt>
PatWildcard :: Pat

-- | Variable or data constructor, e.g., <tt>v</tt> or <tt>Some</tt>
PatId :: Identifier -> Pat

-- | Literal match, e.g., <tt>1</tt>
PatLit :: Literal -> Pat

-- | Pattern alias, e.g., <tt>a @ <a>pat</a></tt>
PatAs :: Identifier -> Pat -> Pat

-- | Match on a tuple, e.g., <tt>(<a>pat</a>, <a>pat</a>)</tt>
PatTup :: [Pat] -> Pat

-- | Match on multiple patterns, e.g., <tt>Some a</tt>
PatApp :: [Pat] -> Pat

-- | Match with type annotation, e.g., <tt><a>pat</a>: Type</tt>
PatAnn :: Typ -> Pat -> Pat

-- | Function type annotation
data TypFn
TypReturn :: TypAnn -> TypFn
TypProper :: TypAnn -> TypFn
TypNone :: TypFn

-- | TODO: type classes
type TypAnn = Typ

-- | A type definition
data Typ
TCon :: Identifier -> Typ
TApp :: Typ -> Typ -> Typ
TTuple :: [Typ] -> Typ
TArrow :: Typ -> Typ -> Typ

-- | An expression
data Expr
Id :: Identifier -> Expr
Lit :: Literal -> Expr
Apply :: Expr -> Expr -> Expr
Lambda :: [Pat] -> Expr -> Expr
OpRegion :: Expr -> OpRegion -> Expr
NoExpr :: Expr
Let :: [Definition] -> Expr -> Expr
While :: Expr -> Expr -> Expr
Loop :: Expr -> Expr
Par :: [Expr] -> Expr
IfElse :: Expr -> Expr -> Expr -> Expr
After :: Expr -> Expr -> Expr -> Expr
Assign :: Expr -> Expr -> Expr
Constraint :: Expr -> TypAnn -> Expr
Wait :: [Expr] -> Expr
Seq :: Expr -> Expr -> Expr
Break :: Expr
Match :: Expr -> [(Pat, Expr)] -> Expr
CQuote :: String -> Expr
CCall :: Identifier -> [Expr] -> Expr

-- | An operator region: a flat list of alternating expressions and
--   operators that is initially parsed flat but will be restructured into
--   a tree by the operator precedence parser.
data OpRegion
NextOp :: Identifier -> Expr -> OpRegion -> OpRegion
EOR :: OpRegion

-- | A literal
data Literal
LitInt :: Integer -> Literal
LitString :: String -> Literal
LitRat :: Rational -> Literal
LitChar :: Char -> Literal
LitEvent :: Literal

-- | Fixity declaration for binary operators.
data Fixity
Infixl :: Int -> Identifier -> Fixity
Infixr :: Int -> Identifier -> Fixity

-- | Collect a type application into the type constructor and its
--   arguments.
collectTApp :: Typ -> (Typ, [Typ])

-- | Collect a curried application into the function and its list of
--   arguments.
collectApp :: Expr -> (Expr, [Expr])

-- | Collect a pattern application into the destructor and arguments.
collectPApp :: Pat -> (Pat, [Pat])

-- | Unwrap a (potential) top-level data definition.
getTopDataDef :: TopDef -> Maybe Definition

-- | Unwrap a (potential) top-level type definition.
getTopTypeDef :: TopDef -> Maybe TypeDef

-- | Unwrap a (potential) top-level C inline block.
getTopCDefs :: TopDef -> Maybe String

-- | Unwrap a (potential) top-level external definition.
getTopExtern :: TopDef -> Maybe ExternDecl

-- | Unzip a list of top-level declarations into their counterparts.
getTops :: [TopDef] -> ([TypeDef], [String], [ExternDecl], [Definition])
instance GHC.Show.Show Front.Ast.Typ
instance GHC.Classes.Eq Front.Ast.Typ
instance GHC.Show.Show Front.Ast.TypFn
instance GHC.Classes.Eq Front.Ast.TypFn
instance GHC.Show.Show Front.Ast.TypeVariant
instance GHC.Classes.Eq Front.Ast.TypeVariant
instance GHC.Show.Show Front.Ast.TypeDef
instance GHC.Classes.Eq Front.Ast.TypeDef
instance GHC.Show.Show Front.Ast.ExternDecl
instance GHC.Classes.Eq Front.Ast.ExternDecl
instance GHC.Show.Show Front.Ast.Literal
instance GHC.Classes.Eq Front.Ast.Literal
instance GHC.Show.Show Front.Ast.Pat
instance GHC.Classes.Eq Front.Ast.Pat
instance GHC.Show.Show Front.Ast.OpRegion
instance GHC.Classes.Eq Front.Ast.OpRegion
instance GHC.Show.Show Front.Ast.Expr
instance GHC.Classes.Eq Front.Ast.Expr
instance GHC.Show.Show Front.Ast.Definition
instance GHC.Classes.Eq Front.Ast.Definition
instance GHC.Show.Show Front.Ast.TopDef
instance GHC.Classes.Eq Front.Ast.TopDef
instance GHC.Show.Show Front.Ast.Program
instance GHC.Classes.Eq Front.Ast.Program
instance Prettyprinter.Internal.Pretty Front.Ast.Program
instance Common.Pretty.Dumpy Front.Ast.Program
instance Prettyprinter.Internal.Pretty Front.Ast.TopDef
instance Prettyprinter.Internal.Pretty Front.Ast.Definition
instance Prettyprinter.Internal.Pretty Front.Ast.Expr
instance Prettyprinter.Internal.Pretty Front.Ast.Pat
instance Prettyprinter.Internal.Pretty Front.Ast.Literal
instance Prettyprinter.Internal.Pretty Front.Ast.ExternDecl
instance Prettyprinter.Internal.Pretty Front.Ast.TypeDef
instance Prettyprinter.Internal.Pretty Front.Ast.TypeVariant
instance Prettyprinter.Internal.Pretty Front.Ast.TypFn
instance Prettyprinter.Internal.Pretty Front.Ast.Typ


-- | Identifiers, associated metadata, and reserved identifiers.
module Front.Identifiers

-- | Where an identifier comes from.
data IdKind

-- | User- and library-defined identifiers, e.g., <tt>foo</tt>.
User :: IdKind

-- | Builtin identifiers, e.g., <tt>new</tt> and <tt>deref</tt>.
Builtin :: IdKind

-- | Unused, but user should not be able to define.
Reserved :: IdKind

-- | Metadata associated with a data identifier.
newtype DataInfo
DataInfo :: IdKind -> DataInfo
[dataKind] :: DataInfo -> IdKind

-- | Metadata associated with a type identifier.
newtype TypInfo
TypInfo :: IdKind -> TypInfo
[typKind] :: TypInfo -> IdKind

-- | Map of builtin types.
builtinTypes :: Map Identifier TypInfo

-- | Map of builtin data.
builtinData :: Map Identifier DataInfo
instance GHC.Classes.Eq Front.Identifiers.IdKind
instance GHC.Show.Show Front.Identifiers.IdKind
instance Common.Default.Default Front.Identifiers.TypInfo
instance Common.Default.Default Front.Identifiers.DataInfo


-- | Parse OpRegion nodes inside of an AST <a>Program</a>.
module Front.ParseOperators

-- | Parse OpRegion nodes inside of an AST <a>Program</a>.
parseOperators :: Program -> Pass Program

-- | Fixity declaration for binary operators.
data Fixity
Infixl :: Int -> Identifier -> Fixity
Infixr :: Int -> Identifier -> Fixity

module Front.Pattern.Common
data CInfo
CInfo :: Identifier -> Identifier -> Int -> CInfo
[cName] :: CInfo -> Identifier
[cType] :: CInfo -> Identifier
[cArity] :: CInfo -> Int
data TInfo
TInfo :: Identifier -> Set Identifier -> TInfo
[tName] :: TInfo -> Identifier
[tCSet] :: TInfo -> Set Identifier
buildTypeMap :: [TypeDef] -> Map Identifier TInfo
buildConsMap :: [TypeDef] -> Map Identifier CInfo
instance GHC.Show.Show Front.Pattern.Common.CInfo
instance GHC.Classes.Eq Front.Pattern.Common.CInfo
instance GHC.Show.Show Front.Pattern.Common.TInfo
instance GHC.Classes.Eq Front.Pattern.Common.TInfo

module Front.Pattern.Desugar
type Equation = ([Pat], Expr)
type Arm = (Pat, Expr)
data DesugarCtx
DesugarCtx :: Map Identifier TInfo -> Map Identifier CInfo -> Int -> DesugarCtx
[typeMap] :: DesugarCtx -> Map Identifier TInfo
[consMap] :: DesugarCtx -> Map Identifier CInfo
[anonCount] :: DesugarCtx -> Int
newtype DesugarFn a
DesugarFn :: StateT DesugarCtx Pass a -> DesugarFn a
runDesugarFn :: DesugarFn a -> DesugarCtx -> Pass a
freshVar :: DesugarFn Identifier
buildCtx :: [TypeDef] -> DesugarCtx
desugarProgram :: Program -> Pass Program
desugarTopDefs :: [TopDef] -> DesugarFn [TopDef]
desugarDefs :: [Definition] -> DesugarFn [Definition]
desugarDef :: Definition -> DesugarFn Definition
desugarExprs :: [Expr] -> DesugarFn [Expr]
desugarExpr :: Expr -> DesugarFn Expr
desugarOpRegion :: OpRegion -> DesugarFn OpRegion
desugarMatch :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchGen :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchVar :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchWild :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchCons :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchLit :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchTup :: [Identifier] -> [Equation] -> Expr -> DesugarFn Expr
desugarMatchIdCons :: [Equation] -> DesugarFn [Equation]
desugarMatchAsAnn :: [Identifier] -> [Equation] -> DesugarFn [Equation]
partitionEqs :: [Equation] -> [[Equation]]
substId :: Identifier -> Identifier -> Expr -> Expr
singleLet :: Identifier -> Expr -> Expr -> Expr
singleAlias :: Identifier -> Identifier -> Expr -> Expr
singleAliasWithTyp :: Identifier -> Identifier -> Typ -> Expr -> Expr
getConstructors :: Identifier -> DesugarFn (Set Identifier)
getArity :: Identifier -> DesugarFn Int
getCInfo :: Identifier -> DesugarFn CInfo
getTInfo :: Identifier -> DesugarFn TInfo
foldrM :: Monad m => (a -> b -> m b) -> b -> [a] -> m b
throwDesugarError :: DesugarFn a
throwInexhaustionError :: DesugarFn a
instance Control.Monad.State.Class.MonadState Front.Pattern.Desugar.DesugarCtx Front.Pattern.Desugar.DesugarFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Pattern.Desugar.DesugarFn
instance Control.Monad.Fail.MonadFail Front.Pattern.Desugar.DesugarFn
instance GHC.Base.Monad Front.Pattern.Desugar.DesugarFn
instance GHC.Base.Applicative Front.Pattern.Desugar.DesugarFn
instance GHC.Base.Functor Front.Pattern.Desugar.DesugarFn

module Front.Pattern.Vector
data PatVec
PatVec :: Int -> [Pat] -> PatVec
[ncol] :: PatVec -> Int
[toList] :: PatVec -> [Pat]
fromList :: [Pat] -> PatVec
singleton :: Pat -> PatVec
extend :: PatVec -> PatVec -> PatVec
append :: Pat -> PatVec -> PatVec
hd :: PatVec -> Pat
tl :: PatVec -> PatVec
specialize :: PatVec -> PatVec
specializeWild :: Int -> PatVec -> PatVec
instance GHC.Show.Show Front.Pattern.Vector.PatVec
instance GHC.Classes.Eq Front.Pattern.Vector.PatVec

module Front.Pattern.Matrix
data PatMat
PatMat :: Int -> Int -> [PatVec] -> PatMat
[nrow] :: PatMat -> Int
[ncol] :: PatMat -> Int
[toList] :: PatMat -> [PatVec]
singleCol :: [Pat] -> PatMat
singleRow :: [Pat] -> PatMat
fromPatVec :: PatVec -> PatMat
emptyWithCols :: Int -> PatMat
hd :: PatMat -> PatVec
tl :: PatMat -> PatMat
extend :: PatMat -> PatMat -> PatMat
prepend :: PatVec -> PatMat -> PatMat
specializeLit :: Literal -> PatMat -> PatMat
specializeTup :: Int -> PatMat -> PatMat
specializeCons :: Int -> Identifier -> PatMat -> PatMat
defaultize :: PatMat -> PatMat
instance GHC.Show.Show Front.Pattern.Matrix.PatMat
instance GHC.Classes.Eq Front.Pattern.Matrix.PatMat

module Front.Pattern.Anomaly
data AnomalyCtx
AnomalyCtx :: Map Identifier TInfo -> Map Identifier CInfo -> AnomalyCtx
[typeMap] :: AnomalyCtx -> Map Identifier TInfo
[consMap] :: AnomalyCtx -> Map Identifier CInfo
newtype AnomalyFn a
AnomalyFn :: ReaderT AnomalyCtx Pass a -> AnomalyFn a
buildCtx :: [TypeDef] -> AnomalyCtx

-- | Run a AnomalyFn computation.
runAnomalyFn :: AnomalyFn a -> AnomalyCtx -> Pass a
checkProgram :: Program -> Pass ()
checkDefs :: [Definition] -> AnomalyFn ()
checkDef :: Definition -> AnomalyFn ()
checkExprs :: [Expr] -> AnomalyFn ()
checkExpr :: Expr -> AnomalyFn ()
checkOpRegion :: OpRegion -> AnomalyFn ()
checkPats :: [Pat] -> AnomalyFn ()
checkUselessArm :: [Pat] -> AnomalyFn ()
checkExhaustive :: [Pat] -> AnomalyFn ()
useful :: PatVec -> PatMat -> AnomalyFn Bool
usefulWildLit :: LitType -> PatVec -> PatMat -> AnomalyFn Bool
samplePat :: PatMat -> Maybe Pat
hasCompleteCons :: Set Identifier -> PatMat -> Bool
hasCompleteLit :: LitType -> PatMat -> Bool
wellFormed :: PatVec -> PatMat -> AnomalyFn ()
wellFormedPat :: Pat -> PatMat -> AnomalyFn ()
wellFormedCons :: TInfo -> PatMat -> AnomalyFn ()
wellFormedTup :: Int -> PatMat -> AnomalyFn ()
wellFormedLit :: Literal -> PatMat -> AnomalyFn ()
wellFormedWild :: PatMat -> AnomalyFn ()
data LitType
LitIntT :: LitType
LitStringT :: LitType
LitRatT :: LitType
LitCharT :: LitType
LitEventT :: LitType
litToType :: Literal -> LitType
askCInfo :: Identifier -> AnomalyFn CInfo
askTInfo :: Identifier -> AnomalyFn TInfo

-- | Report <a>Identifier</a> for error reporting.
showId :: Identifier -> ErrorMsg
showSet :: Set Identifier -> ErrorMsg
throwMalformedError :: AnomalyFn a
instance Control.Monad.Reader.Class.MonadReader Front.Pattern.Anomaly.AnomalyCtx Front.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Front.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Pattern.Anomaly.AnomalyFn
instance Control.Monad.Fail.MonadFail Front.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Monad Front.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Applicative Front.Pattern.Anomaly.AnomalyFn
instance GHC.Base.Functor Front.Pattern.Anomaly.AnomalyFn
instance GHC.Show.Show Front.Pattern.Anomaly.LitType
instance GHC.Classes.Eq Front.Pattern.Anomaly.LitType

module Front.Pattern
desugarProgram :: Program -> Pass Program
checkAnomaly :: Program -> Pass ()


-- | Check scoping rules and naming conventions for identifiers.
--   
--   Here, we ensure that all identifiers that appear in the AST only
--   appear after they are previously declared or defined.
--   
--   Identifiers can be segregated into two categories: data identifiers,
--   which produce expressions, and type identifiers, which produce types
--   (more accurately, type expressions). These inhabit separate namespaces
--   and are distinguished by the different contexts in which they are
--   used.
--   
--   Of each category, there are two kinds of identifiers: constructors and
--   variables. Constructors must begin with an upper case letter or a
--   colon (<tt>:</tt>); all other identifiers are variables (see
--   <a>isCons</a> and <a>isVar</a>). For instance, data constructors name
--   the variants of an algebraic data type, while data variables name
--   values bound by a let-binding, a pattern-match, or a lambda.
--   Meanwhile, type constructors are points in the type system defined by
--   the user, while type variables are universally quantified in each type
--   expression.
--   
--   Consider the following example:
--   
--   @@ type Bool = True False
--   
--   type Either t u = Left t Right u
--   
--   liftEither b x y: Bool -&gt; a -&gt; b -&gt; Either a b = match b True
--   = Left x False = Right y @@
--   
--   Data variables are <tt>switch</tt>, <tt>b</tt>, <tt>x</tt>, and
--   <tt>y</tt>; data constructors are <tt>True</tt>, <tt>False</tt>,
--   <tt>Left</tt>, and <tt>Right</tt>. Type variables are <tt>t</tt>,
--   <tt>u</tt>, <tt>a</tt>, and <tt>b</tt>; type constructors are
--   <tt>Bool</tt> and <tt>Either</tt>.
--   
--   The grammar as it appears in the parser does not actually distinguish
--   between any of these kinds of identifiers, so it is the responsibility
--   of this module to check that, a data constructor does not appear where
--   a data variable is expected, e.g., <tt>let F x = e</tt>, or vice
--   versa, e.g., <tt>let f (x Y) = e</tt>.
module Front.Scope

-- | Check the scoping of a <a>Program</a>.
scopeProgram :: Program -> Pass ()
instance Control.Monad.Reader.Class.MonadReader Front.Scope.ScopeCtx Front.Scope.ScopeFn
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Front.Scope.ScopeFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Front.Scope.ScopeFn
instance Control.Monad.Fail.MonadFail Front.Scope.ScopeFn
instance GHC.Base.Monad Front.Scope.ScopeFn
instance GHC.Base.Applicative Front.Scope.ScopeFn
instance GHC.Base.Functor Front.Scope.ScopeFn


-- | Sslang source code tokens.
module Front.Token

-- | Tokens extracted from source text.
newtype Token
Token :: (Span, TokenType) -> Token

-- | Extract the <a>TokenType</a> from a <a>Token</a>.
tokenType :: Token -> TokenType

-- | The location of a token in the source text.
data Span
Span :: Int -> Int -> Int -> Int -> Span
[tokPos] :: Span -> Int
[tokLen] :: Span -> Int
[tokLine] :: Span -> Int
[tokCol] :: Span -> Int

-- | The types of tokens that can appear in a sslang source file.
data TokenType
TEOF :: TokenType
TType :: TokenType
TIf :: TokenType
TElse :: TokenType
TWhile :: TokenType
TDo :: TokenType
TPar :: TokenType
TLoop :: TokenType
TLet :: TokenType
TMatch :: TokenType
TAfter :: TokenType
TWait :: TokenType
TFun :: TokenType
TExtern :: TokenType
TEq :: TokenType
TLarrow :: TokenType
TRarrow :: TokenType
TDRarrow :: TokenType
TDBar :: TokenType
TColon :: TokenType
TSemicolon :: TokenType
TBar :: TokenType
TComma :: TokenType
TUnderscore :: TokenType
TAt :: TokenType
TAmpersand :: TokenType
TLparen :: TokenType
TRparen :: TokenType
TLbrace :: TokenType
TRbrace :: TokenType
TLbracket :: TokenType
TRbracket :: TokenType
TInteger :: Integer -> TokenType
TString :: String -> TokenType
TId :: Identifier -> TokenType
TOp :: Identifier -> TokenType
TCSym :: Identifier -> TokenType
TCQuote :: String -> TokenType
TCBlock :: String -> TokenType

-- | Pretty print a list of tokens.
prettyTokens :: [Token] -> String
instance GHC.Show.Show Front.Token.Span
instance GHC.Classes.Eq Front.Token.Span
instance GHC.Show.Show Front.Token.TokenType
instance GHC.Classes.Eq Front.Token.TokenType
instance GHC.Classes.Eq Front.Token.Token
instance GHC.Show.Show Front.Token.Token
instance Prettyprinter.Internal.Pretty Front.Token.Token
instance Prettyprinter.Internal.Pretty Front.Token.TokenType
instance Prettyprinter.Internal.Pretty Front.Token.Span


-- | Scanner for sslang.
--   
--   In addition to tokenizing the input text stream, this scanner is
--   responsible for the following:
--   
--   <ul>
--   <li>Insert implicit open braces after any block-starting token, if
--   necessary;</li>
--   <li>Insert implicit separators for aligned lines within the same
--   block; and</li>
--   <li>Insert implicit close braces if an implicit block closed, either
--   by a decrease in indentation, or by the closure of a surrounding
--   explicit block.</li>
--   </ul>
--   
--   As such, the scanner's state is enriched with a stack of contexts
--   which it uses to perform basic delimiter matching. It also relies on
--   epsilon transitions to emit implicit tokens.
module Front.Scanner

-- | Extract a token stream from an input string.
scanTokens :: String -> Pass [Token]

-- | Extract a stream of token types (without span) from an input string.
scanTokenTypes :: String -> Pass [TokenType]

-- | Used to integrate with Happy parser.
lexerForHappy :: (Token -> Alex a) -> Alex a

-- | Tokens extracted from source text.
newtype Token
Token :: (Span, TokenType) -> Token

-- | The types of tokens that can appear in a sslang source file.
data TokenType
TEOF :: TokenType
TType :: TokenType
TIf :: TokenType
TElse :: TokenType
TWhile :: TokenType
TDo :: TokenType
TPar :: TokenType
TLoop :: TokenType
TLet :: TokenType
TMatch :: TokenType
TAfter :: TokenType
TWait :: TokenType
TFun :: TokenType
TExtern :: TokenType
TEq :: TokenType
TLarrow :: TokenType
TRarrow :: TokenType
TDRarrow :: TokenType
TDBar :: TokenType
TColon :: TokenType
TSemicolon :: TokenType
TBar :: TokenType
TComma :: TokenType
TUnderscore :: TokenType
TAt :: TokenType
TAmpersand :: TokenType
TLparen :: TokenType
TRparen :: TokenType
TLbrace :: TokenType
TRbrace :: TokenType
TLbracket :: TokenType
TRbracket :: TokenType
TInteger :: Integer -> TokenType
TString :: String -> TokenType
TId :: Identifier -> TokenType
TOp :: Identifier -> TokenType
TCSym :: Identifier -> TokenType
TCQuote :: String -> TokenType
TCBlock :: String -> TokenType

-- | The location of a token in the source text.
data Span
Span :: Int -> Int -> Int -> Int -> Span
[tokPos] :: Span -> Int
[tokLen] :: Span -> Int
[tokLine] :: Span -> Int
[tokCol] :: Span -> Int

-- | User-facing syntax error.
syntaxErr :: String -> Alex a

-- | Internal compiler error for unreachable code.
internalErr :: String -> Alex a

-- | Convert Alex's String-encoded errors to Sslang <a>Error</a>.
liftErr :: String -> Error
instance GHC.Show.Show Front.Scanner.AlexPosn
instance GHC.Classes.Eq Front.Scanner.AlexPosn
instance GHC.Show.Show Front.Scanner.ScannerContext
instance GHC.Base.Functor Front.Scanner.Alex
instance GHC.Base.Applicative Front.Scanner.Alex
instance GHC.Base.Monad Front.Scanner.Alex


-- | Parser for sslang token stream.
--   
--   To check for shift<i>reduce and reduce</i>reduce conflicts, generate
--   parser manually:
--   
--   <pre>
--   happy -i Parser.y -o /dev/null
--   </pre>
--   
--   Then check <tt>Parser.info</tt>.
module Front.Parser

-- | Parse a <a>String</a> and yield a <a>Program</a>.
parseProgram :: String -> Pass Program


-- | Front end of the compiler pipeline.
--   
--   Throughout this stage, high-level syntax is progressively parsed and
--   desugared into simpler AST constructs.
module Front

-- | Operation modes for the front end compiler stage.
data Mode

-- | Compile end-to-end (default).
Continue :: Mode

-- | Print the token stream from the scanner.
DumpTokens :: Mode

-- | Print the initial parsed AST, before operators are parsed.
DumpAst :: Mode

-- | Print the AST after operators are parsed.
DumpAstParsed :: Mode

-- | Print the AST after all desugaring, just before lowering.
DumpAstFinal :: Mode

-- | Compiler options for the front end compiler stage.
newtype Options
Options :: Mode -> Options
[optMode] :: Options -> Mode

-- | CLI options for the front end compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Parse a fully-formed AST from some String input.
parseAst :: Options -> String -> Pass Program

-- | Semantic checking on an AST.
checkAst :: Options -> Program -> Pass ()

-- | Front end compiler stage.
run :: Options -> String -> Pass Program
instance GHC.Show.Show Front.Mode
instance GHC.Classes.Eq Front.Mode
instance GHC.Show.Show Front.Options
instance GHC.Classes.Eq Front.Options
instance Common.Default.Default Front.Options


-- | Definitions of and related to the sslang IR's type system.
module IR.Types.Type

-- | Encoding of sslang types.
--   
--   Structurally speaking, these are very simple. Types are either type
--   variables or type constructors applied to some other types.
--   
--   Builtin types (and type constructors) include <a>Arrow</a>,
--   <a>Unit</a>, <a>Ref</a>, <a>List</a>, and various sizes of tuples; for
--   convenience, those are defined elsewhere using the GHC PatternSynonyms
--   extension.
data Type

-- | Type constructor, applied to zero or more types
TCon :: TConId -> [Type] -> Type

-- | Type variable (may be implicitly quantified)
TVar :: TVarId -> Type

-- | Constraints on a type scheme.
--   
--   For now, we only support trivial constraints.
data Constraint

-- | The trivial constraint, i.e., always satisfied.
CTrue :: Constraint

-- | Schemes quantify over <a>Type</a> variables and impose some
--   <a>Constraint</a>.
--   
--   <a>SchemeOf</a> is implemented as functor over some kind of type so we
--   can easily substitute in <a>Type</a> vs <tt>UType</tt> when performing
--   type inference/unification.
data SchemeOf t
Forall :: Set TVarId -> Constraint -> t -> SchemeOf t

-- | Unwrap a scheme and obtain the underlying type.
unScheme :: SchemeOf t -> t

-- | Construct a scheme with quantified type variables and a trivial
--   constraint.
forall :: (Functor l, Foldable l) => l TVarId -> t -> SchemeOf t

-- | Construct a scheme from all free type variables and a trivial
--   constraint.
schemeOf :: Type -> Scheme

-- | Schemes over <a>Type</a>.
newtype Scheme
Scheme :: SchemeOf Type -> Scheme

-- | An annotation records the annotated portion of a pattern.
data Annotation

-- | A basic <a>Type</a> annotation
AnnType :: Type -> Annotation

-- | Annotations collected from patterns
AnnDCon :: DConId -> [Annotation] -> Annotation

-- | Annotations collected from fun args
AnnArrows :: [Annotation] -> Annotation -> Annotation

-- | Expressions are annotated with a (potentially empty) list of
--   <a>Annotation</a>.
newtype Annotations
Annotations :: [Annotation] -> Annotations

-- | Unwrap the <a>Annotations</a> data constructor.
unAnnotations :: Annotations -> [Annotation]

-- | Unroll an annotation into a type. FIXME: get rid of this.
fromAnnotations :: Annotations -> Type

-- | Some data type that contains a sslang <a>Type</a>.
class HasType a
getType :: HasType a => a -> Type

-- | A fresh, free type variable; may appear in type annotations.
pattern Hole :: Type

-- | The type constructor for function arrows.
pattern Arrow :: Type -> Type -> Type

-- | Unfold an <a>Arrow</a> <a>Type</a> into a list of argument types and a
--   return type.
unfoldArrow :: Type -> ([Type], Type)

-- | Fold a list of argument types and a return type into an <a>Arrow</a>
--   <a>Type</a>.
foldArrow :: ([Type], Type) -> Type

-- | The builtin singleton <a>Type</a>, whose only data constructor is just
--   <tt>()</tt>.
pattern Unit :: Type

-- | The builtin reference <a>Type</a>, created using <tt>new</tt>.
pattern Ref :: Type -> Type

-- | The builtin list <a>Type</a>, created using list syntax, e.g., <tt>[a,
--   b]</tt>.
pattern List :: Type -> Type

-- | The builtin 64-bit timestamp <a>Type</a>.
pattern Time :: Type

-- | Builtin <a>Type</a> for signed 64-bit integers.
pattern I64 :: Type

-- | Builtin <a>Type</a> for unsigned 64-bit integers.
pattern U64 :: Type

-- | Builtin <a>Type</a> for signed 32-bit integers.
pattern I32 :: Type

-- | Builtin <a>Type</a> for unsigned 32-bit integers.
pattern U32 :: Type

-- | Builtin <a>Type</a> for signed 16-bit integers.
pattern I16 :: Type

-- | Builtin <a>Type</a> for unsigned 16-bit integers.
pattern U16 :: Type

-- | Builtin <a>Type</a> for signed 8-bit integers.
pattern I8 :: Type

-- | Builtin <a>Type</a> for unsigned 8-bit integers.
pattern U8 :: Type

-- | Test whether a <a>Type</a> is one of the builtin signed integers.
isInt :: Type -> Bool

-- | Test whether a <a>Type</a> is one of the builtin unsigned integers.
isUInt :: Type -> Bool

-- | Test whether a <a>Type</a> is one of the builtin numeric types.
isNum :: Type -> Bool

-- | Construct a builtin tuple type out of a list of at least 2 types.
tuple :: [Type] -> Type

-- | Test whether a <a>Type</a> is a tuple of some arity.
isTuple :: Type -> Bool

-- | Construct the type constructor of a builtin tuple of given arity
--   (&gt;= 2).
tupleId :: (Integral i, Identifiable v) => i -> v

-- | More convenient representation of tuple types, for pattern-matching.
data TupleView

-- | 2-tuples
Tup2 :: (Type, Type) -> TupleView

-- | 3-tuples
Tup3 :: (Type, Type, Type) -> TupleView

-- | 4-tuples
Tup4 :: (Type, Type, Type, Type) -> TupleView

-- | n-ary tuples
TupN :: [Type] -> TupleView

-- | not a tuple
NotATuple :: TupleView

-- | Convert a <a>Type</a> to a <a>TupleView</a>; convenient for
--   ViewPatterns.
--   
--   For example, to match on just 2-tuples;
--   
--   <pre>
--   foo :: Type -&gt; String
--   foo (tupleOf -&gt; Tup2 (a, b)) = "2-tuple of " ++ show a ++ " and " ++ show b
--   foo t                        = "Some other kind of type: " ++ show t
--   </pre>
tupleOf :: Type -> TupleView

-- | Kinds are just the arity of type constructors.
type Kind = Int

-- | Map to help us look up the kinds of builtin types.
builtinKinds :: Map TConId Kind
instance Data.Data.Data IR.Types.Type.Type
instance GHC.Show.Show IR.Types.Type.Type
instance GHC.Classes.Eq IR.Types.Type.Type
instance Data.Data.Data IR.Types.Type.Constraint
instance GHC.Show.Show IR.Types.Type.Constraint
instance GHC.Classes.Eq IR.Types.Type.Constraint
instance Data.Data.Data t => Data.Data.Data (IR.Types.Type.SchemeOf t)
instance Data.Traversable.Traversable IR.Types.Type.SchemeOf
instance Data.Foldable.Foldable IR.Types.Type.SchemeOf
instance GHC.Base.Functor IR.Types.Type.SchemeOf
instance GHC.Show.Show t => GHC.Show.Show (IR.Types.Type.SchemeOf t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.Types.Type.SchemeOf t)
instance Data.Data.Data IR.Types.Type.Scheme
instance GHC.Show.Show IR.Types.Type.Scheme
instance GHC.Classes.Eq IR.Types.Type.Scheme
instance Data.Data.Data IR.Types.Type.Annotation
instance GHC.Show.Show IR.Types.Type.Annotation
instance GHC.Classes.Eq IR.Types.Type.Annotation
instance GHC.Base.Monoid IR.Types.Type.Annotations
instance GHC.Base.Semigroup IR.Types.Type.Annotations
instance Data.Data.Data IR.Types.Type.Annotations
instance GHC.Show.Show IR.Types.Type.Annotations
instance GHC.Classes.Eq IR.Types.Type.Annotations
instance IR.Types.Type.HasType IR.Types.Type.Type
instance IR.Types.Type.HasType IR.Types.Type.Scheme
instance Prettyprinter.Internal.Pretty IR.Types.Type.Annotations
instance Common.Pretty.Dumpy IR.Types.Type.Annotations
instance Prettyprinter.Internal.Pretty IR.Types.Type.Annotation
instance Common.Pretty.Dumpy IR.Types.Type.Annotation
instance Common.Identifiers.HasFreeVars IR.Types.Type.Scheme Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty IR.Types.Type.Scheme
instance Common.Pretty.Dumpy IR.Types.Type.Scheme
instance Common.Identifiers.HasFreeVars IR.Types.Type.Type Common.Identifiers.TVarId
instance Prettyprinter.Internal.Pretty IR.Types.Type.Type
instance Common.Pretty.Dumpy IR.Types.Type.Type


-- | Sslang's intermediate representation and its associated helpers.
module IR.IR

-- | Top-level compilation unit.
--   
--   <tt>t</tt> is the type system in use, e.g., <a>IR.Types.Flat</a>
data Program t
Program :: VarId -> String -> [(VarId, Type)] -> [(VarId, Expr t)] -> [(TConId, TypeDef)] -> Program t
[programEntry] :: Program t -> VarId
[cDefs] :: Program t -> String
[externDecls] :: Program t -> [(VarId, Type)]
[programDefs] :: Program t -> [(VarId, Expr t)]
[typeDefs] :: Program t -> [(TConId, TypeDef)]

-- | The type definition associated with a type constructor. A definition
--   for `data MyList a = Cons a (MyList a) | Nil` looks like: <tt> TypeDef
--   { targs = [a] , [ (<a>Cons</a>, VariantUnnamed [TVar a, TCon
--   (<a>MyList</a> [TVar a])]) , (<a>Nil</a>, VariantUnnamed []) ] } </tt>
--   (Data constructors for identifiers are omitted for brevity.) Note that
--   for a flat type system, where all type constructors are nullary, targs
--   will just be set to [].
data TypeDef
TypeDef :: [(DConId, TypeVariant)] -> [TVarId] -> TypeDef
[variants] :: TypeDef -> [(DConId, TypeVariant)]
[targs] :: TypeDef -> [TVarId]

-- | Arguments to a data constructor, whose fields may or may not be named
data TypeVariant

-- | A record with named fields
VariantNamed :: [(VarId, Type)] -> TypeVariant

-- | An algebraic type with unnamed fields
VariantUnnamed :: [Type] -> TypeVariant

-- | A name to be bound; <a>Nothing</a> represents a wildcard, e.g.,
--   <tt>let _ = ...</tt>.
type Binder = Maybe VarId

-- | Literal values supported by the language.
--   
--   Note that these don't carry any connotation of type: <tt>1</tt> just
--   means <tt>1</tt>,
data Literal
LitIntegral :: Integer -> Literal
LitEvent :: Literal

-- | Primitive operations.
--   
--   These should be the kinds of functions one may expect to be available
--   as operators in C, or as instructions in an assembly language.
--   
--   For simplicity and consistency, they should be:
--   
--   <ul>
--   <li>Pure (i.e., side-effectful iff operands are side-effectful, i.e.,
--   no <tt>=</tt>)</li>
--   <li>Strict in all operands (i.e., no <tt>&amp;&amp;</tt> or
--   <tt>||</tt>)</li>
--   </ul>
--   
--   We can instead implement short-circuit control flow using match
--   statements.
data PrimOp

-- | negation, i.e., -x
PrimNeg :: PrimOp

-- | logical not, i.e., !x
PrimNot :: PrimOp

-- | bitwise not, i.e., ~x
PrimBitNot :: PrimOp

-- | addition, i.e., x + y
PrimAdd :: PrimOp

-- | subtraction, i.e., x - y
PrimSub :: PrimOp

-- | multiplication, i.e., x * y
PrimMul :: PrimOp

-- | division, i.e., x / y
PrimDiv :: PrimOp

-- | modulus, i.e., x % y
PrimMod :: PrimOp

-- | bitwise-and, i.e., x &amp; y
PrimBitAnd :: PrimOp

-- | bitwise-or, i.e., x | y
PrimBitOr :: PrimOp

-- | equality, i.e., x == y
PrimEq :: PrimOp

-- | equality, i.e., x != y
PrimNeq :: PrimOp

-- | greater than, i.e., x &gt; y
PrimGt :: PrimOp

-- | greater than or equal to, i.e., x &gt;= y
PrimGe :: PrimOp

-- | less than, i.e., x &lt; y
PrimLt :: PrimOp

-- | less than or equal to, i.e., x &lt;= y
PrimLe :: PrimOp

-- | Primitive functions for side-effects and imperative control flow.
data Primitive

-- | <tt>New e</tt> allocates a schedule variable initialized to
--   <tt>e</tt>, and returns a reference to it.
New :: Primitive

-- | <tt>Dup r</tt> dups the reference <tt>r</tt> and returns <tt>r</tt>.
Dup :: Primitive

-- | <tt>Drop e r</tt> evaluates to <tt>e</tt>, but also drops <tt>r</tt>.
Drop :: Primitive

-- | <tt>Deref r</tt> dereferences reference <tt>r</tt> to obtain its
--   value.
Deref :: Primitive

-- | <tt>Assign r e</tt> instantly assigns value <tt>e</tt> to reference
--   <tt>r</tt>.
Assign :: Primitive

-- | <tt>After t r e</tt> assigns <tt>e</tt> to reference <tt>r</tt> after
--   time <tt>t</tt>.
After :: Primitive

-- | <tt>Par es+</tt> evaluates expressions <tt>es</tt> concurrently.
Par :: Primitive

-- | <tt>Wait rs+</tt> waits for an assignment to any reference in
--   <tt>rs</tt>.
Wait :: Primitive

-- | <tt>Loop b</tt> loops body <tt>b</tt> forever.
Loop :: Primitive

-- | <tt>Break</tt> breaks out of the innermost loop.
Break :: Primitive

-- | <tt>Now</tt> obtains the value of the current instant
Now :: Primitive

-- | Inlined C expression code.
PrimOp :: PrimOp -> Primitive

-- | Primitive operator.
CQuote :: String -> Primitive

-- | Direct call to arbitrary C function (NOTE: HACKY).
CCall :: CSym -> Primitive

-- | Call to well-typed extern symbol.
FfiCall :: VarId -> Primitive

-- | Expressions, based on the let-polymorphic lambda calculus.
--   
--   <tt>t</tt> represents the type of this expression, e.g., <a>Flat</a>.
--   At various stages, this may represent a richer or simpler type system.
--   The type is embedded in each data constructor so as to type-annotate
--   the entire expression tree.
--   
--   Designed for side effects with call-by-value evaluation order. Basic
--   sequencing can be recovered through let-bindings:
--   
--   <pre>
--   let _ = stmt1 in
--   let _ = stmt2 in
--   ...
--   </pre>
--   
--   Effects of <tt>stmt1</tt> take place before that of <tt>stmt2</tt>.
data Expr t

-- | <tt>Var n t</tt> is a variable named <tt>n</tt> of type <tt>t</tt>.
Var :: VarId -> t -> Expr t

-- | <tt>Data d t</tt> is a data constructor named <tt>d</tt> of type
--   <tt>t</tt>.
Data :: DConId -> t -> Expr t

-- | <tt>Lit l t</tt> is a literal value <tt>l</tt> of type <tt>t</tt>.
Lit :: Literal -> t -> Expr t

-- | <tt>App f a t</tt> applies function <tt>f</tt> to argument <tt>a</tt>,
--   producing a value of type <tt>t</tt>.
App :: Expr t -> Expr t -> t -> Expr t

-- | <tt>Let [(n, v)] b t</tt> binds value <tt>v</tt> to variable
--   <tt>v</tt> in its body <tt>b</tt>.
--   
--   The bindings list may only be of length greater than 1 for a set of
--   mutually co-recursive functions.
Let :: [(Binder, Expr t)] -> Expr t -> t -> Expr t

-- | <tt>Lambda v b t</tt> constructs an anonymous function of type
--   <tt>t</tt> that binds a value to parameter <tt>v</tt> in its body
--   <tt>b</tt>.
Lambda :: Binder -> Expr t -> t -> Expr t

-- | <tt>Match s alts t</tt> pattern-matches on scrutinee <tt>s</tt>
--   against alternatives <tt>alts</tt>, each producing a value of type
--   <tt>t</tt>.
Match :: Expr t -> [(Alt, Expr t)] -> t -> Expr t

-- | <tt>Prim p es t</tt> applies primitive <tt>p</tt> arguments
--   <tt>es</tt>, producing a value of type <tt>t</tt>.
Prim :: Primitive -> [Expr t] -> t -> Expr t

-- | An alternative in a pattern-match.
data Alt

-- | <tt>AltData d vs</tt> matches data constructor <tt>d</tt>, and names
--   dcon members <tt>vs</tt>.
AltData :: DConId -> [Binder] -> Alt

-- | <tt>AltLit l</tt> matches against literal <tt>l</tt>, producing
--   expression <tt>e</tt>.
AltLit :: Literal -> Alt

-- | <tt>AltDefault v</tt> matches anything, and bound to name <tt>v</tt>.
AltDefault :: Binder -> Alt

-- | Identifier for data variables, e.g., <tt>x</tt>.
newtype VarId
VarId :: Identifier -> VarId

-- | Identifier for type constructors, e.g., <tt>Option</tt>.
newtype TConId
TConId :: Identifier -> TConId

-- | Identifier for data constructors, e.g., <tt>None</tt>.
newtype DConId
DConId :: Identifier -> DConId

-- | Encoding of sslang types.
--   
--   Structurally speaking, these are very simple. Types are either type
--   variables or type constructors applied to some other types.
--   
--   Builtin types (and type constructors) include <a>Arrow</a>,
--   <a>Unit</a>, <a>Ref</a>, <a>List</a>, and various sizes of tuples; for
--   convenience, those are defined elsewhere using the GHC PatternSynonyms
--   extension.
data Type

-- | An annotation records the annotated portion of a pattern.
data Annotation

-- | Expressions are annotated with a (potentially empty) list of
--   <a>Annotation</a>.
data Annotations

-- | The number of fields in a <a>TypeVariant</a>.
variantFields :: TypeVariant -> Int

-- | Predicate of whether an expression "looks about right".
--   
--   Description left deliberately vague so that we have the flexibility to
--   strengthen this predicate. For now, we just check that all primitives
--   are applied to the right number of arguments.
--   
--   This predicate also provides a template to recursively traverse
--   through all sub-expressions of an expression.
wellFormed :: Expr t -> Bool

-- | Create a lambda chain given a list of argument-type pairs and a body.
foldLambda :: [(Binder, Type)] -> Expr Type -> Expr Type

-- | Collect a curried list of function arguments from a nesting of
--   lambdas.
unfoldLambda :: Expr t -> ([Binder], Expr t)

-- | Extract the type carried by an <a>Expr</a>.
extract :: Expr t -> t

-- | Replace the top-level type carried by an <a>Expr</a>.
inject :: t -> Expr t -> Expr t

-- | Apply a function to zero or more arguments.
--   
--   <a>zipApp</a> is the inverse of <a>unzipApp</a>.
zipApp :: Expr t -> [(Expr t, t)] -> Expr t

-- | Collect a curried application into the function and argument list.
--   
--   The type accompanying each argument represents type produced by the
--   application, and is extracted from the <a>App</a> node that this
--   function unwraps.
--   
--   For example, the term <tt>f a b</tt> (where <tt>a: A</tt> and <tt>b:
--   B</tt>) would be represented by the following AST: @<tt> (App (App
--   (Var f (A -&gt; B -&gt; C)) (Var a A) (B -&gt; C)) (Var b B) C) </tt>@
--   
--   which, when unzipped, gives:
--   
--   @<tt> (Var f (A -&gt; B -&gt; C)) [(Var a A, B -&gt; C), (Var b B, C)]
--   </tt>@
--   
--   <a>unzipApp</a> is the inverse of <a>zipApp</a>.
unzipApp :: Expr t -> (Expr t, [(Expr t, t)])

-- | Whether an expression is a value.
isValue :: Expr t -> Bool
instance Data.Data.Data IR.IR.TypeVariant
instance GHC.Classes.Eq IR.IR.TypeVariant
instance GHC.Show.Show IR.IR.TypeVariant
instance Data.Data.Data IR.IR.TypeDef
instance GHC.Classes.Eq IR.IR.TypeDef
instance GHC.Show.Show IR.IR.TypeDef
instance Data.Data.Data IR.IR.Literal
instance GHC.Show.Show IR.IR.Literal
instance GHC.Classes.Eq IR.IR.Literal
instance Data.Data.Data IR.IR.PrimOp
instance GHC.Show.Show IR.IR.PrimOp
instance GHC.Classes.Eq IR.IR.PrimOp
instance Data.Data.Data IR.IR.Primitive
instance GHC.Show.Show IR.IR.Primitive
instance GHC.Classes.Eq IR.IR.Primitive
instance Data.Data.Data IR.IR.Alt
instance GHC.Show.Show IR.IR.Alt
instance GHC.Classes.Eq IR.IR.Alt
instance Data.Traversable.Traversable IR.IR.Expr
instance Data.Foldable.Foldable IR.IR.Expr
instance GHC.Base.Functor IR.IR.Expr
instance Data.Data.Data t => Data.Data.Data (IR.IR.Expr t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Expr t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Expr t)
instance GHC.Base.Functor IR.IR.Program
instance Data.Data.Data t => Data.Data.Data (IR.IR.Program t)
instance GHC.Show.Show t => GHC.Show.Show (IR.IR.Program t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (IR.IR.Program t)
instance Prettyprinter.Internal.Pretty (IR.IR.Program IR.Types.Type.Type)
instance Common.Pretty.Dumpy (IR.IR.Program IR.Types.Type.Type)
instance Common.Identifiers.HasFreeVars (IR.IR.Expr t) Common.Identifiers.VarId
instance Prettyprinter.Internal.Pretty (IR.IR.Expr ())
instance Common.Pretty.Dumpy (IR.IR.Expr IR.Types.Type.Type)
instance Prettyprinter.Internal.Pretty IR.IR.Alt
instance Common.Pretty.Dumpy IR.IR.Alt
instance Prettyprinter.Internal.Pretty IR.IR.PrimOp
instance Common.Pretty.Dumpy IR.IR.PrimOp
instance Prettyprinter.Internal.Pretty IR.IR.Literal
instance Common.Pretty.Dumpy IR.IR.Literal


-- | Substitute AST nodes with magical primitives.
module IR.SubstMagic

-- | Substitute AST nodes with magical primitives.
--   
--   Implemented as a syb-style generic tree traversal.
--   
--   Example usage:
--   
--   @@ -- Given: myExpr :: Expr Poly.Type
--   
--   <ul>
--   <li>- Do: substMagic (Proxy :: Proxy Poly.Type) myExpr</li>
--   <li>- Given: myProm :: Program Annotated.Type</li>
--   <li>- Do: substMagic (Proxy :: Proxy Annotated.Type) myProg @@</li>
--   </ul>
substMagic :: (Data t, Data a) => Proxy t -> a -> a


-- | Unroll let-def blocks to break apart non-mutually recursive
--   definitions.
module IR.SegmentLets
segmentLets :: Program T -> Pass (Program T)
segmentDefs :: Show t => [Def t] -> [[Def t]]

module IR.ClassInstantiation
instProgram :: Program Type -> Pass (Program Type)


-- | Extract and encapsulate the type information needed during codegen.
module Codegen.Typegen

-- | Information and codegen handlers associated with each data
--   constructor.
data DConInfo
DConInfo :: TConId -> Int -> Bool -> Exp -> Exp -> (Int -> Exp -> Exp) -> DConInfo

-- | the type that the data constructor inhabits
[dconType] :: DConInfo -> TConId

-- | number of fields
[dconSize] :: DConInfo -> Int

-- | whether the data constructor is heap-allocated
[dconOnHeap] :: DConInfo -> Bool

-- | the dcon tag to match on, i.e., in <tt>case tag</tt>
[dconCase] :: DConInfo -> Exp

-- | constructs a dcon instance
[dconConstruct] :: DConInfo -> Exp

-- | retrieve the ith field
[dconDestruct] :: DConInfo -> Int -> Exp -> Exp

-- | Information and codegen handlers associated with each type
--   constructor.
data TConInfo
TConInfo :: TypeEncoding -> (Exp -> Exp) -> TConInfo

-- | how the data type is encoded
[typeEncoding] :: TConInfo -> TypeEncoding

-- | how to retrieve the tag of an instance
[typeScrut] :: TConInfo -> Exp -> Exp

-- | Type-related information, abstracted behind partial lookup functions.
data TypegenInfo
TypegenInfo :: (DConId -> Maybe DConInfo) -> (TConId -> Maybe TConInfo) -> TypegenInfo

-- | for each data constructor.
[dconInfo] :: TypegenInfo -> DConId -> Maybe DConInfo

-- | for each type constructor.
[tconInfo] :: TypegenInfo -> TConId -> Maybe TConInfo

-- | Create codegen definitions and helpers for sslang type definitions.
genTypes :: [(TConId, TypeDef)] -> Pass ([Definition], TypegenInfo)


-- | Wrapper around the unification-fd library.
--   
--   Compared to normal types (<a>Type</a>), unification types
--   (<a>Type</a>) may contain unification variables, which only appear
--   during the type inference process.
--   
--   This module provides a definition for unification types, an inference
--   monad, as well as some pattern synonyms for the builtin types.
module IR.Types.Unification

-- | A type that may also contain unification variables.
type Type = UTerm TypeF IntVar

-- | An explicitly quantified <a>Type</a>, which may contain unification
--   variables.
type Scheme = SchemeOf Type

-- | Pattern synonym for <a>Type</a> variables.
pattern TVar :: TVarId -> Type

-- | Pattern synonym for <a>Type</a> constructors.
pattern TCon :: TConId -> [Type] -> Type
class HasFreeUVars a
freeUVars :: HasFreeUVars a => a -> InferM ctx (Set IntVar)

-- | Inference monad, build on top of the unification algorithm.
type InferM ctx = ReaderT ctx (ExceptT Error (IntBindingT TypeF Pass))

-- | Execute the <a>InferM</a> inference monad.
runInfer :: ctx -> InferM ctx a -> Pass a

-- | Create a fresh unification variable.
fresh :: InferM ctx Type

-- | Apply bindings from current monad so remaining bindings must be free.
applyBindings :: Type -> InferM ctx Type

-- | Unifies two types; fails if they cannot unify.
(=:=) :: Type -> Type -> InferM ctx ()
infix 4 =:=

-- | Whether the LHS subsumes the RHS.
(<:=) :: Type -> Type -> InferM ctx Bool
infix 4 <:=

-- | Promote a <a>Type</a> to a <a>Type</a>.
unfreeze :: Type -> Type

-- | Demote a <a>Type</a> to a regular <a>Type</a>.
--   
--   Fails if the unification type contains more than just contructors and
--   variables.
freeze :: Type -> InferM ctx Type

-- | Instantiate a <a>Scheme</a> by replacing all quantified type varibles
--   with fresh unification variables
instantiate :: Scheme -> InferM ctx Type

-- | Generalize a <a>Type</a> by replacing all free unification variables
--   with quantified type variables.
generalize :: HasFreeUVars ctx => Type -> InferM ctx Scheme

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | A fresh, free type variable; may appear in type annotations.
pattern Hole :: Type

-- | The type constructor for function arrows.
pattern Arrow :: Type -> Type -> Type

-- | Fold a list of argument types and a return type into an <a>Arrow</a>
--   <a>Type</a>.
foldArrow :: ([Type], Type) -> Type

-- | Unfold an <a>Arrow</a> <a>Type</a> into a list of argument types and a
--   return type.
unfoldArrow :: Type -> ([Type], Type)

-- | The builtin singleton <a>Type</a>, whose only data constructor is just
--   <tt>()</tt>.
pattern Unit :: Type

-- | The builtin reference <a>Type</a>, created using <tt>new</tt>.
pattern Ref :: Type -> Type

-- | The builtin list <a>Type</a>, created using list syntax, e.g., <tt>[a,
--   b]</tt>.
pattern List :: Type -> Type

-- | The builtin 64-bit timestamp <a>Type</a>.
pattern Time :: Type

-- | Builtin <a>Type</a> for signed 64-bit integers.
pattern I64 :: Type

-- | Builtin <a>Type</a> for unsigned 64-bit integers.
pattern U64 :: Type

-- | Builtin <a>Type</a> for signed 32-bit integers.
pattern I32 :: Type

-- | Builtin <a>Type</a> for unsigned 32-bit integers.
pattern U32 :: Type

-- | Builtin <a>Type</a> for signed 16-bit integers.
pattern I16 :: Type

-- | Builtin <a>Type</a> for unsigned 16-bit integers.
pattern U16 :: Type

-- | Builtin <a>Type</a> for signed 8-bit integers.
pattern I8 :: Type

-- | Builtin <a>Type</a> for unsigned 8-bit integers.
pattern U8 :: Type

-- | Construct a builtin tuple type out of a list of at least 2 types.
tuple :: [Type] -> Type
instance Control.Unification.Types.Unifiable IR.Types.Unification.TypeF
instance GHC.Generics.Generic1 IR.Types.Unification.TypeF
instance Data.Traversable.Traversable IR.Types.Unification.TypeF
instance Data.Foldable.Foldable IR.Types.Unification.TypeF
instance GHC.Base.Functor IR.Types.Unification.TypeF
instance GHC.Classes.Eq a => GHC.Classes.Eq (IR.Types.Unification.TypeF a)
instance GHC.Classes.Ord Control.Unification.IntVar.IntVar
instance Control.Unification.Types.Unifiable []
instance IR.Types.Unification.HasFreeUVars IR.Types.Unification.Type
instance IR.Types.Unification.HasFreeUVars IR.Types.Unification.Scheme
instance Common.Identifiers.HasFreeVars IR.Types.Unification.Type Common.Identifiers.TVarId
instance GHC.Show.Show a => GHC.Show.Show (IR.Types.Unification.TypeF a)
instance Control.Unification.Types.Fallible IR.Types.Unification.TypeF Control.Unification.IntVar.IntVar Common.Compiler.Error


-- | Hindley-Milner-Damas type inference with union-find.
module IR.Types.Inference

-- | Infer the types of every node in an optionally annotated program.
inferProgram :: Program Annotations -> Pass (Program Type)
instance IR.Types.Unification.HasFreeUVars IR.Types.Inference.InferCtx


-- | Entry point to the type checking phase of the compiler.
module IR.Types.Typechecking

-- | Type check an optionally annotated program.
typecheckProgram :: Program Annotations -> Pass (Program Type)


-- | Wrapper module around other types-related modules and definitions.
module IR.Types

-- | Type check an optionally annotated program.
typecheckProgram :: Program Annotations -> Pass (Program Type)


-- | Lower the representation of a sslang Ast into sslang IR.
--   
--   This pass expects prior desugaring passes to ensure that:
--   
--   <ul>
--   <li>Op regions are unflatted into proper applications.</li>
--   <li>Patterns in definitions consist of only (annotated) identifiers or
--   wildcards.</li>
--   </ul>
module IR.LowerAst

-- | Lower an AST <tt>Program</tt> into IR.
lowerProgram :: Program -> Pass (Program Annotations)


-- | Lift lambda definitions into the global scope.
--   
--   This pass is responsible for moving nested lambda definitions into the
--   global scope and performing necessary callsite adjustments.
module IR.LambdaLift

-- | Entry-point to lambda lifting.
--   
--   Maps over top level definitions and lifts out lambda definitions to
--   create a new Program with the relative order of user definitions
--   preserved.
liftProgramLambdas :: Program Type -> Pass (Program Type)
instance Control.Monad.State.Class.MonadState IR.LambdaLift.LiftCtx IR.LambdaLift.LiftFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.LambdaLift.LiftFn
instance Control.Monad.Fail.MonadFail IR.LambdaLift.LiftFn
instance GHC.Base.Monad IR.LambdaLift.LiftFn
instance GHC.Base.Applicative IR.LambdaLift.LiftFn
instance GHC.Base.Functor IR.LambdaLift.LiftFn


-- | Insert reference counting primitives.
module IR.InsertRefCounting

-- | Entry-point to insert dup/drops.
insertRefCounting :: Program Type -> Pass (Program Type)


-- | Turns non-nullary data constructors into calls to constructor
--   functions.
module IR.ExternToCall

-- | <a>externToCall</a> modifies programDefs and traverses the IR to
--   accomplish two tasks:
--   
--   <ol>
--   <li>Add top-level constructor functions for each non-nullary
--   <tt>DCon</tt> to progamDefs</li>
--   <li>Turn non-nullary data constuctors into calls to top level
--   constructor funcs</li>
--   </ol>
externToCall :: Program Type -> Pass (Program Type)
instance Control.Monad.Reader.Class.MonadReader IR.ExternToCall.ExternEnv IR.ExternToCall.ExternFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.ExternToCall.ExternFn
instance Control.Monad.Fail.MonadFail IR.ExternToCall.ExternFn
instance GHC.Base.Monad IR.ExternToCall.ExternFn
instance GHC.Base.Applicative IR.ExternToCall.ExternFn
instance GHC.Base.Functor IR.ExternToCall.ExternFn


-- | Turns non-nullary data constructors into calls to constructor
--   functions.
--   
--   Worked example of ADT definition and corresponding constructor
--   functions:
--   
--   <pre>
--   type Shape 
--     Square Int 
--     Rect Int Int
--   </pre>
--   
--   Let's turn data constructor <tt>Square</tt> into constructor function
--   <tt>__Square</tt>:
--   
--   <pre>
--   __Square arg0 : Int -&gt; Shape =  Square arg0
--   </pre>
--   
--   The difference is that <tt>Square</tt> cannot be partially-applied,
--   whereas <tt>__Square</tt> can.
--   
--   Next, <tt>Rect</tt> turns into this:
--   
--   <pre>
--   __Rect arg0 arg1 : Int -&gt; Int -&gt; Shape =  Rect arg0 arg1
--   </pre>
--   
--   The difference is that <tt>Rect</tt> cannot be partially-applied,
--   whereas <tt>__Rect</tt> can.
--   
--   Representing constructor functions in the IR:
--   
--   Every top-level function has the form (I.VarId, I.Expr Poly.Type) =
--   (functionName, functionBody) The function body is a lambda expression
--   representing a call to the fully applied data constructor.
--   
--   Let's turn the top-level func for <tt>Square</tt> into IR:
--   
--   <pre>
--   (__Square, body) 
--   body = fun arg0 { App L R t } : Int -&gt; Shape
--    where L = Square : Int -&gt; Shape
--          R = arg0 : type Int
--          t = Shape, because the type of a fully applied data constructor
--              is its type constructor@
--   </pre>
--   
--   Next <tt>Rect</tt> turns into this:
--   
--   <pre>
--   (Rect, body)
--   body = fun arg0 { fun arg1 { App L R t } : Int -&gt; Shape } : Int -&gt; Int -&gt; Shape
--    where L = App L2 R2 t
--          R = arg1 : Int
--          t = Shape, because the type of a fully applied data constructor 
--              is its type constructor
--           where L2 = Rect : Int -&gt; Int -&gt; Shape
--                 R  = arg0 : Int
--                 t = Int -&gt; Shape, because at this point in the inner App, 
--                     Rect is partially applied with only 1 arg.
--   </pre>
module IR.DConToFunc

-- | <a>dConToFunc</a> modifies programDefs and traverses the IR to
--   accomplish two tasks:
--   
--   <ol>
--   <li>Add top-level constructor functions for each non-nullary
--   <tt>DCon</tt> to progamDefs</li>
--   <li>Turn non-nullary data constuctors into calls to top level
--   constructor funcs</li>
--   </ol>
dConToFunc :: Program Type -> Pass (Program Type)
instance Control.Monad.Reader.Class.MonadReader IR.DConToFunc.ArityEnv IR.DConToFunc.ArityFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error IR.DConToFunc.ArityFn
instance Control.Monad.Fail.MonadFail IR.DConToFunc.ArityFn
instance GHC.Base.Monad IR.DConToFunc.ArityFn
instance GHC.Base.Applicative IR.DConToFunc.ArityFn
instance GHC.Base.Functor IR.DConToFunc.ArityFn


-- | Intermediate representation (IR) stages of the compiler pipeline.
module IR

-- | Operation modes for the IR compiler stage.
--   
--   By default, <a>Continue</a> completes the pipeline end-to-end.
data Mode
Continue :: Mode
DumpIR :: Mode
DumpIRAnnotated :: Mode
DumpIRTyped :: Mode
DumpIRLifted :: Mode
DumpIRFinal :: Mode

-- | Compiler options for the IR compiler stage.
newtype Options
Options :: Mode -> Options
[mode] :: Options -> Mode

-- | CLI options for the IR compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Lower from AST to IR (with annotations).
lower :: Options -> Program -> Pass (Program Annotations)

-- | Type inference + check against type annotations.
--   
--   After this stage, no compiler errors should be thrown.
typecheck :: Options -> Program Annotations -> Pass (Program Type)

-- | IR transformations to prepare for codegen.
transform :: Options -> Program Type -> Pass (Program Type)

-- | IR compiler stage.
run :: Options -> Program -> Pass (Program Type)
instance GHC.Show.Show IR.Mode
instance GHC.Classes.Eq IR.Mode
instance GHC.Show.Show IR.Options
instance GHC.Classes.Eq IR.Options
instance Common.Default.Default IR.Options


-- | Translate SSM program to C compilation unit.
--   
--   What is expected of the IR:
--   
--   Well-formed: All primitive functions are applied to the right number
--   of arguments.
--   
--   Pure par expression: All par-expressions' operands are applications
--   that have no side effects.
--   
--   Defunctionalized: No lambdas; the only terms with an arrow type are
--   variables or applications.
--   
--   Name mangled: All variable identifiers are unique.
module Codegen.Codegen

-- | Possible, but temporarily punted for the sake of expediency.
todo :: HasCallStack => a

-- | Impossible without a discussion about implementation strategy.
nope :: HasCallStack => a

-- | Hack to allow us to splice string literals into C AST
newtype EscExp
EscExp :: String -> EscExp

-- | State maintained while compiling a top-level SSM function.
--   
--   The information here is populated while generating the step function,
--   so that should be computed first, before this information is used to
--   generate the act struct and enter definitions.
data GenFnState
GenFnState :: VarId -> [(Binder, Type)] -> Type -> Expr Type -> Map VarId Type -> Map VarId Exp -> Int -> Int -> Int -> TypegenInfo -> GenFnState

-- | Function name
[fnName] :: GenFnState -> VarId

-- | Function parameters
[fnParams] :: GenFnState -> [(Binder, Type)]

-- | Function return type
[fnRetTy] :: GenFnState -> Type

-- | Function body
[fnBody] :: GenFnState -> Expr Type

-- | Function local variables
[fnLocals] :: GenFnState -> Map VarId Type

-- | How to resolve variables
[fnVars] :: GenFnState -> Map VarId Exp

-- | Number of triggers needed
[fnMaxWaits] :: GenFnState -> Int

-- | Yield point counter
[fnCases] :: GenFnState -> Int

-- | Temporary variable name counter
[fnFresh] :: GenFnState -> Int

-- | (User-defined) type information
[fnTypeInfo] :: GenFnState -> TypegenInfo

-- | Translation monad for procedures, with derived typeclass instances.
--   
--   We declare <a>GenFn</a> as a newtype so that we can implement
--   <a>MonadFail</a> for it, allowing us to use monadic pattern matching.
newtype GenFn a
GenFn :: StateT GenFnState Pass a -> GenFn a

-- | Run a <a>GenFn</a> computation on a procedure.
runGenFn :: VarId -> [(Binder, Type)] -> Type -> Expr Type -> TypegenInfo -> [(VarId, Type)] -> GenFn a -> Pass a

-- | Lookup some information associated with a type constructor.
getsTCon :: (TConInfo -> a) -> TConId -> GenFn a

-- | Lookup some information associated with a data constructor.
getsDCon :: (DConInfo -> a) -> DConId -> GenFn a

-- | Read and increment the number of cases in a procedure, i.e.,
--   <tt>fnCases++</tt>.
nextCase :: GenFn Int

-- | Obtain fresh integer in the <a>GenFn</a> monad
getFresh :: GenFn Int

-- | Bind a variable to a C expression.
addBinding :: Binder -> Exp -> GenFn ()

-- | Register a new local variable, to be declared in activation record.
addLocal :: VarId -> Type -> GenFn VarId

-- | Bind a variable to a C expression only while computing the given
--   monad.
withBindings :: [(Binder, Exp)] -> GenFn a -> GenFn a

-- | Register a local variable and bind its C expression during a monad.
withNewLocal :: (VarId, Type) -> GenFn a -> GenFn a

-- | Register number of wait statements track of number of triggers needed.
maxWait :: Int -> GenFn ()

-- | Generate a fresh label.
freshLabel :: GenFn CIdent

-- | Generate anonymous local variable in activation record for storage.
genTmp :: Type -> GenFn Exp

-- | Translate a list of SSM parameters to C parameters.
genParams :: [(Binder, Type)] -> [(CIdent, Type)]

-- | Translate a list of SSM local declarations to C declarations.
genLocals :: [(VarId, Type)] -> [(CIdent, Type)]

-- | Generate declarations for <tt>numTrigs</tt> triggers.
genTrigs :: Int -> [(CIdent, Type)]

-- | The constant unit value, the singleton inhabitant of the type Unit.
unit :: Exp

-- | Fake undefined value used for expressions of type Void.
undef :: Exp

-- | Generate a C compilation from an SSM program.
--   
--   Each top-level function in a program is turned into three components:
--   
--   <ol>
--   <li>a struct (the activation record);</li>
--   <li>an initialization function (the enter function); and</li>
--   <li>a step function, which corresponds to the actual procedure
--   body.</li>
--   </ol>
--   
--   Items 2 and 3 include both declarations and definitions.
genProgram :: Program Type -> Pass [Definition]

-- | Include statements in the generated C file.
includes :: [Definition]

-- | Setup the entry point of the program.
genInitProgram :: VarId -> [Definition]
genExtern :: (VarId, Type) -> Pass Definition

-- | Generate struct definition for an SSM procedure.
--   
--   This is where local variables, triggers, and parameter values are
--   stored.
genStruct :: GenFn Definition

-- | Generate the enter function for an SSM procedure and its signature.
--   
--   Its struct is allocated and initialized (partially; local variables'
--   values are left uninitialized).
genEnter :: GenFn (Definition, Definition)

-- | Generate static closure for top-level function
genStaticClosure :: GenFn (Definition, Definition)

-- | Generate the step function for an SSM procedure.
--   
--   This function just defines the function definition and switch
--   statement that wraps the statements of the procedure. The heavy
--   lifting is performed by <a>genExpr</a>.
genStep :: GenFn (Definition, Definition)

-- | Helper to generate yield point in step function.
genYield :: GenFn [BlockItem]

-- | Translate an SSM expression into a C expression and statements.
--   
--   SSM IR is a side-effectful expression language, with two implications
--   when translating to C:
--   
--   <ol>
--   <li>every expression has a value (even if it is an uninhabited type),
--   so this must be reflected in C; and</li>
--   <li>some of the side effects in SSM cannot be implemented in C using
--   expressions alone.</li>
--   </ol>
--   
--   These two implications roughly translate to the <tt>C.Exp</tt> and
--   <tt>[C.BlockItem]</tt> in <tt>genExpr</tt>'s return type. When we
--   translate an SSM expression <tt>e</tt>:
--   
--   <pre>
--   (val, stms) &lt;- genExpr e
--   </pre>
--   
--   <tt>val</tt> represents the C expression that corresponds to the value
--   of <tt>e</tt> upon evaluation, while <tt>stms</tt> represents the list
--   of preceding statements that compute <tt>val</tt>.
--   
--   A further consideration upon point 2 is that SSM expressions may yield
--   control at any point. Thus, the C expression returned by
--   <tt>genExpr</tt> must accommodate the step function suspending and
--   resuming. For instance, consider the following SSM IR expression:
--   
--   <pre>
--   (let x = 3 in x) + (wait r; 6)
--   </pre>
--   
--   The <tt>x</tt> in the let-binding in the left operand cannot just be a
--   local variable in the step function, because it would be
--   "uninitialized" by the yield in the right operand:
--   
--   <pre>
--     // let x = 3 in x
--     // stms:
--     int x = 3;
--     // exp: x
--   
--     // (wait r; 6)
--     // stms:
--     ssm_sensitize(r);
--     actg-&gt;pc = N;
--     return;
--   case N:
--     ssm_desensitize(r);
--     // exp: 6
--   
--     // After the return, x is no longer initialized, so the following is
--     // undefined behavior:
--     x + 6
--   </pre>
--   
--   To ensure this is cannot happen, we conservatively declare <tt>x</tt>
--   as a local variable in the activation record, so that its value is
--   preserved between yields, even if this is not usually necessary. We
--   leave it to later compiler passes to optimize this.
genExpr :: Expr Type -> GenFn (Exp, [BlockItem])

-- | Generate code for SSM primitive; see <a>genExpr</a> for extended
--   discussion.
genPrim :: Primitive -> [Expr Type] -> Type -> GenFn (Exp, [BlockItem])

-- | Generate C value for SSM literal, marshalled.
genLiteral :: Literal -> Exp

-- | Generate C value for SSM literal, unmarshalled.
genLiteralRaw :: Literal -> Exp

-- | Generate C expression for SSM primitive operation.
genPrimOp :: PrimOp -> [Expr Type] -> Type -> GenFn (Exp, [BlockItem])

-- | Helper for sequencing across binary operations.
genBinop :: Expr Type -> Expr Type -> GenFn ((Exp, Exp), [BlockItem])

-- | Compute priority and depth arguments for a par fork of given width.
genParArgs :: Int -> (Exp, Exp) -> [(Exp, Exp)]

-- | How much the depth should be decreased when par forking given width.
depthSub :: Int -> Exp
instance Control.Monad.Writer.Class.MonadWriter [Common.Compiler.Warning] Codegen.Codegen.GenFn
instance Control.Monad.State.Class.MonadState Codegen.Codegen.GenFnState Codegen.Codegen.GenFn
instance Control.Monad.Error.Class.MonadError Common.Compiler.Error Codegen.Codegen.GenFn
instance Control.Monad.Fail.MonadFail Codegen.Codegen.GenFn
instance GHC.Base.Monad Codegen.Codegen.GenFn
instance GHC.Base.Applicative Codegen.Codegen.GenFn
instance GHC.Base.Functor Codegen.Codegen.GenFn
instance Language.C.Quote.Base.ToExp Codegen.Codegen.EscExp


-- | Code generation (codegen) stage of the compiler pipeline.
--   
--   This module exposes some options for configuring what C code is
--   generated and how it is represented.
module Codegen

-- | Operation modes for the codegen compiler stage.
data Mode
Continue :: Mode

-- | Compiler options for the codegen compiler stage.
data Options
Options :: Mode -> Int -> Options
[mode] :: Options -> Mode
[textWidth] :: Options -> Int

-- | CLI options for the codegen compiler stage.
options :: [OptDescr (Options -> Options)]

-- | Codegen compiler stage.
run :: Options -> Program Type -> Pass String
instance GHC.Show.Show Codegen.Mode
instance GHC.Classes.Eq Codegen.Mode
instance GHC.Show.Show Codegen.Options
instance GHC.Classes.Eq Codegen.Options
instance Common.Default.Default Codegen.Options
